<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Noise and Offset in Dynamic Comparators</title>
    <url>/2023/01/06/ClockedComparators/</url>
    <content><![CDATA[<h2 id="offset">Offset</h2>
<h2 id="noise">Noise</h2>
<h3 id="transient-noise-method">transient noise method</h3>
<h3 id="pss-method">PSS method</h3>
<p><span class="math display">\[
\overline{V^2_{n,in}}=\frac{\overline{V^2_{n,out}}}{A_v}
\]</span></p>
<p><img src="/2023/01/06/ClockedComparators/image-20230106232724903.png"
alt="image-20230106232724903" /></p>
<h2 id="rx-sensitivity-and-input-referred-noise">RX sensitivity and
input referred noise</h2>
<h2 id="reference">reference</h2>
<p>J. Silva, D. Brito, G. Rodrigues, T. Rabuske, A. C. Pinto and J.
Fernandes, "Methods for Fast Characterization of Noise and Offset in
Dynamic Comparators," 2021 19th IEEE International New Circuits and
Systems Conference (NEWCAS), 2021, pp. 1-4, doi:
10.1109/NEWCAS50681.2021.9462744.</p>
<p>P. Lund, “Comparator Design for High-Speed ADCs,” Dissertation, 2022.
URL: <a
href="https://www.diva-portal.org/smash/get/diva2:1688161/FULLTEXT01.pdf">https://www.diva-portal.org/smash/get/diva2:1688161/FULLTEXT01.pdf</a></p>
<p>Art Schaldenbrand, Senior Product Manager, Keeping Things Quiet: A
New Methodology for Dynamic Comparator Noise Analysis URL:<a
href="https://www.cadence.com/content/dam/cadence-www/global/en_US/videos/tools/custom-_ic_analog_rf_design/NoiseAnalyisposting201612Chalk%20Talk.pdf">https://www.cadence.com/content/dam/cadence-www/global/en_US/videos/tools/custom-_ic_analog_rf_design/NoiseAnalyisposting201612Chalk%20Talk.pdf</a></p>
<p>Masaya Miyahara, Yusuke Asada, Daehwa Paik and Akira Matsuzawa, "A
low-noise self-calibrating dynamic comparator for high-speed ADCs," 2008
IEEE Asian Solid-State Circuits Conference, 2008, pp. 269-272, doi:
10.1109/ASSCC.2008.4708780.</p>
<p>J. Kim, B. S. Leibowitz, J. Ren and C. J. Madden, "Simulation and
Analysis of Random Decision Errors in Clocked Comparators," in IEEE
Transactions on Circuits and Systems I: Regular Papers, vol. 56, no. 8,
pp. 1844-1857, Aug. 2009, doi: 10.1109/TCSI.2009.2028449. URL:<a
href="https://people.engr.tamu.edu/spalermo/ecen689/simulation_analysis_clocked_comparators_kim_tcas1_2009.pdf">https://people.engr.tamu.edu/spalermo/ecen689/simulation_analysis_clocked_comparators_kim_tcas1_2009.pdf</a></p>
<p>Jaeha Kim, Lecture 12. Aperture and Noise Analysis of Clocked
Comparators URL:<a
href="https://ocw.snu.ac.kr/sites/default/files/NOTE/7038.pdf">https://ocw.snu.ac.kr/sites/default/files/NOTE/7038.pdf</a></p>
<p>Shanthi Pavan, NOC:Introduction to Time - Varying Electrical
Networks, IIT Madras <a
href="https://youtube.com/playlist?list=PLyqSpQzTE6M8qllAtp9TTODxNfaoxRLp9">https://youtube.com/playlist?list=PLyqSpQzTE6M8qllAtp9TTODxNfaoxRLp9</a></p>
<p>Rabuske, Taimur &amp; Fernandes, Jorge. (2014). Noise-aware
simulation-based sizing and optimization of clocked comparators. Analog
Integr. Circuits Signal Process.. 81. 723-728.
10.1007/s10470-014-0428-4.</p>
<p>Rabuske, Taimur &amp; Fernandes, Jorge. (2017), Chapter 5 Noise-Aware
Synthesis and Optimization of Voltage Comparators, "Charge-Sharing SAR
ADCs for Low-Voltage Low-Power Applications"</p>
<p>Eric Chang, EE240B Discussion 9 <a
href="https://inst.eecs.berkeley.edu/~ee240b/sp18/discussions/dis9.pdf">https://inst.eecs.berkeley.edu/~ee240b/sp18/discussions/dis9.pdf</a></p>
<p>Y. Luo, A. Jain, J. Wagner and M. Ortmanns, "Input Referred
Comparator Noise in SAR ADCs," in IEEE Transactions on Circuits and
Systems II: Express Briefs, vol. 66, no. 5, pp. 718-722, May 2019, doi:
10.1109/TCSII.2019.2909429.</p>
<p>E. Gillen, G. Panchanan, B. Lawton and D. O'Hare, "Comparison of
transient and PNOISE simulation techniques for the design of a dynamic
comparator," 2022 33rd Irish Signals and Systems Conference (ISSC),
Cork, Ireland, 2022, pp. 1-5, doi: 10.1109/ISSC55427.2022.9826195.</p>
<p>Sam Palermo Lecture 6: RX Circuits URL:<a
href="https://people.engr.tamu.edu/spalermo/ecen689/lecture6_ee689_rx_circuits.pdf">https://people.engr.tamu.edu/spalermo/ecen689/lecture6_ee689_rx_circuits.pdf</a></p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Common Innovus Commands</title>
    <url>/2022/02/07/Common-Innovus-Commands/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Common-Innovus-Commands.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Digital Delay Model</title>
    <url>/2023/11/14/DigitalModels/</url>
    <content><![CDATA[<h2 id="effective-switching-resistance">Effective Switching
resistance</h2>
<p><img src="/2023/11/14/DigitalModels/image-20231114001209252.png"
alt="image-20231114001209252" /></p>
<blockquote>
<p><a
href="https://www.eecis.udel.edu/~vsaxena/courses/ece445/s19/Lecture%20Notes/lec15_ece445.pdf">https://www.eecis.udel.edu/~vsaxena/courses/ece445/s19/Lecture%20Notes/lec15_ece445.pdf</a></p>
</blockquote>
<div class="pdf-container" data-target="/pdfs/chapter5_ex_sol.pdf" data-height="500px"></div>
<h2 id="wire-delay">wire delay</h2>
<h3 id="the-elmore-delay">The Elmore Delay</h3>
<p><img src="/2023/11/14/DigitalModels/image-20230624234813719.png"
alt="image-20230624234813719" /></p>
<p><img src="/2023/11/14/DigitalModels/image-20230624234940864.png"
alt="image-20230624234940864" /></p>
<p><img src="/2023/11/14/DigitalModels/image-20230625001756173.png"
alt="image-20230625001756173" /></p>
<blockquote>
<p>Basic idea: use of <strong>mean</strong> of <span
class="math inline">\(v&#39;(t)\)</span> to approximate
<strong>median</strong> of <span
class="math inline">\(v&#39;(t)\)</span></p>
</blockquote>
<p><img src="/2023/11/14/DigitalModels/image-20230624235148246.png"
alt="image-20230624235148246" /></p>
<p><img src="/2023/11/14/DigitalModels/image-20230625002239199.png"
alt="image-20230625002239199" /></p>
<blockquote>
<p>Elmore delay approximates the <strong>median</strong> of <span
class="math inline">\(h(t)\)</span> by the <strong>mean</strong> of
<span class="math inline">\(h(t)\)</span></p>
</blockquote>
<h3 id="distributed-rc-line">Distributed RC-Line</h3>
<p><img src="/2023/11/14/DigitalModels/image-20230624224005736.png"
alt="image-20230624224005736" /></p>
<h3 id="lumped-approximations">Lumped approximations</h3>
<h4 id="rc-models"><span class="math inline">\(rc\)</span>-models</h4>
<p>If your simulator does not support a distributed <span
class="math inline">\(rc\)</span>-model, or if the computational
complexity of these models slows down your simulation too much, you can
construct a simple yet accurate model yourself by approximating the
distributed <span class="math inline">\(rc\)</span> by a lumped RC
network with a limited number of elements</p>
<p><img src="/2023/11/14/DigitalModels/image-20230624230057265.png"
alt="image-20230624230057265" /></p>
<blockquote>
<p>The accuracy of the model is determined by the number of stages. For
instance, the error of the <span class="math inline">\(\Pi -3\)</span>
model is less than 3%, which is generally sufficient.</p>
</blockquote>
<h4 id="why-use-pi-model">Why use "<span
class="math inline">\(\Pi\)</span> Model"</h4>
<p><img src="/2023/11/14/DigitalModels/image-20230624230800255.png"
alt="image-20230624230800255" /></p>
<h4 id="examples">examples</h4>
<p><img src="/2023/11/14/DigitalModels/image-20230624224643487.png"
alt="image-20230624224643487" /></p>
<p><img src="/2023/11/14/DigitalModels/image-20230624224923241.png"
alt="image-20230624224923241" /></p>
<h2 id="wire-inductive-effect">Wire Inductive Effect</h2>
<ul>
<li>RC delay increases quadratically with length</li>
<li>LC delay (speed of light flight time) increases linearly with
length</li>
</ul>
<blockquote>
<p>Inductance will only be important to the delay of low-resistance
signals such as wide clock lines</p>
</blockquote>
<h3 id="wave">wave</h3>
<p>Signal propagates over the wire as a <strong>wave</strong> (rather
than <strong>diffusing</strong> as in <span
class="math inline">\(rc\)</span> only models)</p>
<blockquote>
<p>Signal propagates by alternately transferring energy from capacitive
to inductive modes</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Akio Kitagawa, Analog layout design <a
href="https://mixsignal.files.wordpress.com/2013/03/analog-layout.pdf">https://mixsignal.files.wordpress.com/2013/03/analog-layout.pdf</a></p>
<p>THE WIRE <a
href="http://bwrcs.eecs.berkeley.edu/Classes/icdesign/ee141_f01/Notes/chapter4.pdf">http://bwrcs.eecs.berkeley.edu/Classes/icdesign/ee141_f01/Notes/chapter4.pdf</a></p>
<p>Anoop Veliyath, Design Engineer, Cadence Design Systems. Accurately
Modeling Transmission Line Behavior with an LC Network-based Approach
[<a
href="https://www.pspice.com/sites/default/files/Transmission_Line_Modeling.pdf">pdf</a>]</p>
<p>Mark Horowitz. Lecture 2: Wires and Wire Models [<a
href="https://web.stanford.edu/class/archive/ee/ee371/ee371.1066/lectures/Old/lect_02.pdf">pdf</a>]</p>
<p>Neil Weste and David Harris. 2010. CMOS VLSI Design: A Circuits and
Systems Perspective (4th. ed.). Addison-Wesley Publishing Company,
USA.</p>
<p>Cheng-Kok Koh. EE695K Modeling and Optimization of High Performance
Interconnect [<a
href="https://engineering.purdue.edu/~chengkok/ee695K/lec3a.pdf">lec3a_pdf</a>]</p>
<p>Vishal Saxena. ECE 445 Intro to VLSI Design: Lectures for Spring 2019
<a
href="https://www.eecis.udel.edu/~vsaxena/courses/ece445/s19/ECE445.htm">https://www.eecis.udel.edu/~vsaxena/courses/ece445/s19/ECE445.htm</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>How does EDI System identify spare cells in a post-mask ECO flow?</title>
    <url>/2022/03/06/EDI-post-mask-ECO-sparecell/</url>
    <content><![CDATA[<h4
id="how-does-edi-system-identify-spare-cells-in-a-post-mask-eco-flow">How
does EDI System identify spare cells in a post-mask ECO flow?</h4>
<p>Spare cells should have a unique string in their instance name to
identify them. Then the command <code>specifySpareGate</code> or
<code>ecoDesign -useSpareCells patternName</code> is run to identify the
spare instances. For example, if all spare cells have _spare_ in their
name then they are identified using:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">specifySpareGate -inst *_spare_*</span><br></pre></td></tr></table></figure>
<p>OR</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">ecoDesign -spareCells *_spare_* ...</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: if you are making <strong>manual ECO</strong>
changes to a netlist and converting a spare cell to a logical instance,
<strong>it's important to change the instance name</strong>. Otherwise,
the instance may be identified as a spare cell if a future ECO is
performed because it still has the spare cell instance name.</p>
<h4 id="example">Example</h4>
<h5 id="the-cell-to-be-swapped-is-unplaced">The cell to be swapped is
unplaced</h5>
<p><img
src="/2022/03/06/EDI-post-mask-ECO-sparecell/image-20220307002842020.png"
alt="image-20220307002842020" /></p>
<p>pre_buf: <strong>unplaced</strong></p>
<p>spare_buf: <strong>placed</strong></p>
<blockquote>
<p>innovus 49&gt; dbGet top.insts.name</p>
<p><strong>spare_buf</strong> <strong>pre_buf</strong> UDriver USink</p>
<p>innovus 50&gt; dbGet top.insts.</p>
<p><strong>0x7f7b03ef60e0</strong> <strong>0x7f7b03ef6150</strong>
0x7f7b03ef6000 0x7f7b03ef6070</p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">specifySpareGate -inst spare_*</span><br><span class="line">ecoSwapSpareCell pre_buf spare_buf</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/06/EDI-post-mask-ECO-sparecell/image-20220307003059068.png"
alt="image-20220307003059068" /></p>
<blockquote>
<p>innovus 55&gt; dbGet top.insts.name</p>
<p><strong>pre_buf</strong> UDriver USink</p>
<p>innovus 56&gt; dbGet top.insts.</p>
<p><strong>0x7f7b03ef6150</strong> 0x7f7b03ef6000 0x7f7b03ef6070</p>
<p>innovus 57&gt; dbGet top.insts.Pstatus</p>
<p><strong>placed</strong> fixed fixed</p>
</blockquote>
<p><strong>Note</strong>: sparecell's pointer and name is swapped with
the unplaced cell.</p>
<h5 id="the-cell-to-be-swapped-is-placed">The cell to be swapped is
placed</h5>
<p><img
src="/2022/03/06/EDI-post-mask-ECO-sparecell/image-20220307004654614.png"
alt="image-20220307004654614" /></p>
<blockquote>
<p>innovus 62&gt; dbGet top.insts.name</p>
<p><strong>spare_buf</strong> <strong>pre_buf</strong> UDriver USink</p>
<p>innovus 63&gt; dbGet top.insts.</p>
<p><strong>0x7f7b03ef60e0</strong> <strong>0x7f7b03ef6150</strong>
0x7f7b03ef6000 0x7f7b03ef6070</p>
<p>innovus 64&gt; dbGet top.insts.pStatus</p>
<p><strong>placed</strong> <strong>placed</strong> fixed fixed</p>
</blockquote>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">innovus <span class="number">66</span>&gt; specifySpareGate -inst spare_*</span><br><span class="line">Specifying instance [spare_buf] as spare gate.</span><br><span class="line">Specified <span class="number">1</span> instances as spare gate.</span><br><span class="line">innovus <span class="number">67</span>&gt; ecoSwapSpareCell pre_buf spare_buf</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/06/EDI-post-mask-ECO-sparecell/image-20220307005254488.png"
alt="image-20220307005254488" /></p>
<blockquote>
<p>innovus 68&gt; dbGet top.insts.name</p>
<p><strong>spare_buf pre_buf</strong> UDriver USink</p>
<p>innovus 69&gt; dbGet top.insts.</p>
<p><strong>0x7f7b03ef60e0 0x7f7b03ef6150</strong> 0x7f7b03ef6000
0x7f7b03ef6070</p>
<p>innovus 70&gt; dbGet top.insts.pStatus</p>
<p>placed placed fixed fixed</p>
</blockquote>
<p><strong>Note</strong>: sparecell's pointer and name is swapped with
the placed cell.</p>
<h5 id="error-in-innovus-text-command-reference-21.12">Error in "Innovus
Text Command Reference 21.12"</h5>
<p><strong>ecoSwapSpareCell</strong></p>
<p><del>If the cell to be swapped is unplaced, it is mapped to the spare
cell. <code>*instName*</code> is deleted, and its connection is
transferred to the spare cell. If the cell to be swapped is placed, it
is swapped with the spare cell and is renamed to
<code>*instNameSuffix*</code> if the <code>-suffix</code> option is
used. If a suffix is not specified, the <code>*instName*</code> cell is
renamed to <code>*spareCellInstName*</code>. The <code>*instName*</code>
cell's connections are transferred to <code>*spareCellInstName*</code>.
The input of <code>*instName*</code> is <code>tielo</code>, based on the
global connection definition.</del></p>
<p><strong>reference:</strong></p>
<p><a
href="https://community.cadence.com/cadence_blogs_8/b/di/posts/answers-to-frequently-asked-questions-when-performing-ecos-in-edi-system">Answers
to Top 10 Questions on Performing ECOs in EDI System</a></p>
<p><a
href="https://eecs.wsu.edu/~daehyun/teaching/2014_EE582/assignments/a10/a10.html">EE
582: Physical Design Automation of VLSI Circuits and Systems</a></p>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Efficient Sequence Objection in UVM</title>
    <url>/2022/02/21/Efficient-Sequence-Objection/</url>
    <content><![CDATA[<p>Objections are handled in <strong>pre/post body</strong> decalared in
a base sequence class</p>
<p>This is efficient for all sequence execution options:</p>
<ul>
<li><p>Default sequences use body objections</p></li>
<li><p>Test sequences use test objections</p></li>
<li><p>Subsequences use objections of the root sequence which calls
them</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_base_seq <span class="keyword">extends</span> uvm_sequence<span class="variable">#(yapp_packet)</span>;</span><br><span class="line">…</span><br><span class="line">    <span class="keyword">task</span> pre_body();</span><br><span class="line">        <span class="keyword">if</span>(starting_phase != <span class="literal">null</span>);</span><br><span class="line">        	starting_phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>, get_type_name());</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span> post_body();</span><br><span class="line">    	<span class="keyword">if</span>(starting_phase != <span class="literal">null</span>);</span><br><span class="line">    		starting_phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>, get_type_name());	</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">class</span> yapp012 <span class="keyword">extends</span> yapp_base_seq;</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p><strong>Set as default sequence of sequencer:</strong></p>
<p>A default sequence is a root sequence, so the <strong>pre/post
body</strong> methods are executed and objection are raised/dropped
there</p>
<p><strong>Test sequence:</strong></p>
<p>A test sequence is a root sequence, so the <strong>pre/post
body</strong> methods are executed. However, for a test sequence,
<code>starting_phase</code> is <code>null</code> and so the objection is
not handled in the sequence. The test must raise and drop objections</p>
<p><strong>Subsequence:</strong></p>
<p>Not a root sequence, so <strong>pre/post body</strong> methods are
not executed. The root sequence which ultimately called the subsequence
handles the objections, using one of the two options above.</p>
<blockquote>
<p>If a <strong>sequence</strong> is call via a <strong>`uvm_do</strong>
variant, the it is defined as a subsequence and its
<strong>pre/post_body()</strong> methods are not executed.</p>
</blockquote>
<p><strong>objection change in UVM1.2</strong></p>
<p>Raising or dropping objections directly from
<code>starting_phase</code> is deprecated</p>
<ul>
<li><p>must use <code>get_starting_phase()</code> method</p></li>
<li><p>prevents modification of phase during sequence</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> pre_body();</span><br><span class="line">    uvm_phase sp = get_starting_phase();</span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">null</span>)</span><br><span class="line">        sp<span class="variable">.raise_objection</span>(<span class="keyword">this</span>, get_type_name());</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Custom Design with FinFETs</title>
    <url>/2022/12/10/FinFET-Considerations/</url>
    <content><![CDATA[<h2 id="design-considerations">Design Considerations</h2>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20221210165644336.png"
alt="image-20221210165644336" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20221210165916985.png"
alt="image-20221210165916985" /></p>
<h2 id="modeling-consideration">Modeling Consideration</h2>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20221217152830191.png"
alt="image-20221217152830191" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20221210170042233.png"
alt="image-20221210170042233" /></p>
<p><img src="/2022/12/10/FinFET-Considerations/mos_pro.drawio.svg"
alt="mos_pro" /> <span class="math display">\[\begin{align}
R_{d1} &amp;\propto \frac{1}{N_{fins}} \\
R_{s1} &amp;\propto \frac{1}{N_{fins}} \\
R_{g1} &amp;\propto N_{fins} \\
C_{gd} &amp;\propto N_{fins} \cdot N_{fingers} \cdot N_{multipler} \\
C_{gs} &amp;= Cgd \\
C_{g1d} &amp;\propto N_{fins} \\
C_{g1s} &amp;= C_{g1d} \\
C_{g1d1} &amp;\propto N_{fins} \\
C_{g1s1} &amp;= C_{g1d1}  \\
C_{g1d1} &amp;\simeq 2\times C_{g1d}
\end{align}\]</span></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230708221056420.png"
alt="image-20230708221056420" /></p>
<h2 id="layout-consideration">Layout Consideration</h2>
<h3 id="pode-cpode">PODE &amp; CPODE</h3>
<blockquote>
<p>The PODE devices is extracted as parasitic devices in post-layout
netlist</p>
</blockquote>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20220213172653116.png"
alt="image-20220213172653116" /></p>
<p><strong>DDB</strong> is the <strong>PODE</strong> (Poly on
OD/Diffusion Edge) in TSMC 16FFC process.</p>
<p><strong>SDB</strong> is the <strong>CPODE</strong> (Connected PODE)
in TSMC 16FFC process.</p>
<blockquote>
<p>PO on OD edge (PODE) is a must and to define GATE that abuts OD
vertical edge</p>
<p>CPODE is used to connect two PODE cells together. It will isolate OD
to save 1 poly pitch, via STI; Additional mask (12N) is required for
manufacture</p>
</blockquote>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20221210145232826.png"
alt="image-20221210145232826" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20221210150847737.png"
alt="image-20221210150847737" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20240509205506112.png"
alt="image-20240509205506112" /></p>
<h3 id="sac-sagc">SAC &amp; SAGC</h3>
<h4 id="self-aligned-diffusion-contacts-sacs">self-aligned diffusion
contacts (SACs)</h4>
<p>As shown in Fig. 35 in older planar technology nodes, gate pitch is
so relaxed such that S/D contacts and gate contacts can easily be placed
next to each other without causing any shorting risk (see Fig.
35(a)).</p>
<p><strong>As the gate pitch scales, there’s no room to put gate
contacts next to S/D contacts, and gatecontacts have been pushed away
from the active region and are only placed on the STI
region.</strong></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230708221916716.png"
alt="image-20230708221916716" /></p>
<p>In addition, at tight gate pitch, even forming <em>S/D contact</em>
without shorting to <em>gate metal</em> becomes very challenging.</p>
<p>The idea of <strong>self-aligned contacts (SAC)</strong> has been
introduced to mitigate the issue of S/D contact to gate shorts.</p>
<p>As shown in Fig. 35(b), <em>the gate metal is fully encapsulated by a
dielectric spacer and gate cap</em>, which protects the gate from
shorting to the S/D contact.</p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230708230238362.png"
alt="image-20230708230238362" /></p>
<blockquote>
<p>A dielectric cap is added on top of the gate so that if the contact
overlaps the gate, no short occurs.</p>
<p><strong>MD</strong> layer represent SACs in PDK</p>
</blockquote>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230709005334372.png"
alt="image-20230709005334372" /></p>
<h4 id="self-aligned-gate-contacts-sagcs">self-aligned gate contacts
(SAGCs)</h4>
<p><strong>Self-aligned gate contacts (SAGCs)</strong> have also been
implemented and Denser standard cells can be achieved by eliminating the
need to land contacts on the gate outside the active area.</p>
<p>SAGCs require the source/drain contacts to be capped with an
insulator that is different from both contact and gate cap dielectrics
to protect the source/drain contacts against a misaligned gate contact
etch.</p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230708233009568.png"
alt="image-20230708233009568" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230708232429240.png"
alt="image-20230708232429240" /></p>
<blockquote>
<p>According to the DRC of T foundary, poly extension &gt; 0 um and
space between MP and OD &gt; 0 um., which demonstrate self-aligned gate
contact is <strong>not</strong> introduced.</p>
</blockquote>
<h5 id="contacted-poly-pitch-cpp">Contacted-Poly-Pitch (CPP)</h5>
<blockquote>
<p>Wider Contacted-Poly-Pitch allows wider MD and VD size, which help
reduce MEOL IRdrop</p>
</blockquote>
<p><img
src="https://www.imec-int.com/_next/image?url=%2Fsites%2Fdefault%2Ffiles%2F2022-02%2FFigure%25201%2520-%2520Logic%2520standard%2520cell%2520scaling.JPG&amp;w=3840&amp;q=75"
alt="Schematic representation of a logic standard cell layout (CPP = contacted poly pitch, FP = fin pitch, MP = metal pitch; cell height = number of metal lines per cell x MP)." /></p>
<p><em>Naoto Horiguchi. Entering the Nanosheet Transistor Era [<a
href="https://www.imec-int.com/en/articles/entering-nanosheet-transistor-era-0">link</a>]</em></p>
<h3 id="gate-resistance">Gate Resistance</h3>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230709000326683.png"
alt="image-20230709000326683" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230709004432013.png"
alt="image-20230709004432013" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230709000637817.png"
alt="image-20230709000637817" /></p>
<p><img
src="/2022/12/10/FinFET-Considerations/image-20230709003917922.png"
alt="image-20230709003917922" /></p>
<h4 id="non-quasistatic-nqs-effect">non-quasistatic (NQS) effect</h4>
<h2 id="reference">reference</h2>
<p>Tom Quan, TSMC, Bob Lefferts, Fred Sendig, Synopsys, Custom Design
with FinFETs - Best practices designing mixed-signal IP</p>
<p>Jacob, Ajey &amp; Xie, Ruilong &amp; Sung, Min &amp; Liebmann, Lars
&amp; Lee, Rinus &amp; Taylor, Bill. (2017). Scaling Challenges for
Advanced CMOS Devices. International Journal of High Speed Electronics
and Systems. 26. 1740001. 10.1142/S0129156417400018.</p>
<p>Joddy Wang, Synopsys <a
href="https://www.mos-ak.org/washington_dc_2015/presentations/T03_Joddy_Wang_MOS-AK_Washington_DC_2015.pdf">"FinFET
SPICE Modeling"</a> Modeling of Systems and Parameter Extraction Working
Group 8th International MOS-AK Workshop (co-located with the IEDM
Conference and CMC Meeting) Washington DC, December 9 2015</p>
<p>A. L. S. Loke et al., "Analog/mixed-signal design challenges in 7-nm
CMOS and beyond," 2018 IEEE Custom Integrated Circuits Conference
(CICC), San Diego, CA, USA, 2018, pp. 1-8, doi:
10.1109/CICC.2018.8357060.[<a
href="https://ewh.ieee.org/r6/san_diego/sscs/events/slides/2018_05_23_AMSDesignChallengesIn7nmCMOS_AlvinLoke.pdf">slides</a>]</p>
<p>Prof. Adam Teman, Advanced Process Technologies, [<a
href="https://www.eng.biu.ac.il/temanad/files/2022/03/Lecture-2-Advanced-Process-Technologies.pdf">pdf</a>]</p>
<p>Luke Collins. FinFET variability issues challenge advantages of new
process [<a
href="https://www.techdesignforums.com/blog/2014/04/16/finfet-variability-challenges-advantages/">link</a>]</p>
<p>Loke, Alvin. (2020). FinFET technology considerations for circuit
design (invited short course). BCICTS 2020 Monterey, CA</p>
<p>Alvin Leng Sun Loke, TSMC. Device and Physical Design Considerations
for Circuits in FinFET Technology", ISSCC 2020</p>
<p>Prof. Adam Teman. Advanced Process Technologies [<a
href="https://www.eng.biu.ac.il/temanad/files/2022/03/Lecture-2-Advanced-Process-Technologies.pdf">pdf</a>]</p>
<p>A. L. S. Loke, C. K. Lee and B. M. Leary, "Nanoscale CMOS
Implications on Analog/Mixed-Signal Design," 2019 IEEE Custom Integrated
Circuits Conference (CICC), Austin, TX, USA, 2019, pp. 1-57, doi:
10.1109/CICC.2019.8780267.</p>
<p>A. L. S. Loke, Migrating Analog/Mixed-Signal Designs to FinFET Alvin
Loke / Qualcomm. 2016 Symposia on VLSI Technology and Circuits</p>
<p>Lattice Semiconductor, 16FFC Process Technology Introduction December
9th, 2021[<a
href="https://cdn.latticesemi-insights.com/wp-content/uploads/2024/01/29174339/HR1000000009.pdf">pdf</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Global Handles in UVM</title>
    <url>/2022/02/23/Global-Handles-UVM/</url>
    <content><![CDATA[<h4 id="mechanism-in-uvm-1.1">Mechanism in UVM-1.1</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> test_base::start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">	<span class="keyword">super</span><span class="variable">.start_of_simulation_phase</span>(phase);</span><br><span class="line">	uvm_top<span class="variable">.print_topology</span>(); <span class="comment">// Will not compile in UVM-1.2</span></span><br><span class="line">	factory<span class="variable">.print</span>(); <span class="comment">// Will not compile in UVM-1.2</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Global handles uvm_top and factory in uvm_pkg have been removed in
UVM-1.2 and later</p>
</blockquote>
<h4 id="mechanism-in-uvm-1.1-and-uvm-1.2">Mechanism in UVM-1.1 and
UVM-1.2</h4>
<p>Call the <strong>get() method of the class</strong> to retrieve the
singleton handle.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> test_base::start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">	<span class="keyword">super</span><span class="variable">.start_of_simulation_phase</span>(phase);</span><br><span class="line">	uvm_root::get()<span class="variable">.print_topology</span>(); <span class="comment">// Works in UVM-1.1 &amp; UVM-1.2</span></span><br><span class="line">	uvm_factory::get()<span class="variable">.print</span>(); <span class="comment">// Works in UVM-1.1 &amp; UVM-1.2</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h4 id="mechanism-only-in-uvm-1.2">Mechanism Only in UVM-1.2</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> test_base::start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">	uvm_coreservice_t cs = uvm_coreservice_t::get();</span><br><span class="line">	cs<span class="variable">.get_root</span>()<span class="variable">.print_topology</span>();</span><br><span class="line">	cs<span class="variable">.get_factory</span>()<span class="variable">.print</span>();</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p><strong>uvm_coreservice_t</strong> is the uvm-1.2 mechanism for
accessing all the central UVM services such as
<strong>uvm_root</strong>,<strong>uvm_factory</strong>,
<strong>uvm_report_server</strong>, etc.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using the uvm_coreservice_t:</span></span><br><span class="line">uvm_coreservice_t cs;</span><br><span class="line">uvm_factory f;</span><br><span class="line">uvm_root top;</span><br><span class="line">cs = uvm_coreservice_t::get();</span><br><span class="line">f = cs<span class="variable">.get_factory</span>();</span><br><span class="line">top = cs<span class="variable">.get_root</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>INL, DNL analysis of current steering DAC</title>
    <url>/2022/02/13/INL-DNL-analysis-of-current-steering-DAC/</url>
    <content><![CDATA[<h2 id="mos-mismatch">MOS mismatch</h2>
<div class="pdf-container" data-target="/pdfs/mos_mismatch.pdf" data-height="500px"></div>
<h2 id="current-mirror-mismatch-analysis">Current mirror mismatch
analysis</h2>
<div class="pdf-container" data-target="/pdfs/Current_mirror_mismatch_analysis.pdf" data-height="500px"></div>
<h2 id="inldnl-analysis-of-current-steering-dac">INL/DNL analysis of
current steering DAC</h2>
<div class="pdf-container" data-target="/pdfs/INL_DNL_analysis_of_current_steering_DAC.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Clock Concurrent Optimization Technology (CCOpt)</title>
    <url>/2022/02/07/Innovus-Clock-Concurrent-Optimization-Technology/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_Clock_Concurrent_Optimization_Technology.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Database Navigation</title>
    <url>/2022/02/07/Innovus-Database-Navigation/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_Database_Navigation.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus ECO</title>
    <url>/2022/02/07/Innovus-ECO/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_ECO.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Parasitic Extraction</title>
    <url>/2022/02/07/Innovus-Parasitic-Extraction/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_Parasitic_Extraction.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Path Based Analysis</title>
    <url>/2022/02/07/Innovus-Path-Based-Analysis/</url>
    <content><![CDATA[<p><strong>aocv</strong> : Re-timing the timing critical paths using the
LOCV deratingfactors</p>
<p><strong>path_slew_propagation</strong> : Re-timing the timing
critical paths using the actual slews for thepath</p>
<p><strong>aocv_path_slew_propagation</strong> : Combination of
re-timing with aocv + path_slew_propagation</p>
<p><strong>waveform_propagation</strong> : Re-timing with waveform
effect taken into consideration during delayCal</p>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Technology File</title>
    <url>/2022/02/07/Innovus-Technology-File/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_Technology_File.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus/Tempus Nonfunctional ECO</title>
    <url>/2022/02/07/Innovus-Tempus-Nonfunctional-ECO/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus-Tempus_Nonfunctional_ECO.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Analysis Command</title>
    <url>/2022/02/07/Innovus-analysis-command/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_analysis_command.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus block level create Power Ground Pin method</title>
    <url>/2022/02/10/Innovus-block-level-PGPin/</url>
    <content><![CDATA[<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">editStretch x ...</span><br><span class="line">selectWire ... VDD</span><br><span class="line">selectWire ... GND</span><br><span class="line">createPGPin -selected -onDie</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/02/10/Innovus-block-level-PGPin/createPGPin_onDie.drawio.svg"
alt="createPGPin_onDie.drawio" /></p>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus check mode variants</title>
    <url>/2022/02/07/Innovus-check-mode-variants/</url>
    <content><![CDATA[<p>checkDesign</p>
<p>check_timing</p>
<p>checkPlace</p>
<p>setDesignMode</p>
<p>setFPlanMode</p>
<p>setEcoMode</p>
<p>setPlaceMode</p>
<p>setRouteMode</p>
<p>setExtractRCMode</p>
<p>setOptMode</p>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Data Exchange</title>
    <url>/2022/02/07/Innovus-data-exchange/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_data_exchange.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Fix DRC Violation</title>
    <url>/2022/02/07/Innovus-fix-DRC-violation/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clearDrc</span><br><span class="line">set drc_marker_file calibre_drc_markers.err</span><br><span class="line">loadViolationReport -type Calibre -filename $drc_marker_file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foreach marker_id [dbGet -p -e top.markers.userOriginator Calibre] &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">editSelect -area [dbget $object.box] -layer M4</span><br><span class="line"></span><br><span class="line">dbSet [dbGet -p top.nets.name $net ].wires.status routed</span><br><span class="line"></span><br><span class="line">editTrim -selected</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus Floorplan</title>
    <url>/2022/02/07/Innovus-floorplan/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_floorplan.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus global and localSkew</title>
    <url>/2022/02/07/Innovus-global-and-localSkew/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_global_and_localSkew.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Innovus timeDesign vs. report_timing</title>
    <url>/2022/02/07/Innovus-timeDesign-vs-report-timing/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/Innovus_timeDesign_vs_report_timing.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>MOS Capacitor</title>
    <url>/2022/09/24/MOS-Cap/</url>
    <content><![CDATA[<h2 id="dsb-varactors">D=S=B varactors</h2>
<p><img src="/2022/09/24/MOS-Cap/image-20220924003223575.png"
alt="image-20220924003223575" /></p>
<hr />
<h2 id="inversion-mode-i-mos">Inversion-mode (I-MOS)</h2>
<p><img src="/2022/09/24/MOS-Cap/image-20220924003314979.png"
alt="image-20220924003314979" /></p>
<hr />
<h2 id="accumulation-mode-a-mos">Accumulation-mode (A-MOS)</h2>
<blockquote>
<p>NMOS in NWELL, aka <strong>NMOS in N-Well varactor</strong></p>
<p><strong>Notice: S/D and NWELL are connected togethor</strong> in
layout</p>
</blockquote>
<p><img src="/2022/09/24/MOS-Cap/image-20230504221234639.png"
alt="image-20230504221234639" /></p>
<p><img src="/2022/09/24/MOS-Cap/image-20230504221313785.png"
alt="image-20230504221313785" /></p>
<p><img src="/2022/09/24/MOS-Cap/image-20220924004206116.png"
alt="image-20220924004206116" /></p>
<p><img src="/2022/09/24/MOS-Cap/image-20240117230001916.png"
alt="image-20240117230001916" /></p>
<h3 id="pdk-varactor">PDK varactor</h3>
<blockquote>
<p>nmoscap: NMOS in <strong>N-Well</strong> varactor</p>
</blockquote>
<p><img src="/2022/09/24/MOS-Cap/image-20230504223522225.png"
alt="image-20230504223522225" /></p>
<blockquote>
<p>pmoscap: PMOS in <strong>P-Well</strong> varactor</p>
</blockquote>
<h2 id="mos-device-as-capacitor">MOS Device as Capacitor</h2>
<p><img src="/2022/09/24/MOS-Cap/image-20240115225644183.png"
alt="image-20240115225644183" /></p>
<p><img src="/2022/09/24/MOS-Cap/image-20240115225928617.png"
alt="image-20240115225928617" /></p>
<p><img src="/2022/09/24/MOS-Cap/image-20240115225853721.png"
alt="image-20240115225853721" /></p>
<hr />
<h2 id="voltage-dependence">Voltage dependence</h2>
<p><img src="/2022/09/24/MOS-Cap/image-20240115230113523.png"
alt="image-20240115230113523" /></p>
<p><img src="/2022/09/24/MOS-Cap/image-20231103213004806.png"
alt="image-20231103213004806" /></p>
<ul>
<li><p>capacitance of MOS gate varies <strong>nonmonotonically</strong>
with <span class="math inline">\(V_{GS}\)</span></p></li>
<li><p>"accumulation-mode" varactor varies
<strong>monotonically</strong> with <span
class="math inline">\(V_{GS}\)</span></p></li>
</ul>
<h2 id="inverter-capacitance">Inverter capacitance</h2>
<p><img src="/2022/09/24/MOS-Cap/invCap.png" alt="invCap" /></p>
<h2 id="reference">reference</h2>
<p>R. L. Bunch and S. Raman, "Large-signal analysis of MOS varactors in
CMOS -G/sub m/ LC VCOs," in IEEE Journal of Solid-State Circuits, vol.
38, no. 8, pp. 1325-1332, Aug. 2003, doi: 10.1109/JSSC.2003.814416.</p>
<p>T. Soorapanth, C. P. Yue, D. K. Shaeffer, T. I. Lee and S. S. Wong,
"Analysis and optimization of accumulation-mode varactor for RF ICs,"
1998 Symposium on VLSI Circuits. Digest of Technical Papers (Cat.
No.98CH36215), 1998, pp. 32-33, doi: 10.1109/VLSIC.1998.687993. URL: <a
href="http://www-smirc.stanford.edu/papers/VLSI98s-chet.pdf">http://www-smirc.stanford.edu/papers/VLSI98s-chet.pdf</a></p>
<p>R. Jacob Baker, 6.1 MOSFET Capacitance Overview/Review, CMOS Circuit
Design, Layout, and Simulation, Fourth Edition</p>
<p>B. Razavi, Design of Analog CMOS Integrated Circuits 2nd</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Frequency Stability of Multipath ring oscillators(MPRO)</title>
    <url>/2022/03/06/MPRO-frequency-stability/</url>
    <content><![CDATA[<blockquote>
<p>A problem associated with the design of MPROs is the existence of
different possible modes of oscillation. Each of these modes is
characterized by a different frequency, phase shift and phase noise.</p>
</blockquote>
<h4 id="linear-delay-stage-model-mode-gain">Linear delay-stage model
(mode gain)</h4>
<p><strong>mode gain</strong> is based on the linear model, independent
of process but depends on coupling structure (coupling configuration,
size ratio).</p>
<p>The inverting buffer modeled as a linear transconductor. The
input-output relationship of a single buffer scaled by <span
class="math inline">\(h_i\)</span> and driving the input capacitance of
a similar buffer can be expressed as <span
class="math display">\[\begin{align}
h_ig_mv_{in}(t) + h_ig_oV_{out}(t)+h_iC_g\frac {dV_{out}(t)}{dt} &amp;=
0 \\
a_nV_{in}(t)+V_{out}(t)+\tau \frac {V_{out}(t)}{dt} &amp;= 0
\end{align}\]</span> where <span class="math inline">\(g_m\)</span> is
the transconductance, <span class="math inline">\(g_o\)</span> is the
output conductance, <span class="math inline">\(C_g\)</span> is the
buffer input capacitance which also acts as the load capacitance for the
driving buffer, and <span class="math inline">\(a_n = \frac
{g_m}{g_o}\)</span> is the <strong>linear dc gain</strong> of the
buffer, and <span class="math inline">\(\tau=\frac {C_g}{g_o}\)</span>
is a time constant.</p>
<p>Similarly, <span class="math inline">\(V_1\)</span>, the output of
the first stage in MPRO can be expressed <span class="math display">\[
\sum_{i=1}^{N}h_ig_mV_i(t)+\sum_{i=1}^{N}h_ig_oV_i(t)+\sum_{i=1}^{N}h_iC_g\frac
{dV_it(t)}{dt} = 0
\]</span> Defining the fractional sizing factors and the total sizing
factor as <span class="math inline">\(x_i=\frac{h_i}{H}\)</span> and
<span class="math inline">\(H=\sum_{i=1}^{N}h_i\)</span> <span
class="math display">\[
a_n\sum_{i=1}^{N}x_iV_i(t) + V_1(t)+\tau\frac {dV_i(t)}{dt} = 0
\]</span> where <span class="math inline">\(a_n = \frac
{g_m}{g_o}\)</span> and <span class="math inline">\(\tau=\frac
{C_g}{g_o}\)</span> are same dc gain and time constant defined
previously</p>
<p>Since the total phase shift around the loop should be multiples of
<span class="math inline">\(2\pi\)</span>, the oscillation waveform at
the <em>i</em>th node can be expressed as <span class="math display">\[
V_i(t) = V_o \cos(\omega_nt-\Delta \varphi \cdot i)
\]</span> where <span class="math inline">\(\omega_n\)</span> is the
oscillation frequency and <span class="math inline">\(\Delta \varphi =
\frac {2\pi n}{N}\)</span>, <span class="math inline">\(N\)</span> is
the number of stages in the oscillator and <span
class="math inline">\(n\)</span> can take values between <span
class="math inline">\(0\)</span> and <span
class="math inline">\(N-1\)</span></p>
<p>Plug <span class="math inline">\(V_i(t)\)</span> into differential
equation, we get <span class="math display">\[
a_n\sum_{i=1}^{N}x_i\cos(\omega_n t-\frac{2\pi n}{N}i)+\cos(\omega_n
t-\frac{2\pi n}{N}) - \omega_n \tau \sin(\omega_n t-\frac{2\pi n}{N}) =
0
\]</span> By equating the <span class="math inline">\(cos(\omega_n
t)\)</span> and <span class="math inline">\(sin(\omega_n t)\)</span>
terms of the above equation, we get expressions for <strong>the
oscillation frequency of the <em>n</em>th mode</strong> and <strong>the
minimum dc gain required for this mode to exist</strong>. we refer to
this gain as the <strong>mode gain</strong> <span
class="math display">\[\begin{align}
\omega_n\tau &amp;= \frac {\sum_{i=1}^{N}x_i \cdot \sin(\frac{2\pi
n}{N}(i-1))}{-\sum_{i=1}^{N}x_i \cdot \cos(\frac{2\pi n}{N}(i-1))} \\
a_n &amp;= \frac {1}{-\sum_{i=1}^{N}x_i \cdot \cos(\frac{2\pi
n}{N}(i-1))}
\end{align}\]</span> where <span class="math inline">\(a_n\)</span>
should be greater than <span class="math inline">\(0\)</span> for a
existent mode</p>
<p>In practice, the oscillator starts first from a linear mode of
operation where all the buffers are indeed acting as linear
transconductors. All oscillation modes that have mode gains <span
class="math inline">\(a_n\)</span> lower than the actual dc gain of the
inverter <span class="math inline">\(a_o\)</span> start to grow. As the
oscillation amplitude grows, the effective gain of the inverter drops
due to nonlinearity. Consequently, <em>modes with higher mode gain die
out and only the mode that requires the minimum gain continues to
oscillate and hence is the dominant mode</em></p>
<p>A. A. Hafez and C. K. Yang, "Design and Optimization of Multipath
Ring Oscillators," in IEEE Transactions on Circuits and Systems I:
Regular Papers, vol. 58, no. 10, pp. 2332-2345, Oct. 2011, doi:
10.1109/TCSI.2011.2142810.</p>
<h4 id="simulation-based-approach">Simulation-based approach</h4>
<p><strong>GCHECK</strong> is an automated verification tool that
validate whether a ring oscillator always converges to the desired mode
of operation regardless of <strong>the initial conditions</strong> and
<strong>variability conditions</strong>. This is the first tool ever
reported to address the global convergence failures in presence of
variability. It has been shown that the tool can successfully validate a
number of coupled ring oscillator circuits with various global
convergence failure modes (e.g. no oscillation, false oscillation, and
even chaotic oscillation) with reasonable computational costs such as
running 1000-point Monte-Carlo simulations for 7~60 initial conditions
(maximum 4 hours).</p>
<ul>
<li>The verification is performed using a <strong>predictive global
optimization algorithm</strong> that looks for a problematic initial
state from a discretized state space</li>
<li>despite the <strong>finite number of initial state
candidates</strong> considered and <strong>finite number of Monte-Carlo
samples</strong> to model variability, the proposed algorithm can verify
the oscillator to a prescribed confidence level</li>
</ul>
<p><img
src="/2022/03/06/MPRO-frequency-stability/image-20220320183344877.png"
alt="image-20220320183344877" /></p>
<blockquote>
<ul>
<li>The observation that the responses of a circuit with nearby initial
conditions are strongly correlated with respect to common variability
conditions enables us to explore a <strong>discretized version</strong>
of the initial condition space instead of the continuous one.</li>
<li>the settling time increases as the initial state gets farther away
from the equilibrium state allowed us to use the settling time as a
guidance metric to find a problematic initial condition.</li>
</ul>
</blockquote>
<p><strong>Selecting the Next Initial Condition Candidate to
Evaluate</strong></p>
<p>To determine whether the algorithm should continue or terminate the
search for a new maximum, the algorithm estimates the probability of
finding a new <strong>initial condition with the longer settling
time</strong>, based on the information obtained with the
previously-evaluated initial conditions.</p>
<p><strong>GCHECK EXAMPLE</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python gcheck_osc.py input.scs</span><br></pre></td></tr></table></figure>
<p>output log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Step 1/4: Simulating the setting-time distribution with the reference initial condition</span><br><span class="line">...</span><br><span class="line">Step 2/4: Simulating the setting-time distribution for randomly-selected initial probes</span><br><span class="line">...</span><br><span class="line">Step 3/4: Searching for Problematic Initial Conditions</span><br><span class="line">...</span><br><span class="line">Step 4/4: Reporting Verification Results and Statistics</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/06/MPRO-frequency-stability/image-20220320201718018.png"
alt="image-20220320201718018" /></p>
<p>T. Kim, D. -G. Song, S. Youn, J. Park, H. Park and J. Kim, "Verifying
start-up failures in coupled ring oscillators in presence of variability
using predictive global optimization," 2013 IEEE/ACM International
Conference on Computer-Aided Design (ICCAD), 2013, pp. 486-493, doi:
10.1109/ICCAD.2013.6691161.</p>
<p><a href="https://mics.snu.ac.kr/wiki/GCHECK">GCHECK: Global
Convergence Checker for Oscillators</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Model Library Setup</title>
    <url>/2023/01/14/ModelLibrarySetup/</url>
    <content><![CDATA[<p>In order to set up model files automatically in the <em>Model Library
Setup</em> form for Spectre or AMS simulator in ADE Explorer or ADE
Assembler</p>
<p>Add the following line in your <code>.cdsinit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">envSetVal( &quot;spectre.envOpts&quot; &quot;modelFiles&quot; &#x27;string &quot;&lt;path_to model_file&gt;/myModels.scs&quot;)</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">envSetVal(&quot;spectre.envOpts&quot; &quot;modelFiles&quot; &#x27;string &quot;moreModels;ff mymodels;tt&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/14/ModelLibrarySetup/image-20230114220458438.png"
alt="image-20230114220458438" /></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>Native NMOS Blocked Implant (NT_N)</title>
    <url>/2023/08/09/NT-N/</url>
    <content><![CDATA[<p>A <strong>native layer (NT_N)</strong> is usually added under
inductors or transformers in the nanoscale CMOS to define the non-doped
high-resistance region of substrate, which decreases eddy currents in
the substrate thus maintaining high Q of the coils.</p>
<blockquote>
<p>For T* PDK offered inductor, a native substrate region is created
under the inductor coil to minimize <em>eddy currents</em></p>
</blockquote>
<p><img src="/2023/08/09/NT-N/image-20230810000702597.png"
alt="image-20230810000702597" /></p>
<blockquote>
<p>OD inside NT_N only can be used for NT_N potential pickup purpose,
such as the guarding-ring of MOM and inductor</p>
</blockquote>
<h2 id="derived-geometries">Derived Geometries</h2>
<table>
<thead>
<tr class="header">
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>PW</em></td>
<td><em>{NOT NW}</em></td>
</tr>
<tr class="even">
<td>N+OD</td>
<td>{NP AND OD}</td>
</tr>
<tr class="odd">
<td>P+OD</td>
<td>{PP AND OD}</td>
</tr>
<tr class="even">
<td>GATE</td>
<td>{PO AND OD}</td>
</tr>
<tr class="odd">
<td>TrGATE</td>
<td>{GATE NOT PODE_GATE}</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>NP: N+ Source/Drain Ion Implantation</p>
<p>PP: P+ Source/Drain Ion Implantation</p>
<p>OD: Gate Oxide and Diffustion</p>
<p>NW: N-WELL</p>
<p>PW: P-WELL</p>
<h2 id="cmos-processing-technology">CMOS Processing Technology</h2>
<p><em>Four main CMOS technologies:</em></p>
<ul>
<li><em>n-well process</em></li>
<li><em>p-well process</em></li>
<li><em>twin-tub process</em></li>
<li><em>silicon on insulator</em></li>
</ul>
<p>Triple well, Deep N-Well (optional):</p>
<ul>
<li>NWell: NMOS svt, lvt, ulvt ...</li>
<li>PWell: PMOS svt, lvt, ulvt ...</li>
<li>DNW: For isolating P-Well from the substrate</li>
</ul>
<blockquote>
<p>The NT_N drawn layer adds <strong>no</strong> process cost and
<strong>no</strong> extra mask</p>
<p>The N-well / P-well technology, where n-type diffusion is done over a
p-type substrate or p-type diffusion is done over n-type substrate
respectively.</p>
<p>The <strong>Twin well technology</strong>, where <strong>NMOS and
PMOS transistor</strong> are developed over the wafer by simultaneous
diffusion over an epitaxial growth base, rather than a substrate.</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Principles of VLSI Design CMOS Processing CMPE 413 [<a
href="https://redirect.cs.umbc.edu/~cpatel2/links/315/lectures/chap3_lect09_processing2.pdf">https://redirect.cs.umbc.edu/~cpatel2/links/315/lectures/chap3_lect09_processing2.pdf</a>]</p>
<p>CMOS processing [<a
href="http://users.ece.utexas.edu/~athomsen/cmos_processing.pdf">http://users.ece.utexas.edu/~athomsen/cmos_processing.pdf</a>]</p>
<p>The Fabrication Process of CMOS Transistor [<a
href="https://www.elprocus.com/the-fabrication-process-of-cmos-transistor/#:~:text=latch%2Dup%20susceptibility.-,N%2D%20well%2F%20P%2D%20well%20Technology,well%20it%20is%20vice%2D%20verse.">https://www.elprocus.com/the-fabrication-process-of-cmos-transistor/#:~:text=latch%2Dup%20susceptibility.-,N%2D%20well%2F%20P%2D%20well%20Technology,well%20it%20is%20vice%2D%20verse.</a>]</p>
<p>CMOS Processing Technology [<a
href="http://ece-research.unm.edu/jimp/vlsi/slides/chap3_1.html">link1</a>,
<a
href="http://ece-research.unm.edu/jimp/vlsi/slides/chap3_2.html">link2</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>New windows and forms appear behind the Library Manager in background when using GNOME 3</title>
    <url>/2022/10/22/New-windows-Gnome3/</url>
    <content><![CDATA[<p>Using <strong>Red Hat Enterprise Linux 8</strong>, <strong>Rocky
Linux 8</strong> and the <strong>GNOME 3</strong> window manager, the
new Virtuoso Schematic/Layout/ADE windows and forms sometimes pop up
under or below the <strong>Library Manager</strong> or on the desktop in
the background instead of the foreground and cannot be seen. Sometimes,
they are iconized; they do not come on the top in front, though it is
the most recent window opened.</p>
<p><strong>solution</strong></p>
<blockquote>
<p>Install <strong>Focus my window</strong> GNOME Shell extension</p>
</blockquote>
<p><img src="/2022/10/22/New-windows-Gnome3/image-20221022002952578.png"
alt="image-20221022002952578" /></p>
<p><strong>reference</strong></p>
<p>Article (11612426) Title: New windows and forms appear behind the
Library Manager in background or iconized instead of foreground on RHEL
and SuSE Linux in GNOME, KDE Desktop, Metacity window manager URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000nSXCEA2">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000nSXCEA2</a></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>OCV Derating With AOCV</title>
    <url>/2022/12/10/OCVDeratingWithAOCV/</url>
    <content><![CDATA[<p><strong>timing_aocv_derate_mode</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timing_aocv_derate_mode&#123;aocv_multiplicative | aocv_additive&#125;</span><br></pre></td></tr></table></figure>
<p><em>Default:</em> <code>aocv_multiplicative</code></p>
<p>Controls the AOCV derating mode.</p>
<p>When set to <code>aocv_multiplicative</code>, the derating factor
will be calculated as AOCV derating * OCV derating, which is set using
the <code>set_timing_derate</code> command.</p>
<p>When set to <code>aocv_additive</code>, the derating factor will be
calculated as AOCV derating + OCV derating values.</p>
<p>When you use this global variable, the <code>report_timing</code>
command shows the <code>total_derate</code> column in the timing report
output, which allows you to view and cross-check the calculated total
derate factor.</p>
<p>To set this global variable, use the <code>set_global</code>
command.</p>
<p><img
src="/2022/12/10/OCVDeratingWithAOCV/image-20221210143256639.png"
alt="image-20221210143256639" /></p>
<h3 id="reference">reference</h3>
<p>Genus Attribute Reference 22.1</p>
<p>Innovus Text Command Reference 22.10</p>
<p>Article (20416394) Title: Analysis with Advanced On-chip Variation
(AOCV) derating in EDI system and ETS URL:
https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od000000050NxEAI</p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Overflow Detection in Verilog</title>
    <url>/2022/05/07/Overflowflag-verilog/</url>
    <content><![CDATA[<ul>
<li>Arithmetic operations have a potential to run into a condition known
as <em>overflow</em>.</li>
<li>Overflow occurs with respect to the <strong>size of the data
type</strong> that must accommodate the result.</li>
<li>Overflow indicates that the result was <em>too large</em> or <em>too
small</em> to fit in the original data type.</li>
</ul>
<h2 id="overflow-when-adding-unsigned-number">Overflow when adding
unsigned number</h2>
<p>When two unsigned numbers are added, overflow occurs if</p>
<ul>
<li>there is a <strong>carry out</strong> of the leftmost bit.</li>
</ul>
<h2 id="overflow-when-adding-signed-numbers">Overflow when adding signed
numbers</h2>
<p>When two signed 2's complement numbers are added, overflow is
detected if:</p>
<ol type="1">
<li>both operands are positive and the result is negative, or</li>
<li>both operands are negative and the result is positive.</li>
</ol>
<p>Notice that when operands have <strong>opposite signs</strong>, their
sum will never overflow. Therefore, <em>overflow can only occur when the
operands have the same sign</em>.</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>carryout_sum</th>
<th>overflow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>0</strong>11 (3)</td>
<td><strong>0</strong>11 (3)</td>
<td>0_<strong>1</strong>10 (6)</td>
<td>overflow</td>
</tr>
<tr class="even">
<td><strong>1</strong>00 (-4)</td>
<td><strong>1</strong>00 (-4)</td>
<td>1_<strong>0</strong>00 (-8)</td>
<td>underflow</td>
</tr>
<tr class="odd">
<td><strong>1</strong>11 (-1)</td>
<td><strong>1</strong>10 (-2)</td>
<td>1_<strong>1</strong>01 (-3)</td>
<td>-</td>
</tr>
</tbody>
</table>
<blockquote>
<p>carryout information <strong>ISN'T</strong> needed to detect
overflow/underflow for signed number addition</p>
</blockquote>
<h3 id="extbitmsb">EXTBIT:MSB</h3>
<p>extended 1bit and msb bit can be used to detect overflow or
underflow</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> <span class="keyword">signed</span>  [<span class="number">1</span>:<span class="number">0</span>]      acc_inc;</span><br><span class="line"><span class="keyword">reg</span> <span class="keyword">signed</span>  [<span class="number">10</span>-<span class="number">1</span>:<span class="number">0</span>]   acc;</span><br><span class="line"><span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">10</span>  :<span class="number">0</span>]   acc_w;  <span class="comment">// extend 1b for saturation</span></span><br><span class="line"><span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">10</span>-<span class="number">1</span>:<span class="number">0</span>]   acc_stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> acc_w = acc + acc_inc;   <span class="comment">// signed arithmetic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> acc_stat = (acc_w[<span class="number">10</span>-<span class="number">1</span> +: <span class="number">2</span>] == <span class="number">2&#x27;b01</span>) ? &#123;<span class="number">1&#x27;b0</span>, &#123;(<span class="number">10</span>-<span class="number">1</span>)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;&#125; : <span class="comment">// up saturation</span></span><br><span class="line">    (acc_w[<span class="number">10</span>-<span class="number">1</span> +: <span class="number">2</span>] == <span class="number">2&#x27;b10</span>) ? &#123;<span class="number">1&#x27;b1</span>, &#123;(<span class="number">10</span>-<span class="number">1</span>)&#123;<span class="number">1&#x27;b0</span>&#125;&#125;&#125;  :   			 <span class="comment">// down saturation</span></span><br><span class="line">    acc_w[<span class="number">10</span>-<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>2'b01</code> : overflow, up saturation</p>
<p><code>2'b10</code>: underflow, down saturation</p>
</blockquote>
<h2 id="s-complement-negative-number">2's complement negative
number</h2>
<ol type="1">
<li>Flip all bits</li>
<li>Add <strong>1</strong>.</li>
</ol>
<p>N-bit signed number <span class="math display">\[
A = -M_{N-1}2^{N-1}+\sum_{k=0}^{N-2}M_k2^k
\]</span> Flip all bits <span class="math display">\[\begin{align}
A_{flip} &amp;= -(1-M_{N-1})2^{N-1} +\sum_{k=0}^{N-2}(1-M_k)2^k \\
&amp;= M_{N-1}2^{N-1}-\sum_{k=0}^{N-2}M_k2^k
-2^{N-1}+\sum_{k=0}^{N-2}2^k \\
&amp;= M_{N-1}2^{N-1}-\sum_{k=0}^{N-2}M_k2^k -1
\end{align}\]</span></p>
<p>Add <strong>1</strong> <span class="math display">\[\begin{align}
A_- &amp;= A_{flip}+1 \\
&amp;= M_{N-1}2^{N-1}-\sum_{k=0}^{N-2}M_k2^k \\
&amp;= -A
\end{align}\]</span></p>
<h2 id="reference">reference</h2>
<p>Overflow Detection: <a
href="http://www.c-jump.com/CIS77/CPU/Overflow/lecture.html">http://www.c-jump.com/CIS77/CPU/Overflow/lecture.html</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Pole-Zero Doublets</title>
    <url>/2022/12/14/Pole-Zero-Doublets/</url>
    <content><![CDATA[<p>Mismatch between the pole and zero frequencies leads to the
<strong>“doublet problem”</strong>. If the pole and the zero do not
exactly coincide, we say that they constitute a
<strong>doublet</strong></p>
<blockquote>
<p>Problem 10.19 in Razavi 2nd book</p>
</blockquote>
<p>Suppose the open-loop transfer function of a two-stage op amp is
expressed as <span class="math display">\[
H_{open}(s)=\frac{A_0(1+\frac{s}{\omega_z})}{\left( 1+
\frac{s}{\omega_{p1}}\right)\left( 1+ \frac{s}{\omega_{p2}}\right)}
\]</span> deally, <span class="math inline">\(\omega_z=\omega_2\)</span>
and the feedback circuit exhibits a first-order behavior, i.e., its step
response contains a single time constant and no overshoot.</p>
<p>Then the transfer function of the amplifier in a <em>unity-gain
feedback loop</em> is given by <span
class="math display">\[\begin{align}
H_{closed}(s)
&amp;=\frac{A_0\left(1+\frac{s}{\omega_z}\right)}{\frac{s^2}{\omega_{p1}\omega_{p2}}+\left(
\frac{1}{\omega_{p1}} +
\frac{1}{\omega_{p2}}+\frac{A_0}{\omega_{z}}\right)s+A_0+1} \\
&amp;=\frac{\frac{A_0}{A_0+1}(1+\frac{s}{\omega_z})}{\frac{s^2}{\omega_{p1}\omega_{p2}(A_0+1)}+\left(
\frac{1}{\omega_{p1}} +
\frac{1}{\omega_{p2}}+\frac{A_0}{\omega_{z}}\right)\frac{s}{A_0+1}+1}
\end{align}\]</span></p>
<hr />
<p>The denominator part of <span
class="math inline">\(H_{closed}(s)\)</span> is <span
class="math display">\[
D(s) = \frac{s^2}{\omega_{p1}\omega_{p2}}+\left( \frac{1}{\omega_{p1}} +
\frac{1}{\omega_{p2}}+\frac{A_0}{\omega_{z}}\right)s+A_0+1
\]</span></p>
<p>Assuming two poles (<span class="math inline">\(\omega_{pA}
\ll\omega_{pB}\)</span>) of <span
class="math inline">\(H_{closed}(s)\)</span> are widely spaced, <span
class="math display">\[\begin{align}
D(s) &amp;= \left( 1+ \frac{s}{\omega_{pA}}\right)\left( 1+
\frac{s}{\omega_{pB}}\right)\\
&amp;\cong \frac{s^2}{\omega_{pA}\omega_{pB}}+\frac{s}{\omega_{pA}} + 1
\end{align}\]</span></p>
<p>Thus, the two poles of the closed-loop transfer function of system
are <span class="math display">\[\begin{align}
\omega_{pA} &amp;= \frac{A_0+1}{\frac{1}{\omega_{p1}} +
\frac{1}{\omega_{p2}}+\frac{A_0}{\omega_{z}}} \\
&amp;=  \frac{(A_0+1)\omega_{p1} \omega_{p2}}{\omega_{p1} + \omega_{p2}
+ \frac{A_0}{\omega_z}\omega_{p1} \omega_{p2}} \\
\omega_{pB} &amp;= \omega_{p1} + \omega_{p2} +
\frac{A_0}{\omega_z}\omega_{p1} \omega_{p2}
\end{align}\]</span></p>
<hr />
<p><strong>Assuming</strong> <span class="math inline">\(\omega_z \simeq
\omega_{p2}\)</span> and <span class="math inline">\(\omega_{p2}\ll
(1+A_0)\omega_{p1}\)</span> <span class="math display">\[
\omega_{pA} = \omega_{p2}
\]</span> and <span class="math display">\[
\omega_{pB} = (1+A_0)\omega_{p1}
\]</span> The closed-loop transfer function is <span
class="math display">\[
H_{closed}(s) =
\frac{\frac{A_0}{A_0+1}\left(1+\frac{s}{\omega_z}\right)}{\left(1+\frac{s}{(1+A_0)\omega_{p1}}\right)\left(
1+\frac{s}{\omega_{p2}} \right)}
\]</span></p>
<hr />
<p>The step response of the closed-loop amplifier</p>
<p>Consider the Laplace transform function of step response, <span
class="math inline">\(X(s)=\frac{1}{s}\)</span> <span
class="math display">\[
Y(s)=\frac{1}{s}\times H_{closed}(s)
\]</span> Thus, the <strong>small-signal step response</strong> of the
closed-loop amplifer is <span class="math display">\[
y(t)=\frac{A_0}{A_0+1}\left[1-e^{-(A_0+1)\omega_{p1}t}-\left(1-\frac{\omega_{p2}}{\omega_z}\right)e^{-\omega_{p2}t}
\right]u(t)
\]</span> Since, <span class="math inline">\(\omega_{p2}\ll
(1+A_0)\omega_{p1}\)</span>. Therefore, rewrite the <span
class="math inline">\(y(t)\)</span> <span class="math display">\[
y(t)\cong
\frac{A_0}{A_0+1}\left[1-\left(1-\frac{\omega_{p2}}{\omega_z}\right)e^{-\omega_{p2}t}
\right]u(t)
\]</span> The step response contains an exponential term of the form
<span
class="math inline">\(\left(1-\frac{\omega_{p2}}{\omega_z}\right)e^{-\omega_{p2}t}\)</span>.
This is an important result, indicating that if the zero does not
exactly cancel the pole, the step response exhibits an exponential with
an amplitude proportional to <span
class="math inline">\(\left(1-\frac{\omega_{p2}}{\omega_z}\right)\)</span>,
which depends on the mismatch between <span
class="math inline">\(\omega_z\)</span> and <span
class="math inline">\(\omega_{p2}\)</span> and a time constant <span
class="math inline">\(\tau\)</span> of <span
class="math inline">\(\frac{1}{\omega_{p2}}\)</span> or <span
class="math inline">\(\frac{1}{\omega_{z}}\)</span></p>
<h3 id="perfect-pole-zero-cancellation">perfect pole-zero
cancellation</h3>
<p><span class="math display">\[\begin{align}
y(t)
&amp;=\frac{A_0}{A_0+1}\left[1-e^{-(A_0+1)\omega_{p1}t}-\left(1-\frac{\omega_{p2}}{\omega_z}\right)e^{-\omega_{p2}t}
\right]u(t) \\
&amp;= \frac{A_0}{A_0+1}\left[1-e^{-(A_0+1)\omega_{p1}t}\right]u(t)
\end{align}\]</span></p>
<hr />
<p><img src="/2022/12/14/Pole-Zero-Doublets/image-20230108233523345.png"
alt="image-20230108233523345" /></p>
<p><img src="/2022/12/14/Pole-Zero-Doublets/image-20230108234123707.png"
alt="image-20230108234123707" /></p>
<blockquote>
<p>The zero comes from the mirror node</p>
<p>Thanks to unity gain buffer, zero is alleviated for <span
class="math inline">\(C_c\)</span></p>
</blockquote>
<h3 id="reference">reference</h3>
<p>Elad Alon, Lecture 10: Settling-Limited Amplifier Design Methodology,
EE 240B – Spring 2018, Advanced Analog Integrated Circuits <a
href="https://inst.eecs.berkeley.edu/~ee240b/sp18/lectures/Lecture10_Settling_Design_2up.pdf">https://inst.eecs.berkeley.edu/~ee240b/sp18/lectures/Lecture10_Settling_Design_2up.pdf</a></p>
<p>Eric Chang, Prof. Elad Alon EE240B HW3 <a
href="https://inst.eecs.berkeley.edu/~ee240b/sp18/homeworks/hw3.pdf">https://inst.eecs.berkeley.edu/~ee240b/sp18/homeworks/hw3.pdf</a>
and <a
href="https://inst.eecs.berkeley.edu/~ee240b/sp18/homeworks/hw3_soln.pdf">https://inst.eecs.berkeley.edu/~ee240b/sp18/homeworks/hw3_soln.pdf</a></p>
<p>Prof. Tai-Haur Kuo, Analog IC Design ( 類比積體電路設計 ),
Operational Amplifiers <a
href="http://msic.ee.ncku.edu.tw/course/aic/201809/chapter5.pdf">http://msic.ee.ncku.edu.tw/course/aic/201809/chapter5.pdf</a></p>
<p>B. Y. T. Kamath, R. G. Meyer and P. R. Gray, "Relationship between
frequency response and settling time of operational amplifiers," in IEEE
Journal of Solid-State Circuits, vol. 9, no. 6, pp. 347-352, Dec. 1974,
doi: 10.1109/JSSC.1974.1050527.</p>
<p>B. Y. T. Kamath, R. G. Meyer and P. R. Gray, "Relationship between
frequency response and settling time of operational amplifiers," in IEEE
Journal of Solid-State Circuits, vol. 9, no. 6, pp. 347-352, Dec. 1974,
doi: 10.1109/JSSC.1974.1050527.</p>
<p>P. R. Gray and R. G. Meyer, "MOS operational amplifier design-a
tutorial overview," in IEEE Journal of Solid-State Circuits, vol. 17,
no. 6, pp. 969-982, Dec. 1982, doi: 10.1109/JSSC.1982.1051851.</p>
<p>SERGIO FRANCO, Demystifying pole-zero doublets URL:<a
href="https://www.edn.com/demystifying-pole-zero-doublets/">https://www.edn.com/demystifying-pole-zero-doublets/</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Precedence Rule of UVM uvm_config_db::set</title>
    <url>/2022/03/23/Precedence-Rule-uvm-config-db/</url>
    <content><![CDATA[<p><a
href="https://vlsiverify.com/uvm/uvm_config_db-in-uvm#Precedence_Rule">https://vlsiverify.com/uvm/uvm_config_db-in-uvm#Precedence_Rule</a></p>
<h4 id="two-precedence-rules">Two Precedence rules</h4>
<p>There are two precedence rules applicable to
<code>uvm_config_db</code>. In the <code>build_phase</code>,</p>
<ol type="1">
<li>A <code>set()</code> call in <strong>a context higher up the
component hierarchy</strong> takes precedence over a <code>set()</code>
call that occurs lower in the hierarchical path.</li>
<li>On having <strong>same context field</strong>, <strong>the
last</strong> <code>set()</code> call takes precedence over the earlier
<code>set()</code> call.</li>
</ol>
<h4 id="example-for-rule---1">Example for rule - 1</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> component_A <span class="keyword">extends</span> uvm_component;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  `uvm_component_utils(component_A)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;component_A&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> display();</span><br><span class="line">    `uvm_info(get_type_name(), <span class="built_in">$sformatf</span>(<span class="string">&quot;inside component_A: id = %0d&quot;</span>, id), UVM_LOW);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> component_B <span class="keyword">extends</span> component_A;</span><br><span class="line">  <span class="keyword">int</span> receive_value;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  </span><br><span class="line">  `uvm_component_utils(component_B)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;component_B&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="keyword">if</span>(!uvm_config_db <span class="variable">#(int)::get(this, &quot;*&quot;, &quot;value&quot;, receive_value))</span></span><br><span class="line">      `uvm_fatal(get_type_name(), <span class="string">&quot;get failed for resource in this scope&quot;</span>);    </span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> display();</span><br><span class="line">    `uvm_info(get_type_name(), <span class="built_in">$sformatf</span>(<span class="string">&quot;inside component_B: id = %0d, receive_value = %0d&quot;</span>, id, receive_value), UVM_LOW);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">  `uvm_component_utils(env)</span><br><span class="line">  component_A comp_A;</span><br><span class="line">  component_B comp_B;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;env&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    comp_A = component_A ::type_id::create(<span class="string">&quot;comp_A&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    comp_B = component_B ::type_id::create(<span class="string">&quot;comp_B&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    uvm_config_db <span class="variable">#(int)::set(this, &quot;*&quot;, &quot;value&quot;, 200)</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.run_phase</span>(phase);</span><br><span class="line">    <span class="keyword">void</span>&#x27;(comp_A<span class="variable">.display</span>());</span><br><span class="line">    <span class="keyword">void</span>&#x27;(comp_B<span class="variable">.display</span>());</span><br><span class="line">  <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line">  <span class="keyword">bit</span> control;</span><br><span class="line">  `uvm_component_utils(my_test)</span><br><span class="line">  env env_o;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_test&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">      env_o = env::type_id::create(<span class="string">&quot;env_o&quot;</span>, <span class="keyword">this</span>);				<span class="comment">// line 99</span></span><br><span class="line">    </span><br><span class="line">      uvm_config_db <span class="variable">#(int)::set(null, &quot;*&quot;, &quot;value&quot;, 100)</span>;		<span class="comment">// line 101</span></span><br><span class="line">	<span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> end_of_elaboration_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.end_of_elaboration_phase</span>(phase);</span><br><span class="line">    uvm_top<span class="variable">.print_topology</span>();</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    run_test(<span class="string">&quot;my_test&quot;</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UVM_INFO /xcelium20.09/tools//methodology/UVM/CDNS-1.2/sv/src/base/uvm_root.svh(605) @ 0: reporter [UVMTOP] UVM testbench topology:</span><br><span class="line">--------------------------------------</span><br><span class="line">Name          Type         Size  Value</span><br><span class="line">--------------------------------------</span><br><span class="line">uvm_test_top  my_test      -     @1810</span><br><span class="line">  env_o       env          -     @1877</span><br><span class="line">    comp_A    component_A  -     @1922</span><br><span class="line">    comp_B    component_B  -     @1953</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line">UVM_INFO testbench.sv(14) @ 0: uvm_test_top.env_o.comp_A [component_A] inside component_A: id = 1</span><br><span class="line">UVM_INFO testbench.sv(36) @ 0: uvm_test_top.env_o.comp_B [component_B] inside component_B: id = 2, receive_value = 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>As you can see , the <code>uvm_config_db::set</code> is after the
factory <code>type_id::create</code>, but <strong>receive_value</strong>
is still <strong>100</strong>, I believe that <code>build_phase</code>
of upper hierarchy finish first before create lower components.</p>
<p>But the recommendation in literature and many web is place
<code>uvm_config_db::set</code> before <code>create</code></p>
</blockquote>
<h4 id="simple-example-for-rule---2">Simple Example for rule - 2</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">uvm_config_db <span class="variable">#(int)::set(null, &quot;*&quot;, &quot;value&quot;, 100)</span>;</span><br><span class="line">uvm_config_db <span class="variable">#(int)::set(null, &quot;*&quot;, &quot;value&quot;, 200)</span>;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.edaplayground.com/x/jgvh">[complete
code]</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UVM_INFO /xcelium20.09/tools//methodology/UVM/CDNS-1.2/sv/src/base/uvm_root.svh(605) @ 0: reporter [UVMTOP] UVM testbench topology:</span><br><span class="line">--------------------------------------</span><br><span class="line">Name          Type         Size  Value</span><br><span class="line">--------------------------------------</span><br><span class="line">uvm_test_top  my_test      -     @1810</span><br><span class="line">  env_o       env          -     @1877</span><br><span class="line">    comp_A    component_A  -     @1924</span><br><span class="line">    comp_B    component_B  -     @1955</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line">UVM_INFO testbench.sv(14) @ 0: uvm_test_top.env_o.comp_A [component_A] inside component_A: id = 1</span><br><span class="line">UVM_INFO testbench.sv(36) @ 0: uvm_test_top.env_o.comp_B [component_B] inside component_B: id = 2, receive_value = 200</span><br></pre></td></tr></table></figure>
<h3 id="another-example-for-rule---2">Another Example for rule - 2</h3>
<p>The <code>set</code> in <code>super.build_phase</code> and
<code>set</code> in current <code>build_phase</code> are at the
<strong>same hierarchy</strong>, so <strong>rule-2</strong> apply</p>
<p>base_test</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> base_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component macro</span></span><br><span class="line">  `uvm_component_utils(base_test)</span><br><span class="line"></span><br><span class="line">  router_tb tb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component constructor</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// UVM build_phase()</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    uvm_config_int::set(<span class="keyword">this</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;recording_detail&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    uvm_config_wrapper::set(<span class="keyword">this</span>, <span class="string">&quot;tb.yapp.tx_agent.sequencer.run_phase&quot;</span>, </span><br><span class="line">                                                      <span class="string">&quot;default_sequence&quot;</span>,</span><br><span class="line">                                                      yapp_5_packets::get_type());</span><br><span class="line">    tb = router_tb::type_id::create(<span class="string">&quot;tb&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span> : build_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span> : base_test</span><br></pre></td></tr></table></figure>
<h4 id="test2---one">test2 - One</h4>
<blockquote>
<p><code>yapp_incr_payload_seq</code> override the
<code>yapp_5_packets</code> in <code>super.build_phase(phase)</code>,
<strong>yapp_incr_payload_seq</strong> is used.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> test2 <span class="keyword">extends</span> base_test;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component macro</span></span><br><span class="line">  `uvm_component_utils(test2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component constructor</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    yapp_packet::type_id::set_type_override(short_yapp_packet::get_type());</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    uvm_config_wrapper::set(<span class="keyword">this</span>, <span class="string">&quot;tb.yapp.tx_agent.sequencer.run_phase&quot;</span>, </span><br><span class="line">                                                      <span class="string">&quot;default_sequence&quot;</span>,</span><br><span class="line">                                                      yapp_incr_payload_seq::get_type());</span><br><span class="line">  <span class="keyword">endfunction</span> : build_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span> : test2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------------------------------------------------                   </span><br><span class="line">Name                           Type               Size  Value</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------                   </span><br><span class="line">req                            short_yapp_packet  -     @3045</span><br><span class="line">  length                       integral           6     &#x27;h5</span><br><span class="line">  addr                         integral           2     &#x27;h1</span><br><span class="line">  payload                      da(integral)       5     -</span><br><span class="line">    [0]                        integral           8     &#x27;h0</span><br><span class="line">    [1]                        integral           8     &#x27;h1</span><br><span class="line">    [2]                        integral           8     &#x27;h2</span><br><span class="line">    [3]                        integral           8     &#x27;h3</span><br><span class="line">    [4]                        integral           8     &#x27;h4</span><br><span class="line">  parity                       integral           8     &#x27;h11</span><br><span class="line">  parity_type                  parity_t           1     GOOD_PARITY</span><br><span class="line">  packet_delay                 integral           32    &#x27;d19</span><br><span class="line">  begin_time                   time               64    0</span><br><span class="line">  depth                        int                32    &#x27;d2</span><br><span class="line">  parent sequence (name)       string             21    yapp_incr_payload_seq                                                           </span><br><span class="line">  parent sequence (full name)  string             61    uvm_test_top.tb.yapp.tx_agent.sequencer.yapp_incr_payload_seq                   </span><br><span class="line">  sequencer                    string             39    uvm_test_top.tb.yapp.tx_agent.sequencer                                         </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h4 id="test2---two">test2 - Two</h4>
<blockquote>
<p>the <code>yapp_5_packets</code> in
<code>super.build_phase(phase)</code> overide
<code>yapp_incr_payload_seq</code> in test2's <code>build_phase</code>,
<strong>yapp_5_packets</strong> is used</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> test2 <span class="keyword">extends</span> base_test;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component macro</span></span><br><span class="line">  `uvm_component_utils(test2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component constructor</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    yapp_packet::type_id::set_type_override(short_yapp_packet::get_type());</span><br><span class="line">    uvm_config_wrapper::set(<span class="keyword">this</span>, <span class="string">&quot;tb.yapp.tx_agent.sequencer.run_phase&quot;</span>, </span><br><span class="line">                                                      <span class="string">&quot;default_sequence&quot;</span>,</span><br><span class="line">                                                      yapp_incr_payload_seq::get_type());</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">  <span class="keyword">endfunction</span> : build_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span> : test2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------------------------------                          </span><br><span class="line">Name                           Type               Size  Value</span><br><span class="line">--------------------------------------------------------------------------------------------------------------                          </span><br><span class="line">req                            short_yapp_packet  -     @3176</span><br><span class="line">  length                       integral           6     &#x27;h6</span><br><span class="line">  addr                         integral           2     &#x27;h1</span><br><span class="line">  payload                      da(integral)       6     -</span><br><span class="line">    [0]                        integral           8     &#x27;h4f</span><br><span class="line">    [1]                        integral           8     &#x27;hbe</span><br><span class="line">    [2]                        integral           8     &#x27;hb</span><br><span class="line">    [3]                        integral           8     &#x27;h1d</span><br><span class="line">    [4]                        integral           8     &#x27;h72</span><br><span class="line">    [5]                        integral           8     &#x27;hc5</span><br><span class="line">  parity                       integral           8     &#x27;h49</span><br><span class="line">  parity_type                  parity_t           1     GOOD_PARITY</span><br><span class="line">  packet_delay                 integral           32    &#x27;d0</span><br><span class="line">  begin_time                   time               64    40</span><br><span class="line">  depth                        int                32    &#x27;d2</span><br><span class="line">  parent sequence (name)       string             14    yapp_5_packets                                                                  </span><br><span class="line">  parent sequence (full name)  string             54    uvm_test_top.tb.yapp.tx_agent.sequencer.yapp_5_packets                          </span><br><span class="line">  sequencer                    string             39    uvm_test_top.tb.yapp.tx_agent.sequencer                                         </span><br><span class="line">-------------------------------------------------------------------------------------------------------------- </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Precision Techniques</title>
    <url>/2024/01/13/Precision-Techniques/</url>
    <content><![CDATA[<h2 id="autozeroing-techniques">Autozeroing techniques</h2>
<blockquote>
<p>offset is <strong>sampled</strong> and then subtracted from the
input.</p>
</blockquote>
<h2 id="chopping-techniques">Chopping techniques</h2>
<blockquote>
<p>offset is <strong>modulated</strong> away from the signal band and
then filtered out.</p>
</blockquote>
<p><strong>Good</strong>: Magically reduces offset, 1/f noise, drift</p>
<p><strong>Bad</strong>: But creates switching spikes, chopper ripple
and other artifacts …</p>
<h2 id="reference">reference</h2>
<p>C. C. Enz and G. C. Temes, "Circuit techniques for reducing the
effects of op-amp imperfections: autozeroing, correlated double
sampling, and chopper stabilization," in Proceedings of the IEEE, vol.
84, no. 11, pp. 1584-1614, Nov. 1996, doi: 10.1109/5.542410. [<a
href="http://www2.ing.unipi.it/~a008309/mat_stud/MIXED/archive/2019/Articles/Offset_canc_Enz_Temes_96.pdf">http://www2.ing.unipi.it/~a008309/mat_stud/MIXED/archive/2019/Articles/Offset_canc_Enz_Temes_96.pdf</a>]</p>
<p>Bernhard E. Boser, M12 Precision Techniques [<a
href="https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M12%20Precision%20Techniques.pdf">https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M12%20Precision%20Techniques.pdf</a>]</p>
<p>Qinwen Fan, Evolution of precision amplifiers</p>
<p>Wu, R., Huijsing, JH., &amp; Makinwa, KAA. (2013). Precision
Instrumentation Amplifiers and Read-Out Integrated Circuits. Springer.
https://doi.org/10.1007/978-1-4614-3731-4</p>
<p>Kofi Makinwa, UPC 2009 <a
href="https://electronicengineering.phd.upc.edu/en/courses-and-seminars/courses-materials/2008-2009/slides-makinwa-1">Overcoming
Offset</a></p>
<p>Kofi Makinwa, ISSCC 2007 Dynamic-Offset Cancellation Techniques in
CMOS [<a
href="https://picture.iczhiku.com/resource/eetop/sYkywlkpwIQEKcxb.pdf">https://picture.iczhiku.com/resource/eetop/sYkywlkpwIQEKcxb.pdf</a>]</p>
<p>Chopper Amplifiers Demystified Kofi A. A. Makinwa [<a
href="https://youtu.be/J19rRjKV7kk?si=oHXskwd9y-B35cJt">https://youtu.be/J19rRjKV7kk?si=oHXskwd9y-B35cJt</a>]</p>
<p>ESSCIRC2023 Circuit Insights Kofi Makinwa [<a
href="https://youtu.be/uwRpP20Lprc?si=D8S4kjexbdsbuhb7">https://youtu.be/uwRpP20Lprc?si=D8S4kjexbdsbuhb7</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>RC corner</title>
    <url>/2023/04/16/RC-corner/</url>
    <content><![CDATA[<h3 id="traditional-rc-corners">Traditional RC Corners</h3>
<p><img src="/2023/04/16/RC-corner/image-20230511232521956.png"
alt="image-20230511232521956" /></p>
<h3 id="dpt-effect">DPT effect</h3>
<p>When using two masks per layer (<strong>Double Patterning Technology,
DPT</strong>) there is an issue of mask alignment where any
mis-alignment will cause layer spacing values to change, therefore
changing the parasitic coupling capacitance values.</p>
<p><img src="/2023/04/16/RC-corner/img_5d04516986340.jpg" /></p>
<p><img src="/2023/04/16/RC-corner/img_5d04516a3ac8b.jpg" /></p>
<blockquote>
<p>Misalignment scale and direction are not deterministic facts:
coupling cap and total cap may be increased or decreased.</p>
</blockquote>
<p><em>Five new corners</em> are added in a <em>DPT</em> flow to account
for RC variations accurately:</p>
<p><img src="/2023/04/16/RC-corner/img_5d04516b03e69.jpg" /></p>
<blockquote>
<p>sapced-dependent side-wall dielectric constant also affect coupling
cap</p>
<p>and <em>CC_worst</em> means to increase both K1 and K2</p>
<p><em>CC_best</em> means to decrease both K1 and K2</p>
</blockquote>
<ul>
<li><p>Setup time sign-off would use:</p>
<p>Cworst_CCworst / RCworst_CCworst</p></li>
<li><p>Hold time sign-off would use:</p>
<p>Cbest_CCbest / RCbest_CCbest / Cworst_CCworst /
RCworst_CCworst</p></li>
</ul>
<p><img src="/2023/04/16/RC-corner/img_5d04516c76593.jpg" /></p>
<p><img src="/2023/04/16/RC-corner/image-20230416143108231.png"
alt="image-20230416143108231" /></p>
<h3 id="signoff-corner">Signoff corner</h3>
<table>
<thead>
<tr class="header">
<th><strong>with misalignment effect</strong></th>
<th>without misalignment effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cworst_CCworst, cworst_CCworst_T</td>
<td>cworst, cworst_T</td>
</tr>
<tr class="even">
<td>cbest_CCbest, cbest_CCbest_T</td>
<td>cbest, cbest_T</td>
</tr>
<tr class="odd">
<td>rcworst_CCworst, rcworst_CCworst_T</td>
<td>rcworst, rcworst_T</td>
</tr>
<tr class="even">
<td>rcbest_CCbest, rcbest_CCbest_T</td>
<td>rcbest, rcbest_T</td>
</tr>
</tbody>
</table>
<blockquote>
<p>BEOL Target: typical</p>
</blockquote>
<p>The recommended RC corner:</p>
<p>​ <em>cworst_CCworst, cbest_CCbest, rcworst_CCworst, rcbest_CCbest
and typical</em></p>
<p>The others are for <em>pre-color</em> RC calculation purpose</p>
<p>**_T** stands for <strong>"Tighten DPT corner"</strong>; these are
less pessimistic <strong>1.5 sigma</strong> corners</p>
<p><img src="/2023/04/16/RC-corner/image-20230513001426737.png"
alt="image-20230513001426737" /></p>
<p><img src="/2023/04/16/RC-corner/tmp_fohu0q4.PNG"
alt="tmp_fohu0q4" /></p>
<blockquote>
<p>Below table is caputre of Aragio's TSMC16: LVDS datasheet</p>
<p><img src="/2023/04/16/RC-corner/image-20230416130433181.png"
alt="image-20230416130433181" /></p>
</blockquote>
<h3 id="beol-corner">BEOL corner</h3>
<p><img src="/2023/04/16/RC-corner/image-20230416160822811.png"
alt="image-20230416144136870" /></p>
<blockquote>
<p>Spacing variation is implicitly defined by <span
class="math inline">\(\Delta W_m\)</span>.</p>
</blockquote>
<p>We denote the conductor <em>width and thickness</em> of the layer m
by <span class="math inline">\(W_m\)</span> and <span
class="math inline">\(T_m\)</span>, respectively.</p>
<p>Similarly, we denote the <em>thickness</em> of the layer's interlayer
dielectric (i.e., the distance between layer m and layer m +1) by <span
class="math inline">\(H_m\)</span></p>
<ul>
<li>C-based means <strong>worst and best caps</strong></li>
<li>RC-based means <strong>worst and best R</strong> in <em>adjustment
with C</em> (RC product)</li>
</ul>
<p>Based on experience, it was found that <strong>C-based
extraction</strong> provides worst and best case over RC for internal
timing paths because <em>Capacitance</em> dominates <strong>short
wire</strong>.</p>
<p>However, for large design, inter-block timing paths were often worst
with <strong>RC worst</strong> parasitic since <em>R</em> dominates for
<strong>long wires</strong>.</p>
<p><img src="/2023/04/16/RC-corner/image-20230416155654008.png"
alt="image-20230416155654008" /></p>
<h4 id="signoff-corners-for-setup-and-hold">signoff corners for setup
and hold</h4>
<p><img src="/2023/04/16/RC-corner/tmpwlgwrlq0.PNG"
alt="tmpwlgwrlq0" /></p>
<h3 id="reference">reference</h3>
<p>Modeling Sub-90nm On-Chip Variation Using Monte Carlo Method for DFM
<a
href="https://www.aspdac.com/aspdac2007/pdf/archive/2D-1.pdf">https://www.aspdac.com/aspdac2007/pdf/archive/2D-1.pdf</a></p>
<p>Double Patterning for IC Design, Extraction and Signoff <a
href="https://semiwiki.com/eda/synopsys/1974-double-patterning-for-ic-design-extraction-and-signoff/">https://semiwiki.com/eda/synopsys/1974-double-patterning-for-ic-design-extraction-and-signoff/</a></p>
<p>抽刀断水水更流，RC Corner不再愁：STA之RC Corner URL: <a
href="http://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247484115&amp;idx=1&amp;sn=de99f27aadf58ea316c284dad9000b7c&amp;chksm=fad26b0dcda5e21b8c9750f738b55053f695843a66c3c202ff0ba586c738f45aa270254c3722&amp;scene=21#wechat_redirect">http://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247484115&amp;idx=1&amp;sn=de99f27aadf58ea316c284dad9000b7c&amp;chksm=fad26b0dcda5e21b8c9750f738b55053f695843a66c3c202ff0ba586c738f45aa270254c3722&amp;scene=21#wechat_redirect</a></p>
<p>一曲新词酒一杯，RC Corner继续飞: STA之RC Corner拾遗 URL:<a
href="https://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247484135&amp;idx=2&amp;sn=bddc632850bd10c32b5688fd7af46218&amp;chksm=fad26b39cda5e22f1c3970f8c8c2e1287c9492c526c4caf02b61f61faffdf829381c392d6ea1&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247484135&amp;idx=2&amp;sn=bddc632850bd10c32b5688fd7af46218&amp;chksm=fad26b39cda5e22f1c3970f8c8c2e1287c9492c526c4caf02b61f61faffdf829381c392d6ea1&amp;scene=21#wechat_redirect</a></p>
<p>且将新火试新茶，深究趁年华：STA之RC Corner再论 URL:<a
href="https://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247484144&amp;idx=1&amp;sn=059843381e77cd4008d25166db388d02&amp;chksm=fad26b2ecda5e23816b33b3a949f34d4ca09118bad76f1089dfcb228b7da6491f423a5f4e703&amp;cur_album_id=1326356275000705025&amp;scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247484144&amp;idx=1&amp;sn=059843381e77cd4008d25166db388d02&amp;chksm=fad26b2ecda5e23816b33b3a949f34d4ca09118bad76f1089dfcb228b7da6491f423a5f4e703&amp;cur_album_id=1326356275000705025&amp;scene=189#wechat_redirect</a></p>
<p>LDP_IN_800_25V_DN: 1.2GHz LVDS Receiver <a
href="http://aragiosolutions.com/pdf/rgo_tsmc16_18v25_lvds_product_brief_rev_1a.pdf">http://aragiosolutions.com/pdf/rgo_tsmc16_18v25_lvds_product_brief_rev_1a.pdf</a></p>
<p>Parasitic extraction technologies Advanced node and 3D-IC design <a
href="https://static.sw.cdn.siemens.com/siemens-disw-assets/public/81845/en-US/Siemens-SW-Parasitic-extraction-technologies-for-advanced-WP-81845-C2.pdf">https://static.sw.cdn.siemens.com/siemens-disw-assets/public/81845/en-US/Siemens-SW-Parasitic-extraction-technologies-for-advanced-WP-81845-C2.pdf</a></p>
<p>New Game, New Goal Posts: A Recent History of Timing Closure <a
href="https://pdfs.semanticscholar.org/9360/5ce48f9bd3b7527ae8979f41a9c7e310efa4.pdf">https://pdfs.semanticscholar.org/9360/5ce48f9bd3b7527ae8979f41a9c7e310efa4.pdf</a></p>
<p>The Evolution, Pitfalls, and Cargo Cult Engineering of Advanced
Digital Timing Sign-off <a
href="https://www.tauworkshop.com/2021/speaker_slides/christian_l.pdf">https://www.tauworkshop.com/2021/speaker_slides/christian_l.pdf</a></p>
<p>T. -B. Chan, S. Dobre and A. B. Kahng, "Improved signoff methodology
with tightened BEOL corners," 2014 IEEE 32nd International Conference on
Computer Design (ICCD), Seoul, Korea (South), 2014, pp. 311-316, doi:
10.1109/ICCD.2014.6974699.</p>
<p>Chan, T. (2014). Mitigation of Variability and Reliability Margins in
IC Implementation /. <em>UC San Diego</em>. ProQuest ID:
Chan_ucsd_0033D_14269. Merritt ID: ark:/20775/bb52916761. Retrieved from
<a
href="https://escholarship.org/uc/item/35r1m001">https://escholarship.org/uc/item/35r1m001</a></p>
<p>Dr. Adam Temanm, Digital VLSI Design:Lecture 10: Routing <a
href="https://www.eng.biu.ac.il/temanad/files/2017/02/Lecture-10-Routing.pdf">https://www.eng.biu.ac.il/temanad/files/2017/02/Lecture-10-Routing.pdf</a></p>
<p>Article (20487193) Title: Setting Pegasus - LVS to Quantus
av_extracted view Flow with TSMC16 packages URL:
https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V000009MprZUAS</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Second-Order System</title>
    <url>/2024/01/06/SecondOrder/</url>
    <content><![CDATA[<h2 id="additional-zero">additional Zero</h2>
<h3 id="peaking-frequency">peaking frequency</h3>
<p><span class="math display">\[\begin{align}
TF &amp;= \frac{s +\omega_z}{s^2+2\zeta \omega_ns+\omega_n^2} \\
&amp;= \frac{\omega _z}{\omega _n^2}\cdot \frac{1+s/\omega
_z}{1+s^2/\omega_n^2+2\zeta s/\omega_n}
\end{align}\]</span></p>
<p>Let <span class="math inline">\(s=j\omega\)</span> and omit factor,
<span class="math display">\[
A_\text{dB}(\omega) = 10\log[1+(\frac{\omega}{\omega _z})^2] -
10\log[1+\frac{\omega^4}{\omega_n^4}+\frac{2\omega^2(2\zeta ^2
-1)}{\omega_n^2}]
\]</span> peaking frequency <span
class="math inline">\(\omega_\text{peak}\)</span> can be obtained via
<span class="math inline">\(\frac{d A_\text{dB}(\omega)}{d\omega} =
0\)</span> <span class="math display">\[
\omega_\text{peak} = \omega_z \sqrt{\sqrt{(\frac{\omega_n}{\omega_z})^4
- 2(\frac{\omega_n}{\omega_z})^2(2\zeta ^2-1)+1} - 1}
\]</span></p>
<h2 id="step-response-of-higher-order-system">Step Response of higher
order system</h2>
<p><img src="/2024/01/06/SecondOrder/image-20240112002314153.png"
alt="image-20240112002314153" /></p>
<p>Since <span class="math inline">\(1/sC_1+R_1 \gg R_0\)</span> <span
class="math display">\[
V_m(s) \simeq \frac{R_0}{R_0 + 1/sC_0} = \frac{sR_0C_0}{1+sR_0C_0}
\]</span> step response of <span class="math inline">\(V_m\)</span>
<span class="math display">\[
V_m(t) = e^{-t/R_0C_0}
\]</span> where <span class="math inline">\(\tau = R_0C_0\)</span></p>
<p>And <span class="math inline">\(V_o(s)\)</span> can be expressed as
<span class="math display">\[\begin{align}
V_o(s)  &amp; \simeq \frac{sR_0C_0}{1+sR_0C_0} \cdot
\frac{sR_1C_1}{1+sR_1C_1} \\
&amp;= \frac{sR_0C_0R_1C_1}{R_0C_0-R_1C_1}\left(\frac{1}{1+sR_1C_1} -
\frac{1}{1+sR_0C_0}\right)
\end{align}\]</span></p>
<p>Then step response of <span class="math inline">\(Vo\)</span> <span
class="math display">\[\begin{align}
Vo(t) &amp;= \frac{R_0C_0R_1C_1}{R_0C_0-R_1C_1}
\left(\frac{1}{R_1C_1}e^{-t/R_1C_1} -
\frac{1}{R_0C_0}e^{-t/R_0C_0}\right) \\
&amp;= \frac{1}{R_0C_0-R_1C_1}\left(R_0C_0e^{-t/R_1C_1} -
R_1C_1e^{-t/R_0C_0}\right) \\
&amp;\simeq = \frac{1}{R_0C_0-R_1C_1}\left(R_0C_0e^{-t/R_1C_1} -
R_1C_1\right)
\end{align}\]</span></p>
<p>where <span class="math inline">\(\tau=R_1C_1\)</span></p>
<h3 id="via-partial-fraction-expansion">Via Partial-fraction
Expansion</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms C0</span><br><span class="line">syms R0</span><br><span class="line">syms C1</span><br><span class="line">syms R1</span><br><span class="line">syms s</span><br><span class="line"></span><br><span class="line">Z0 = <span class="number">1</span>/s/C1 + R1;</span><br><span class="line">Z1 = R0*Z0/(R0+Z0);</span><br><span class="line">vm = Z1 / (Z1 + <span class="number">1</span>/s/C0);</span><br><span class="line">vo = R1/Z0 * vm;</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; partfrac(vm, s)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> - (s*(C1*R0 + C1*R1) + <span class="number">1</span>)/(C0*C1*R0*R1*s^<span class="number">2</span> + (C0*R0 + C1*R0 + C1*R1)*s + <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">&gt;&gt; partfrac(vo, s)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> - (s*(C0*R0 + C1*R0 + C1*R1) + <span class="number">1</span>)/(C0*C1*R0*R1*s^<span class="number">2</span> + (C0*R0 + C1*R0 + C1*R1)*s + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[\begin{align}
V_m(s) &amp;= 1 -
\frac{s(C_1R_0+C_1R_1)+1}{C_0C_1R_0R_1s^2+(C_0R_0+C_1R_0+C_1R_1)s+1} \\
V_o(s) &amp;= 1 -
\frac{s(C_0R_0+C_1R_0+C_1R_1)+1}{C_0C_1R_0R_1s^2+(C_0R_0+C_1R_0+C_1R_1)s+1}
\end{align}\]</span></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C0 = <span class="number">200e-9</span>;</span><br><span class="line">R0 = <span class="number">50</span>;</span><br><span class="line">C1 = <span class="number">400e-15</span>;</span><br><span class="line">R1 = <span class="number">200e3</span>;</span><br><span class="line"></span><br><span class="line">s = tf(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"></span><br><span class="line">Z0 = <span class="number">1</span>/s/C1 + R1;</span><br><span class="line">Z1 = R0*Z0/(R0+Z0);</span><br><span class="line">vm = Z1 / (Z1 + <span class="number">1</span>/s/C0);</span><br><span class="line">vo = R1/Z0 * vm;</span><br><span class="line"></span><br><span class="line">vm_exp = <span class="number">1</span> - (s*(C1*R0 + C1*R1) + <span class="number">1</span>)/(C0*C1*R0*R1*s^<span class="number">2</span> + (C0*R0 + C1*R0 + C1*R1)*s + <span class="number">1</span>);</span><br><span class="line">vo_exp = <span class="number">1</span> - (s*(C0*R0 + C1*R0 + C1*R1) + <span class="number">1</span>)/(C0*C1*R0*R1*s^<span class="number">2</span> + (C0*R0 + C1*R0 + C1*R1)*s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">step(vm, <span class="number">500e-9</span>, <span class="string">&#x27;k-o&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">step(vm_exp, <span class="number">500e-9</span>, <span class="string">&#x27;r-^&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;vm step response&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">step(vo, <span class="number">500e-9</span>, <span class="string">&#x27;k-o&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">step(vo_exp, <span class="number">500e-9</span>, <span class="string">&#x27;r-^&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;vo step response&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% with approximation</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">vm_exp2 = s*R0*C0/(<span class="number">1</span>+s*R0*C0);</span><br><span class="line">vo_exp2 = s*R0*C0/(<span class="number">1</span>+s*R0*C0) * s*R1*C1/(<span class="number">1</span>+s*R1*C1);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">step(vm, <span class="number">500e-9</span>, <span class="string">&#x27;k-o&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">step(vm_exp2, <span class="number">500e-9</span>, <span class="string">&#x27;r-^&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;vm step response&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>()</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">step(vo, <span class="number">500e-9</span>, <span class="string">&#x27;k-o&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">step(vo_exp2, <span class="number">500e-9</span>, <span class="string">&#x27;r-^&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;vo step response&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>()</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/06/SecondOrder/image-20240113181003272.png"
alt="image-20240113181003272" /></p>
<p><img src="/2024/01/06/SecondOrder/image-20240113181032379.png"
alt="image-20240113181032379" /></p>
<hr />
<p>spectre simulation vs matlab</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C0 = <span class="number">200e-9</span>;</span><br><span class="line">R0 = <span class="number">50</span>;</span><br><span class="line">C1 = <span class="number">400e-15</span>;</span><br><span class="line">R1 = <span class="number">200e3</span>;</span><br><span class="line"></span><br><span class="line">s = tf(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"></span><br><span class="line">Z0 = <span class="number">1</span>/s/C1 + R1;</span><br><span class="line">Z1 = R0*Z0/(R0+Z0);</span><br><span class="line">vm = Z1 / (Z1 + <span class="number">1</span>/s/C0);</span><br><span class="line">vo = R1/Z0 * vm;</span><br><span class="line"></span><br><span class="line">step(vm, <span class="number">500e-9</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">step(vo, <span class="number">500e-9</span>);</span><br><span class="line"></span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vm</span><br><span class="line"></span><br><span class="line">vm =</span><br><span class="line"> </span><br><span class="line">          <span class="number">1.024e-44</span> s^<span class="number">5</span> + <span class="number">2.56e-37</span> s^<span class="number">4</span> + <span class="number">1.6e-30</span> s^<span class="number">3</span></span><br><span class="line">  -----------------------------------------------------------</span><br><span class="line">  <span class="number">1.024e-44</span> s^<span class="number">5</span> + <span class="number">2.571e-37</span> s^<span class="number">4</span> + <span class="number">1.626e-30</span> s^<span class="number">3</span> + <span class="number">1.6e-25</span> s^<span class="number">2</span></span><br><span class="line"> </span><br><span class="line">Continuous-time transfer <span class="keyword">function</span>.</span><br><span class="line"></span><br><span class="line">&gt;&gt; vo</span><br><span class="line"></span><br><span class="line">vo =</span><br><span class="line"> </span><br><span class="line">                 <span class="number">8.194e-52</span> s^<span class="number">6</span> + <span class="number">2.048e-44</span> s^<span class="number">5</span> + <span class="number">1.28e-37</span> s^<span class="number">4</span></span><br><span class="line">  ---------------------------------------------------------------------------</span><br><span class="line">  <span class="number">8.194e-52</span> s^<span class="number">6</span> + <span class="number">3.081e-44</span> s^<span class="number">5</span> + <span class="number">3.871e-37</span> s^<span class="number">4</span> + <span class="number">1.638e-30</span> s^<span class="number">3</span> + <span class="number">1.6e-25</span> s^<span class="number">2</span></span><br><span class="line"> </span><br><span class="line">Continuous-time transfer <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure>
<p><img src="/2024/01/06/SecondOrder/image-20240112002155622.png"
alt="image-20240112002155622" /></p>
<h2 id="reference">reference</h2>
<p><em>Gene F. Franklin, J. David Powell, and Abbas Emami-Naeini. 2018.
Feedback Control of Dynamic Systems (8th Edition) (8th. ed.).
Pearson.</em></p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>SpiceIn foundary&#39;s standard cell&#39;s spice netlist</title>
    <url>/2022/10/22/SpiceIn-standardcellspi/</url>
    <content><![CDATA[<p>use <strong>SpiceIn</strong> GUI feature to map MOS parameter
correctly in generated schematic</p>
<h3 id="input">Input</h3>
<p><img
src="/2022/10/22/SpiceIn-standardcellspi/image-20221022224745955.png"
alt="image-20221022224745955" /></p>
<blockquote>
<p>The mos's total width (parameter name "w") value will update during
<strong>SpiceIn</strong> trigger CDF callback automatically</p>
</blockquote>
<h3 id="output">Output</h3>
<p><img
src="/2022/10/22/SpiceIn-standardcellspi/image-20221022225143844.png"
alt="image-20221022225143844" /></p>
<h3 id="device-map">Device Map</h3>
<p><img
src="/2022/10/22/SpiceIn-standardcellspi/image-20221022225224751.png"
alt="image-20221022225224751" /></p>
<blockquote>
<p><strong>User Prop Mapping</strong> is significant setup, both
<em>xxx.spi</em> and <em>Edit CDF</em> provide the essential
information.</p>
<p>The map syntax is <em>spice_para0 cdf_para0 spice_para1 cdf_para01
... spice_paraN cdf_paraN</em></p>
</blockquote>
<p><img
src="/2022/10/22/SpiceIn-standardcellspi/image-20221022225742497.png"
alt="image-20221022225742497" /></p>
<h3 id="reference">reference</h3>
<p>Article (20488179) Title: How to use SpiceIn GUI feature to map MOS
parameter correctly in generated schematic URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009bdPWEAY">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009bdPWEAY</a></p>
<p>Article (11724692) Title: SpiceIn maps the netlist parameter to the
CDF parameter incorrectly on the generated schematic devices (e.g. w to
wf) URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000nZ2CEAU">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000nZ2CEAU</a></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>StatEye</title>
    <url>/2023/09/23/StatEye/</url>
    <content><![CDATA[<h2 id="matlab---pulse2stateye">Matlab - <code>pulse2stateye</code></h2>
<blockquote>
<p>Due to this function only output PDF of eye, postprocessing is needed
which cumulative sum PDF.</p>
</blockquote>
<h3 id="probability-density-functionpdf-plot">Probability Density
Function(PDF) plot</h3>
<p><img src="/2023/09/23/StatEye/PDF.jpg" alt="PDF" /></p>
<h3 id="bit-error-rateber-plot">Bit Error Rate(BER) plot</h3>
<p><img src="/2023/09/23/StatEye/BER.jpg" alt="BER" /></p>
<h3 id="pulse-response">pulse response</h3>
<p><img src="/2023/09/23/StatEye/image-20220502134522549.png"
alt="image-20220502134522549" /></p>
<blockquote>
<p>DC shift don't affect <code>pulse2stateye</code> function
normally</p>
<p>Both pulse <code>[0 0 0 0 .. 0 1 0 0 0 0 0 ...]</code> and
<code>[1 1 1 1 ... 1 0 1 1 1 1 ...]</code> can be fed into</p>
<p><code>pulse2stateye</code> function</p>
<p><strong>CAUTION</strong>: the <code>0</code> don't mean common
voltage but bit <code>0</code> , which is <code>-Vpeak</code> in
differential link</p>
</blockquote>
<h3 id="postprocessing-function">postprocessing function</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% REF: https://www.mathworks.com/help/serdes/ref/pulse2stateye.html</span></span><br><span class="line">load(<span class="string">&#x27;PulseResponseReflective100ps.mat&#x27;</span>);</span><br><span class="line">modulation = <span class="number">2</span>;</span><br><span class="line">pulsewave = <span class="built_in">zeros</span>(<span class="built_in">size</span>(pulse, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">pulsewave = pulse(:, <span class="number">1</span>);</span><br><span class="line">pulsewave(:,<span class="number">1</span>) = pulsewave - pulsewave(<span class="number">1</span>);  <span class="comment">% DC shift, although `pulse2stateye` shift internally</span></span><br><span class="line"></span><br><span class="line">[stateye,vh,th] = pulse2stateye(pulsewave,SamplesPerSymbol,modulation);</span><br><span class="line"><span class="comment">%stateye(1:200, 1:200) = 10000;</span></span><br><span class="line">cmap = serdes.utilities.SignalIntegrityColorMap;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">imagesc(th*SymbolTime*<span class="number">1e12</span>,vh,stateye)</span><br><span class="line">colormap(cmap)</span><br><span class="line">colorbar</span><br><span class="line">axis(<span class="string">&#x27;xy&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;ps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Statistical Eye PDF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[ysize, xsize] = <span class="built_in">size</span>(stateye);</span><br><span class="line">ymid = <span class="built_in">floor</span>((ysize+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">upperEyePDF = stateye(ymid:<span class="keyword">end</span>,:);</span><br><span class="line">lowerEyePDF = stateye(ymid:<span class="number">-1</span>:<span class="number">1</span>,:); <span class="comment">% upside down</span></span><br><span class="line"></span><br><span class="line">upperEyeCDF = cumsum(upperEyePDF, <span class="number">1</span>);</span><br><span class="line">lowerEyeCDF = cumsum(lowerEyePDF, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">berlist = [<span class="number">1e-12</span>, <span class="number">1e-6</span>, <span class="number">0.01</span>];</span><br><span class="line">lenBer = <span class="built_in">length</span>(berlist);</span><br><span class="line">upperBERIdx = <span class="built_in">zeros</span>(lenBer, xsize);</span><br><span class="line">lowerBERIdx = <span class="built_in">zeros</span>(lenBer, xsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:lenBer</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:xsize</span><br><span class="line">        upperBERIdx(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">find</span>(upperEyeCDF(:, <span class="built_in">j</span>) &gt;= berlist(<span class="built_in">i</span>), <span class="number">1</span>);</span><br><span class="line">        lowerBERIdx(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">find</span>(lowerEyeCDF(:, <span class="built_in">j</span>) &gt;= berlist(<span class="built_in">i</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% shift idx to algin original stateye</span></span><br><span class="line">upperBERIdx = ymid - <span class="number">1</span> + upperBERIdx;</span><br><span class="line">lowerBERIdx = ymid + <span class="number">1</span> - lowerBERIdx;</span><br><span class="line"></span><br><span class="line">upperBERVal = vh(upperBERIdx);</span><br><span class="line">lowerBERVal = vh(lowerBERIdx);</span><br><span class="line"></span><br><span class="line">tticks = th*SymbolTime*<span class="number">1e12</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">lgd = cell(lenBer*<span class="number">2</span>,<span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:lenBer<span class="comment">% REF: https://www.mathworks.com/help/serdes/ref/pulse2stateye.html</span></span><br><span class="line">load(<span class="string">&#x27;PulseResponseReflective100ps.mat&#x27;</span>);</span><br><span class="line">modulation = <span class="number">2</span>;</span><br><span class="line">pulsewave = <span class="built_in">zeros</span>(<span class="built_in">size</span>(pulse, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">pulsewave = pulse(:, <span class="number">1</span>);    <span class="comment">% remove crosstalk pulse responses</span></span><br><span class="line"></span><br><span class="line">[stateye,vh,th] = pulse2stateye(pulsewave,SamplesPerSymbol,modulation);</span><br><span class="line">cmap = serdes.utilities.SignalIntegrityColorMap;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">imagesc(th*SymbolTime*<span class="number">1e12</span>,vh,stateye)</span><br><span class="line">colormap(cmap)</span><br><span class="line">colorbar</span><br><span class="line">axis(<span class="string">&#x27;xy&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;ps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Statistical Eye PDF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[ysize, xsize] = <span class="built_in">size</span>(stateye);</span><br><span class="line">ymid = <span class="built_in">floor</span>((ysize+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">upperEyePDF = stateye(ymid:<span class="keyword">end</span>,:);</span><br><span class="line">lowerEyePDF = stateye(ymid:<span class="number">-1</span>:<span class="number">1</span>,:); <span class="comment">% upside down</span></span><br><span class="line"></span><br><span class="line">upperEyeCDF = cumsum(upperEyePDF, <span class="number">1</span>);</span><br><span class="line">lowerEyeCDF = cumsum(lowerEyePDF, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">berlist = [<span class="number">1e-12</span>, <span class="number">1e-6</span>, <span class="number">0.01</span>];</span><br><span class="line">lenBer = <span class="built_in">length</span>(berlist);</span><br><span class="line">upperBERIdx = <span class="built_in">zeros</span>(lenBer, xsize);</span><br><span class="line">lowerBERIdx = <span class="built_in">zeros</span>(lenBer, xsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:lenBer</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:xsize</span><br><span class="line">        upperBERIdx(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">find</span>(upperEyeCDF(:, <span class="built_in">j</span>) &gt;= berlist(<span class="built_in">i</span>), <span class="number">1</span>);</span><br><span class="line">        lowerBERIdx(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">find</span>(lowerEyeCDF(:, <span class="built_in">j</span>) &gt;= berlist(<span class="built_in">i</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% shift idx to algin original stateye</span></span><br><span class="line">upperBERIdx = ymid - <span class="number">1</span> + upperBERIdx;</span><br><span class="line">lowerBERIdx = ymid + <span class="number">1</span> - lowerBERIdx;</span><br><span class="line"></span><br><span class="line">upperBERVal = vh(upperBERIdx);</span><br><span class="line">lowerBERVal = vh(lowerBERIdx);</span><br><span class="line"></span><br><span class="line">tticks = th*SymbolTime*<span class="number">1e12</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">lgd = cell(lenBer*<span class="number">2</span>,<span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:lenBer</span><br><span class="line">    <span class="built_in">plot</span>(tticks, upperBERVal(<span class="built_in">i</span>, :), <span class="string">&#x27;Color&#x27;</span>, cmap(<span class="built_in">i</span>*<span class="number">15</span>, :));</span><br><span class="line">    lgd&#123;<span class="built_in">i</span>*<span class="number">2</span><span class="number">-1</span>&#125; = strcat(<span class="string">&#x27;BER=&#x27;</span>,num2str(berlist(<span class="built_in">i</span>)));</span><br><span class="line">    <span class="built_in">plot</span>(tticks, lowerBERVal(<span class="built_in">i</span>, :), <span class="string">&#x27;Color&#x27;</span>, cmap(<span class="built_in">i</span>*<span class="number">15</span>, :));</span><br><span class="line">    lgd&#123;<span class="built_in">i</span>*<span class="number">2</span>&#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(lgd)</span><br><span class="line">axis(<span class="string">&#x27;xy&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;ps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Statistical Eye BER&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">tt = [<span class="number">0</span>:<span class="built_in">size</span>(pulsewave, <span class="number">1</span>)<span class="number">-1</span>]*dt;</span><br><span class="line"><span class="built_in">plot</span>(tt*<span class="number">1e9</span>, pulsewave, <span class="string">&#x27;k&#x27;</span>, tt*<span class="number">1e9</span>, pulsewave-pulsewave(<span class="number">1</span>), <span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;original&#x27;</span>, <span class="string">&#x27;dc shift&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">10</span>]);</span><br><span class="line">ylim([<span class="number">-0.65</span> <span class="number">0.65</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ns)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;voltage (V)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;pulse response&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">    <span class="built_in">plot</span>(tticks, upperBERVal(<span class="built_in">i</span>, :), <span class="string">&#x27;Color&#x27;</span>, cmap(<span class="built_in">i</span>*<span class="number">15</span>, :));</span><br><span class="line">    lgd&#123;<span class="built_in">i</span>*<span class="number">2</span><span class="number">-1</span>&#125; = strcat(<span class="string">&#x27;BER=&#x27;</span>,num2str(berlist(<span class="built_in">i</span>)));</span><br><span class="line">    <span class="built_in">plot</span>(tticks, lowerBERVal(<span class="built_in">i</span>, :), <span class="string">&#x27;Color&#x27;</span>, cmap(<span class="built_in">i</span>*<span class="number">15</span>, :));</span><br><span class="line">    lgd&#123;<span class="built_in">i</span>*<span class="number">2</span>&#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(lgd)</span><br><span class="line">axis(<span class="string">&#x27;xy&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;ps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Statistical Eye BER&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">tt = [<span class="number">0</span>:<span class="built_in">size</span>(pulsewave, <span class="number">1</span>)<span class="number">-1</span>]*dt;</span><br><span class="line"><span class="built_in">plot</span>(tt*<span class="number">1e9</span>, pulsewave);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ns)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;voltage (V)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;pulse response&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<h3 id="pulse-without-isi">pulse without ISI</h3>
<blockquote>
<p>Vp2p = 1V</p>
</blockquote>
<p><img src="/2023/09/23/StatEye/image-20220502135551321.png"
alt="image-20220502135551321" /></p>
<p><img src="/2023/09/23/StatEye/image-20220502135535943.png"
alt="image-20220502135535943" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">modulation = <span class="number">2</span>;</span><br><span class="line">SamplesPerSymbol = <span class="number">32</span>;</span><br><span class="line">pulsewave = <span class="built_in">zeros</span>(SamplesPerSymbol*<span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">pulsewave(<span class="number">3</span>*SamplesPerSymbol:<span class="number">4</span>*SamplesPerSymbol<span class="number">-1</span>, <span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[stateye,vh,th] = pulse2stateye(pulsewave,SamplesPerSymbol,modulation);</span><br><span class="line">cmap = serdes.utilities.SignalIntegrityColorMap;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">imagesc(th*SymbolTime*<span class="number">1e12</span>,vh,stateye)</span><br><span class="line">colormap(cmap)</span><br><span class="line">colorbar</span><br><span class="line">axis(<span class="string">&#x27;xy&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;ps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Statistical Eye PDF&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">tt = [<span class="number">0</span>:<span class="built_in">size</span>(pulsewave, <span class="number">1</span>)<span class="number">-1</span>]*dt;</span><br><span class="line"><span class="built_in">plot</span>(tt*<span class="number">1e9</span>, pulsewave, <span class="string">&#x27;k&#x27;</span>, tt*<span class="number">1e9</span>, pulsewave-pulsewave(<span class="number">1</span>), <span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;original&#x27;</span>, <span class="string">&#x27;dc shift&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ns)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;voltage (V)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;pulse response&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<h2 id="hspice---snpssimade">HSPICE - <code>snpsSimADE</code></h2>
<blockquote>
<p>use StatEye Analysis in HSPICE</p>
</blockquote>
<h3 id="create-netlist-with-hspiced-in-virtuoso">create netlist with
hspiceD in Virtuoso</h3>
<p><img src="/2023/09/23/StatEye/image-20220708011315422.png"
alt="image-20220708011315422" /></p>
<h3 id="modify-netlist">modify netlist</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P1 vi 0  port=1  Z0=0 LFSR (1 0 0 100p 100p 1G 1 [5,2])</span><br><span class="line">P2 vo 0  port=2  Z0=1G</span><br><span class="line">.stateye T=1ns trf=100p incident_port=1 probe_port=2</span><br><span class="line">.probe stateye eye(2) berC(2) eyeBW(2)</span><br><span class="line">.print stateye eye(2) berC(2) eyeBW(2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note both<code>Z0=0</code> and <code>Z0=1G</code> are used to remove
port's effect, which is used as ideal voltage source and voltage
monitor</p>
</blockquote>
<p><img src="/2023/09/23/StatEye/image-20220708012542135.png"
alt="image-20220708012542135" /></p>
<blockquote>
<p>The <code>.probe stateye</code> command generates
<code>netlist.stet#</code> and <code>netlist.stev#</code> for following
purposes:</p>
<ul>
<li>netlist.stet#: eye(t,v), eyeBW(t,v), eyeV(t), ber(t,v) and
bathtubV(t)</li>
<li>netlist.stet#: eye(t,v), eyeBW(t,v), eyeV(t), ber(t,v) and
bathtubV(t)</li>
</ul>
</blockquote>
<h3 id="setup">setup</h3>
<h4 id="cdsinit">.cdsinit</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load( strcat( getShellEnvVar(&quot;HSPICE_HOME&quot;) &quot;/hspice/interface/snpsSimADE.ile&quot; ))</span><br></pre></td></tr></table></figure>
<h4 id="environment-variable">environment variable</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CDS_LOAD_ENV=CSF</span><br><span class="line">export SNPSSIMADE_LOAD_MODE=HSPICE</span><br></pre></td></tr></table></figure>
<h2 id="references">references</h2>
<p>Sanders, Anthony, Michael Resso and John D'Ambrosia. “Channel
Compliance Testing Utilizing Novel Statistical Eye Methodology.”
(2004).</p>
<p>X. Chu, W. Guo, J. Wang, F. Wu, Y. Luo and Y. Li, "Fast and Accurate
Estimation of Statistical Eye Diagram for Nonlinear High-Speed Links,"
in IEEE Transactions on Very Large Scale Integration (VLSI) Systems,
vol. 29, no. 7, pp. 1370-1378, July 2021, doi:
10.1109/TVLSI.2021.3082208.</p>
<p>HSPICE® User Guide: Signal Integrity Modeling and Analysis, Version
Q-2020.03, March 2020</p>
<p>IA Title: Common Electrical I/O (CEI) - Electrical and Jitter
Interoperability agreements for 6G+ bps, 11G+ bps, 25G+ bps I/O and 56G+
bps IA # OIF-CEI-04.0 December 29, 2017 [<a
href="https://www.oiforum.com/wp-content/uploads/2019/01/OIF-CEI-04.0.pdf">pdf</a>]</p>
<p>Chris Li Ph.D. student at the University of Toronto [<a
href="https://github.com/ChrisZonghaoLi/pystateye">pystateye
repo</a>]</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>voltage-dependent DRC checks</title>
    <url>/2022/04/13/VD-DRC/</url>
    <content><![CDATA[<p>In T* DRC deck, it is based on the voltage recognition CAD layer and
net connection to calculate the voltage difference between two
neighboring nets by the following formula:</p>
<p><span class="math display">\[
\Delta V = \max(V_H(\text{net1})-V_L(\text{net2}),
V_H(\text{net2})-V_L(\text{net1}))
\]</span></p>
<p>where <span class="math display">\[
V_H(\text{netx}) = \max(V(\text{netx}))
\]</span> and <span class="math display">\[
V_L(\text{netx}) = \min(V(\text{netx}))
\]</span></p>
<blockquote>
<ul>
<li>The <span class="math inline">\(\Delta V\)</span> will be
<strong>0</strong> if two nets are connected as same potential</li>
<li>If <span class="math inline">\(V_L \gt V_H\)</span> <strong>on a
net</strong>, DRC will report warning on this net</li>
</ul>
</blockquote>
<h2 id="voltage-recognition-cad-layer">Voltage recognition CAD
Layer</h2>
<p>Two method</p>
<ol type="1">
<li><p>voltage text layer</p>
<p>You place specific voltage text on specific drawing layer</p></li>
<li><p>voltage marker layer</p>
<p>Each voltage marker layer represent different voltage for specific
drawing layer</p></li>
</ol>
<blockquote>
<p><em>voltage text layer</em> has higher priority than <em>voltage
marker layer</em> and is recommended</p>
</blockquote>
<h3 id="voltage-text-layer">voltage text layer</h3>
<p>For example <strong>M3</strong></p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 9%" />
<col style="width: 32%" />
<col style="width: 8%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>Process Layer</th>
<th>CAD Layer#</th>
<th>Voltage High</th>
<th>Voltage High Top<br />(highest priority)</th>
<th>Voltage Low</th>
<th>Voltage Low Top<br />(highest priority)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>M3</td>
<td>63</td>
<td>110</td>
<td>112</td>
<td>111</td>
<td>113</td>
</tr>
</tbody>
</table>
<blockquote>
<p>where <strong>63</strong> is <strong>layer number</strong>,
<strong>110 ~ 113</strong> is <strong>datatype</strong></p>
</blockquote>
<h3 id="voltage-marker-layer">voltage marker layer</h3>
<p>Different data type represent different voltage, like</p>
<table>
<thead>
<tr class="header">
<th>DataType</th>
<th>100</th>
<th>101</th>
<th>102</th>
<th>...</th>
<th>109</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Voltage</td>
<td>0.0</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.9</td>
</tr>
</tbody>
</table>
<h2 id="example">Example</h2>
<p><img src="/2022/04/13/VD-DRC/image-20220503171006936.png"
alt="image-20220503171006936" /></p>
<h2 id="reference">reference</h2>
<p><a
href="https://blogs.sw.siemens.com/calibre/2015/08/18/automate-those-voltage-dependent-drc-checks/">Automate
those voltage-dependent DRC checks! - siemens</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>VMware Disk Shrink</title>
    <url>/2022/12/16/VMwareDiskShrink/</url>
    <content><![CDATA[<p>In Guest OS and run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure>
<p><a
href="https://superuser.com/q/211798">https://superuser.com/q/211798</a></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Virtual Connectivity</title>
    <url>/2023/05/11/Virtual-Connectivity/</url>
    <content><![CDATA[<p>Normally, if the layout connectivity extractor finds disjoint,
unconnected geometries with the same net name text attached, the
extractor will view this as an open circuit.</p>
<ul>
<li>Virtual connection results in the extraction of a single net from
two or more disjoint physical nets when the physical net segments share
the same name.</li>
<li>Virtual connectivity is triggered by the rule file <strong>VIRTUAL
CONNECT COLON</strong> and <strong>VIRTUAL CONNECT NAME</strong>
specification statements.</li>
<li>Virtual connectivity can also be specified through the Calibre
Interactive GUI.</li>
</ul>
<h3 id="virtual-connect-colon">VIRTUAL CONNECT COLON</h3>
<p><strong>Virtual Connect Colon</strong> is used to virtually connect
nets that <em>share a common prefix before a colon</em>, like
VDD<strong>:</strong>1, VDD<strong>:</strong>2, and so forth.</p>
<p>If you specify <em>YES</em>, then the connectivity extractor first
<em>strips off</em> all characters from the first colon to the end of
the label names.</p>
<p>Next, the extractor forms a virtual connection between any two labels
that have the same name and that <em>originally contained a
colon</em>.</p>
<p>Colons can appear anywhere in the name with the exception that a
colon at the beginning of a name is treated as a regular character (that
is, it has no special effect).</p>
<p><img
src="/2023/05/11/Virtual-Connectivity/image-20230511211343788.png"
alt="image-20230511211343788" /></p>
<blockquote>
<p><em>up to the first colon character</em> encountered</p>
<p>The <em>colon</em> is <strong>discarded</strong> in the extracted net
name</p>
</blockquote>
<p><img
src="/2023/05/11/Virtual-Connectivity/image-20230511211607588.png"
alt="image-20230511211607588" /></p>
<h3 id="virtual-connect-name">VIRTUAL CONNECT NAME</h3>
<p><strong>Virtual Connect Name</strong> virtually connects nets that
share the same name</p>
<p>Each name is a net name and can be optionally enclosed in quotes.</p>
<p>The connectivity extractor forms a virtual connection between any two
labels having the same name such that the label name appears in a
<strong>Virtual Connect Name</strong> specification statement in the
rule file.</p>
<p><img
src="/2023/05/11/Virtual-Connectivity/image-20230511211209469.png"
alt="image-20230511211209469" /></p>
<blockquote>
<p><code>VIRTUAL CONNECT NAME ?</code> == Connect all nets by name</p>
</blockquote>
<p>Note that if <strong>Virtual Connect Colon YES</strong> is also
specified, then <strong>Virtual Connect Name</strong> operates on names
<em>after all colon suffixes have been stripped off</em>.</p>
<p><img
src="/2023/05/11/Virtual-Connectivity/image-20230511211651448.png"
alt="image-20230511211651448" /></p>
<h3 id="reference">reference</h3>
<p>Calibre Fundamentals: Performing DRC/LVS Student Workbook</p>
<p>Calibre Verification User’s Manual Software Version 2019.3 Document
Revision 7</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>Device Aging</title>
    <url>/2022/12/11/aging/</url>
    <content><![CDATA[<p><img src="/2022/12/11/aging/image-20231106232135180.png"
alt="image-20231106232135180" /></p>
<h2 id="terminology">Terminology</h2>
<p>The most accurate method to calculate the degradation of transistors
is the SPICE-level simulation of the whole netlist with application
programming interface (API) and industry-standard stress process
models</p>
<p>​ <strong>MOSRA</strong>: MOSFET reliability analysis Synopsys</p>
<p>​ <strong>RelXpert</strong>: Cadence</p>
<p>​ <strong>TMI</strong>: TSMC Model Interface, TSMC</p>
<p>​ <strong>OMI</strong>: Open Model Interface, Si2 standard,</p>
<blockquote>
<p>The Silicon Integration Initiative (Si2) Compact Model Coalition has
released the <em>Open Model Interface</em>, an Si2 standard, C-language
application programming interface that supports SPICE compact model
extensions.OMI allows circuit designers to simulate and analyze such
important physical effects as <em>self-heating</em> and <em>aging</em>,
and perform extended design optimizations. It is based on TMI2, the TSMC
Model Interface, which was donated to Si2 by TSMC in 2014.</p>
</blockquote>
<ul>
<li><strong>TDDB</strong>: Time-Dependent Dielectric Breakdown</li>
<li><strong>HCI</strong>: Hot Carrier injection</li>
<li><strong>BTI</strong>: Bias Temperature Instability
<ul>
<li><strong>NBTI</strong>: Negative Bias Temperature Instability</li>
<li><strong>PBTI</strong>: Positive Bias Temperature Instability</li>
</ul></li>
<li><strong>SHE</strong>: Self-Heating Effect</li>
</ul>
<p><img src="/2022/12/11/aging/4645.reliability.png"
alt="4645.reliability.png" /></p>
<h2 id="aging-she-in-finfet">Aging &amp; SHE in FinFET</h2>
<p><img src="/2022/12/11/aging/image-20230513215602865.png"
alt="image-20230513215602865" /></p>
<h2 id="she">SHE</h2>
<p><img src="/2022/12/11/aging/image-20221214001912093.png"
alt="image-20221214001912093" /></p>
<p><img src="/2022/12/11/aging/image-20230513110032603.png"
alt="image-20230513110032603" /></p>
<p><img src="/2022/12/11/aging/image-20221214001940656.png"
alt="image-20221214001940656" /></p>
<h3 id="self-heating-em">Self-Heating &amp; EM</h3>
<p><img src="/2022/12/11/aging/image-20230513220047241.png"
alt="image-20230513220047241" /></p>
<h3 id="heat-sink-hs">Heat Sink (HS)</h3>
<ol type="1">
<li><p>guard ring</p>
<p>closer OD help reduce dT</p></li>
<li><p>extended gate</p></li>
<li><p>source/drain metal stack</p></li>
</ol>
<h2 id="bti">BTI</h2>
<p><img src="/2022/12/11/aging/slide_39.jpg" alt="img" /></p>
<p>BTI occurs <em>predominantly in PMOS (or p-type or p channel)</em>
transistors and causes an increase in the transistor's <em>absolute
threshold voltage</em>.</p>
<p>Stress in the case of NBTI means that the PMOS transistor is
<strong>in inversion</strong>; that means that its <strong>gate to
body</strong> potential is substantially below 0 V for analogue circuits
or at <em>VGB = −VDD</em> for digital circuits</p>
<p><em>Higher voltages</em> and <em>higher temperatures</em> both have
an exponential impact onto the degradation, induced by NBTI.</p>
<p>NBTI will be accelaerated with thinner gate oxide, at a high
temperature and at a high electric field across the oxide region.</p>
<p>During recovery phase where the gate voltage of pMOS is high and
stress is removed, the H atoms in the gate oxiede diffuse back to
Si-SiO2 interface and the recombination of Si-H bonds reduces the
threshold voltage of pMOS.</p>
<p><img src="/2022/12/11/aging/image-20230513111525657.png"
alt="image-20230513111525657" /></p>
<p><img src="/2022/12/11/aging/image-20230513111657285.png"
alt="image-20230513111657285" /></p>
<blockquote>
<p>The net result is an increase in the magnitude of the device
<strong>threshold voltage |Vt|</strong>, and a degradation of the
channel <strong>carrier mobility</strong>.</p>
<p><strong>Caution</strong>: The aging model provided by fab may
<strong>NOT</strong> contain recovry effect</p>
</blockquote>
<p><img src="/2022/12/11/aging/image-20230513104621962.png"
alt="image-20230513104621962" /></p>
<p><img src="/2022/12/11/aging/image-20230513104654501.png"
alt="image-20230513104654501" /></p>
<p><img src="/2022/12/11/aging/image-20230513105016631.png"
alt="image-20230513105016631" /></p>
<p><img src="/2022/12/11/aging/image-20230513105100239.png"
alt="image-20230513105100239" /></p>
<h2 id="hci">HCI</h2>
<p>Short-channel MOSFETs may exprience <strong>high lateral electric
fields</strong> if the drain-source voltage is large. while the average
velocity of carriers saturate at high fields, the instantaneous velocity
and hence the kinetic energy of the carriers continue to increase,
especially as they accelerate toward the drain. These are called
<strong>hot</strong> carriers.</p>
<p>In nanometer technologies, hot carrier effects have
<strong>subsided</strong>. This is because the energy required to create
an electron-hole pair, <span class="math inline">\(E_g \simeq 1.12
eV\)</span>, is simply not available if the supply voltage is around
1V.</p>
<p><span class="math display">\[
F_E= E \cdot q
\]</span></p>
<p><span class="math display">\[\begin{align}
E_k &amp;= F_E \cdot s \\
&amp;= E \cdot q \cdot s
\end{align}\]</span></p>
<p>Electrons and holes gaining high <strong>kinetic energies</strong> in
the electric field (<strong>hot carriers</strong>) may be injected into
the gate oxide and cause <em>permanent</em> changes in the
oxide-interface charge distribution, degrading the current-voltage
characteristics of the MOSFET.</p>
<p>The channel hot-electron (CHE) effect is caused by electons flowing
in the channel region, from the source to the drain. This effect is more
pronounced at large drain-to-source voltage, at which the lateral
electric field in the drain end of the channel accelerates the
electrons.</p>
<blockquote>
<p>Four different hot carrier injectoin mechanisms can be distinguished:
- channel hot electron (CHE) injection - drain avalanche hot carrier
(DAHC) injection - secondary generated hot electron (SGHE) injection -
substrate hot electron (SHE) injection</p>
</blockquote>
<p>HCI is more of a <strong>drain-localized</strong> mechanism, and is
primarily a <strong>carrier mobility</strong> degradation (and <em>a Vt
degradation if the device is operated bi-directionally</em>).</p>
<p><img src="/2022/12/11/aging/image-20230512213236023.png"
alt="image-20230512213236023" /></p>
<blockquote>
<p>For smaller transistor dimensions, <em>CHE</em> dominates the hot
carrier degradation effect</p>
</blockquote>
<p>The hot-carrier induced damage in nMOS transistors has been found to
result in either trapping of carriers on defect sites in the oxide or
the creation of interface states at the silicon-oxide interface, or
both.</p>
<p>The damage caused by hot-carrier injection affects the transistor
characteristics by causing a degradation in transconductance, a shift in
the threshold voltage, and a general decrease in the drain current
capability.</p>
<blockquote>
<p>HCI seems to have just a <strong>weak</strong> temperature
dependency. Unlike BTI, it seems to be no or just little recovery. As
holes are much "cooler" (i.e. heavier) than electrons, the channel hot
carrier effect in nMOS devices is shown to be more significant than in
pMOS devices.</p>
</blockquote>
<p><img src="/2022/12/11/aging/image-20231106224938502.png"
alt="image-20231106224938502" /></p>
<h3 id="degradation-saturation-effect">Degradation saturation
effect</h3>
<p>HCI model can reproduce the saturation effect if stress time is long
enough</p>
<p><img src="/2022/12/11/aging/image-20230513112108262.png"
alt="image-20230513112108262" /></p>
<h2 id="tddb">TDDB</h2>
<p>TDDB effect is also related to oxide traps. In general, TDDB refers
to the loss of isolating properties of a dielectric layer. If this
dielectric layer is the gate oxide, TDDB will initially lead to an
increase in the gate tunnelling current.</p>
<p>This soft breakdown can already lead to a parametric degradation.
After a long accumulation period, TDDB leads to a catastrophic reduction
of the channel to gate insulation and thus a functional failure of the
transistor.</p>
<p><img src="/2022/12/11/aging/image-20230513105908505.png"
alt="image-20230513105908505" /></p>
<blockquote>
<p>Scaling drive more concerns in TDDB</p>
</blockquote>
<p><img src="/2022/12/11/aging/slide_33.jpg" alt="img" /></p>
<p><img src="/2022/12/11/aging/slide_34.jpg" alt="img" /></p>
<h2 id="waveform-dependent-nature">waveform-dependent nature</h2>
<p>The figure below illustrates the waveform-dependent nature of these
mechanisms – as described earlier, BTI and HCI depend upon the region of
active device operation. The slew rate of the circuit inputs and output
will have a significant impact upon these mechanisms, especially
HCI.</p>
<p><img src="/2022/12/11/aging/img_5d04562454462.jpg" /></p>
<ul>
<li><strong>Negative bias temperature instability (NBTI)</strong>. This
is caused by <em>constant electric fields</em> degrading the dielectric,
which in turn causes the threshold voltage of the transistor to degrade.
That leads to lower switching speeds. This effect depends on the
activity level of the circuits, with heavier impact on parts of the
design that <em>don’t switch as often</em>, such as gated clocks,
control logic, and reset, programming and test circuitry.</li>
<li><strong>Hot carrier injection (HCI)</strong>. This is caused by
<em>fast-moving</em> electrons inserting themselves into the gate and
degrading performance. It primarily occurs on higher-voltage modes and
fast switching signals.</li>
</ul>
<p><img src="/2022/12/11/aging/image-20230513110202915.png"
alt="image-20230513110202915" /></p>
<ul>
<li><em>longer</em> channel length help both BTI and HCI</li>
<li><em>larger</em> <span class="math inline">\(V_{ds}\)</span> help
BTI, but hurt HCI</li>
<li><em>lower</em> temperature help BTI of core device, but hurt that of
IO device for 7nm FinFET</li>
</ul>
<h2 id="mosra">MOSRA</h2>
<p>MOSRA is a 2-step simulation: 1) Age computation, 2) Post-age
analysis</p>
<h2 id="tmi">TMI</h2>
<p>BTI recovery effect <strong>NOT</strong> included for N7</p>
<h2 id="stochastic-nature-of-reliability-mechanisms">Stochastic Nature
of Reliability Mechanisms</h2>
<blockquote>
<p>A fraction of devices will fail</p>
</blockquote>
<p><img src="/2022/12/11/aging/slide_5.jpg" alt="img" /></p>
<p><img src="/2022/12/11/aging/slide_6.jpg" alt="img" /></p>
<h2 id="circuit-simulations">Circuit Simulations</h2>
<p><img src="/2022/12/11/aging/image-20231106230145351.png"
alt="image-20231106230145351" /></p>
<p><img src="/2022/12/11/aging/image-20231106230226203.png"
alt="image-20231106230226203" /></p>
<h2 id="reference">reference</h2>
<p>Spectre Tech Tips: Device Aging? Yes, even Silicon wears out -
Analog/Custom Design (Analog/Custom design) - Cadence Blogs - Cadence
Community <a
href="https://shar.es/afd31p">https://shar.es/afd31p</a></p>
<p>S. Liao, C. Huang, and A. C. J. X. T. Guo, "New Generation
Reliability Model," Dec 2016. [Online]. Available: <a
href="http://www.mos-ak.org/berkeley_2016/publications/T11_Xie_MOS-AK_Berkeley_2016.pdf">http://www.mos-ak.org/berkeley_2016/publications/T11_Xie_MOS-AK_Berkeley_2016.pdf</a>.
[Accessed Aug 2018]</p>
<p>Tianlei Guo, Jushan Xie, "A Complete Reliability Solution:
Reliability Modeling, Applications, and Integration in Analog Design
Environment" [<a
href="https://mos-ak.org/beijing_2018/presentations/Tianlei_Guo_MOS-AK_Beijing_2018.pdf">https://mos-ak.org/beijing_2018/presentations/Tianlei_Guo_MOS-AK_Beijing_2018.pdf</a>]</p>
<p>FinFET Reliability Analysis with Device Self-Heating via <span
class="citation" data-cites="DanielNenni">@DanielNenni</span> <a
href="https://semiwiki.com/eda/synopsys/5085-finfet-reliability-analysis-with-device-self-heating/">https://semiwiki.com/eda/synopsys/5085-finfet-reliability-analysis-with-device-self-heating/</a></p>
<p>Chris Changze Liu 刘长泽,Hisilicon, Huawei, "Reliability Challenges
in Advanced Technology Node" <a
href="https://www.tek.com.cn/sites/default/files/2018-09/reliability-challenges-in-advanced-technology-node.pdf">https://www.tek.com.cn/sites/default/files/2018-09/reliability-challenges-in-advanced-technology-node.pdf</a></p>
<p>Ben Kaczer, imec. FEOL reliability: from essentials to advanced and
emerging devices and circuits. 2016 IRPS Tutorial</p>
<p>Ben Kaczer, imec. Present and Future of FEOL Reliability—from
Dielectric Trap Properties to Reliable Circuit Operation. 2016 IEDM 2016
[<a href="https://slideplayer.com/slide/12992784/">link</a>]</p>
<p>Kang, Sung-Mo Steve, Yusuf Leblebici and Chulwoo Kim. “CMOS Digital
Integrated Circuits: Analysis &amp; Design, 4th Edition.” (2014).</p>
<p>Behzad Razavi. "Design of Analog CMOS Integrated Circuits" (2016)</p>
<p>Basel Halak. Ageing of Integrated Circuits : Causes, Effects and
Mitigation Techniques. Cham, Switzerland: Springer, 2020. ‌</p>
<p>Elie Maricau, and Georges Gielen. Analog IC Reliability in Nanometer
CMOS. Springer Science &amp; Business Media, 2013. ‌</p>
<p>Transistor Aging Intensifies At 10/7nm And Below <a
href="https://semiengineering.com/transistor-aging-intensifies-10nm/">https://semiengineering.com/transistor-aging-intensifies-10nm/</a></p>
<p>Modeling Effects of Dynamic BTI Degradation on Analog and
Mixed-Signal CMOS Circuits. MOS-AK/GSA Workshop, April 11-12, 2013,
Munich <a
href="https://www.mos-ak.org/munich_2013/presentations/05_Leonhard_Heiss_MOS-AK_Munich_2013.pdf">https://www.mos-ak.org/munich_2013/presentations/05_Leonhard_Heiss_MOS-AK_Munich_2013.pdf</a></p>
<p>Challenges and Solutions in Modeling and Simulation of Device
Self-heating, Reliability Aging and Statistical Variability Effects <a
href="https://www.mos-ak.org/beijing_2018/presentations/Dehuang_Wu_MOS-AK_Beijing_2018.pdf">https://www.mos-ak.org/beijing_2018/presentations/Dehuang_Wu_MOS-AK_Beijing_2018.pdf</a></p>
<p>New Generation Reliability Model <a
href="https://www.mos-ak.org/berkeley_2016/publications/T11_Xie_MOS-AK_Berkeley_2016.pdf">https://www.mos-ak.org/berkeley_2016/publications/T11_Xie_MOS-AK_Berkeley_2016.pdf</a></p>
<p>FinFET SPICE Modeling: Synopsys Solutions to Simulation Challenges of
Advanced Technology Nodes <a
href="https://www.mos-ak.org/washington_dc_2015/presentations/T03_Joddy_Wang_MOS-AK_Washington_DC_2015.pdf">https://www.mos-ak.org/washington_dc_2015/presentations/T03_Joddy_Wang_MOS-AK_Washington_DC_2015.pdf</a></p>
<p>A. Zhang et al., "Reliability variability simulation methodology for
IC design: An EDA perspective," 2015 IEEE International Electron Devices
Meeting (IEDM), Washington, DC, USA, 2015, pp. 11.5.1-11.5.4, doi:
10.1109/IEDM.2015.7409677.</p>
<p>W. -K. Lee et al., "Unifying self-heating and aging simulations with
TMI2," 2014 International Conference on Simulation of Semiconductor
Processes and Devices (SISPAD), Yokohama, Japan, 2014, pp. 333-336, doi:
10.1109/SISPAD.2014.6931631.</p>
<p>Aging and Self-Heating in FinFETs - Breakfast Bytes - Cadence Blogs -
Cadence Community <a
href="https://community.cadence.com/cadence_blogs_8/b/breakfast-bytes/posts/aging-and-self-heating">https://community.cadence.com/cadence_blogs_8/b/breakfast-bytes/posts/aging-and-self-heating</a></p>
<p>Article (20482350) Title: Measure the Impact of Aging in Spectre
Technology URL:
https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V000009ESBFUA4</p>
<p>Karimi, Naghmeh, Thorben Moos and Amir Moradi. “Exploring the Effect
of Device Aging on Static Power Analysis Attacks.” IACR Trans. Cryptogr.
Hardw. Embed. Syst. 2019 (2019): 233-256.[<a
href="https://pdfs.semanticscholar.org/b0f8/720a2b51a479f4a711bec4b47fdd50f29e2d.pdf">link</a>]</p>
<p>Self-Heating Issues Spread <a
href="https://semiengineering.com/self-heating-issues-spread/">https://semiengineering.com/self-heating-issues-spread/</a></p>
<p>Y. Zhao and Y. Qu, "Impact of Self-Heating Effect on Transistor
Characterization and Reliability Issues in Sub-10 nm Technology Nodes,"
in IEEE Journal of the Electron Devices Society, vol. 7, pp. 829-836,
2019, doi: 10.1109/JEDS.2019.2911085.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Ahuja Frequency Compensation</title>
    <url>/2024/01/16/ahuja/</url>
    <content><![CDATA[<p>This <strong>cascode compensation</strong> topology is popularly
known as <strong>Ahuja compensation</strong></p>
<p>The cause of the positive zero is the <em>feedforward current through
<span class="math inline">\(C_m\)</span></em>.</p>
<p>To abolish this zero, we have to cut the feedforward path and create
a unidirectional feedback through <span
class="math inline">\(C_m\)</span>.</p>
<ol type="1">
<li><p>Adding a resistor(nulling resistor) is one way to mitigate the
effect of the feedforward current.</p></li>
<li><p>Another approach uses a current buffer cascode to pass the
small-signal feedback current but cut the feedforward current</p></li>
</ol>
<blockquote>
<p>People name this approach after the author <em>Ahuja</em></p>
</blockquote>
<p>The benefits of <em>Ahuja</em> compensation over Miller compensation
are severa</p>
<ul>
<li><p>better PSRR</p></li>
<li><p>higher unity-gain bandwidth using smaller compensation
capacitor</p></li>
<li><p>ability to cope better with heavy capacitive and resistive
loads</p></li>
</ul>
<blockquote>

</blockquote>
<h2 id="millers-approximation">Miller's approximation</h2>
<p><img src="/2024/01/16/ahuja/image-20240130224043511.png"
alt="image-20240130224043511" /></p>
<h3 id="right-half-plane-zero">Right-Half-Plane Zero</h3>
<p><span class="math display">\[
\left[(v_i - v_o)sC_c - g_m v_i\right]R_o = v_o
\]</span> Then <span class="math display">\[
\frac{v_o}{v_i} = -g_mR_o\frac{1-s\frac{C_c}{g_m}}{1+sR_oC_c}
\]</span> right-half-plane Zero <span class="math inline">\(\omega _z =
\frac{g_m}{C_c}\)</span></p>
<h3 id="equivalent-cap">Equivalent cap</h3>
<p>The amplifier gain magnitude <span class="math inline">\(A_v = g_m
R_o\)</span> <span class="math display">\[
I_\text{c,in} = (v_i - v_o)sC_c
\]</span> Then <span class="math display">\[\begin{align}
I_\text{c,in}  &amp;= (v_i + A_v v_i)sC_c \\
&amp; = v_i s (1+A_v)C_c
\end{align}\]</span></p>
<p>we get <span class="math inline">\(C_\text{in,eq}= (1+A_v)C_c\simeq
A_vC_c\)</span></p>
<p>Similarly <span class="math display">\[\begin{align}
I_\text{c,out}  &amp;= (v_o - v_i)sC_c \\
&amp; = v_o s (1+\frac{1}{A_v})C_c
\end{align}\]</span></p>
<p>we get <span class="math inline">\(C_\text{out,eq}=
(1+\frac{1}{A_v})C_c\simeq C_c\)</span></p>
<h2 id="ahuja-compensation">Ahuja compensation</h2>
<p><img src="/2024/01/16/ahuja/image-20240130233532624.png"
alt="image-20240130233532624" /></p>
<h3 id="right-half-plane-zero-1">Right-Half-Plane Zero</h3>
<p><span class="math display">\[
\left[(\alpha v_i - v_o)sC_c - g_m v_i\right]R_o = v_o
\]</span></p>
<p>where <span class="math inline">\(v_m = \alpha v_i\)</span> and <span
class="math inline">\(\alpha \ll 1\)</span></p>
<p>Then <span class="math display">\[
\frac{v_o}{v_i} = -g_mR_o\frac{1-s\frac{\alpha C_c}{g_m}}{1+sR_oC_c}
\]</span> right-half-plane Zero <span class="math inline">\(\omega _z =
\frac{g_m}{\alpha C_c} \gg \frac{g_m}{C_c}\)</span></p>
<blockquote>
<p>Ahuja compensation push right-half-plane Zero to higher frequency</p>
</blockquote>
<h3 id="equivalent-cap-1">Equivalent cap</h3>
<p>Then <span class="math display">\[\begin{align}
I_\text{c,in}  &amp;= (\alpha v_i + A_v v_i)sC_c \\
&amp; = v_i s (\alpha+A_v)C_c
\end{align}\]</span></p>
<p>we get <span class="math inline">\(C_\text{in,eq}=
(\alpha+A_v)C_c\simeq A_v C_c\)</span></p>
<p>Similarly <span class="math display">\[\begin{align}
I_\text{c,out}  &amp;= (v_o - \alpha v_i)sC_c \\
&amp; = v_o s (1+\frac{\alpha}{A_v})C_c
\end{align}\]</span></p>
<p>we get <span class="math inline">\(C_\text{out,eq}= (1+\frac{\alpha
}{A_v})C_c\simeq C_c\)</span></p>
<h2 id="reference">reference</h2>
<p>B. K. Ahuja, "An Improved Frequency Compensation Technique for CMOS
Operational Amplifiers," IEEE 1. Solid-State Circuits, vol. 18, no. 6,
pp. 629-633, Dec. 1983.</p>
<p>U. Dasgupta, "Issues in "Ahuja" frequency compensation technique",
IEEE International Symposium on Radio-Frequency Integration Technology,
2009.</p>
<p>R. 1. Reay and G. T. A. Kovacs, "An unconditionally stable two-stage
CMOS amplifier," IEEE 1. Solid-State Circuits, vol. 30, no. 5, pp. 591-
594, May 1995.</p>
<p>A. Garimella and P. M. Furth, "Frequency compensation techniques for
op-amps and LDOs: A tutorial overview," 2011 IEEE 54th International
Midwest Symposium on Circuits and Systems (MWSCAS), 2011, pp. 1-4, doi:
10.1109/MWSCAS.2011.6026315.</p>
<p>H. Aminzadeh, R. Lotfi and S. Rahimian, "Design Guidelines for
Two-Stage Cascode-Compensated Operational Amplifiers," 2006 13th IEEE
International Conference on Electronics, Circuits and Systems, 2006, pp.
264-267, doi: 10.1109/ICECS.2006.379776.</p>
<p>H. Aminzadeh and K. Mafinezhad, "On the power efficiency of cascode
compensation over Miller compensation in two-stage operational
amplifiers," Proceeding of the 13th international symposium on Low power
electronics and design (ISLPED '08), Bangalore, India, 2008, pp.
283-288, doi: 10.1145/1393921.1393995.</p>
<p>Stabilizing a 2-Stage Amplifier URL:<a
href="https://everynanocounts.com/2016/11/10/stabilizing-a-2-stage-amplifier/">https://everynanocounts.com/2016/11/10/stabilizing-a-2-stage-amplifier/</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Antenna Effect</title>
    <url>/2023/08/08/antenna/</url>
    <content><![CDATA[<p>The <strong>antenna effect</strong> is a common name for the effects
of <em>charge accumulation</em> in <em>isolated nodes</em> of an
integrated circuit <em>during its processing</em>.</p>
<blockquote>
<p>This effect is also sometimes called "Plasma Induced Damage",
"Process Induced Damage" (PID) or "charging effect".</p>
</blockquote>
<h2 id="antenna-ratio">antenna ratio</h2>
<p>The antenna rule specifies the maximum tolerance for the ratio of a
metal line area to the area of connected gates.</p>
<h2 id="metal-jumping">metal jumping</h2>
<p>Long metal can be taken to <em>higher metal</em> routing layer. This
is known as <strong>metal jumping</strong>.</p>
<blockquote>
<p>This metal jumping will break the long interconnect and hence the
charge collected on the long interconnect will not discharge through
gate oxide because the higher metal layer is not yet fabricated.</p>
</blockquote>
<blockquote>
<p>so, if the gate immediately connects to the highest level by jump-up
metals, large amount of charges can not be collected, while the poly
finally connected to the diffusion part by highest level, thus no
antenna violation will normally occure.</p>
</blockquote>
<h2 id="diode-insertion">Diode Insertion</h2>
<p>Diode helps dissipate charges accumulated on metal. Diode should be
placed as near as possible to the gate of device on low level of
metal.</p>
<blockquote>
<p>Diode should always be connected in <em>reverse bias</em>, with
cathode connected to gate electrode and anode connected to ground
potential.</p>
<p>During processing, even if the diodes are reversely biased, because
of the elevated wafer temperature (200 o C plus) it will provide a much
conductive path</p>
<p>In the reverse bias region, the reverse saturation current of Si and
Ge diodes doubles for every 10° C rise in temperature</p>
</blockquote>
<p><img
src="/2023/08/08/antenna/main-qimg-c3fe57dfac5fd5e5b5616ddf4f89f08a-pjlq.jpg"
alt="main-qimg-c3fe57dfac5fd5e5b5616ddf4f89f08a-pjlq" /></p>
<h2 id="reference">reference</h2>
<p>Tuvia Liran, Antenna effect (PID): Do the design rules really protect
us? [<a
href="https://www.eetimes.com/antenna-effect-do-the-design-rules-really-protect-us/">link</a>]</p>
<p>Upma Pawan Kumar, Sunandan Chaubey, Antenna Effect in 16nm Technology
Node [<a
href="https://www.design-reuse.com/articles/48227/antenna-effect-in-16nm-technology-node.html">link</a>]</p>
<p>pulsic.com, Analog layout – Stop the antenna effect from destroying
your circuit [<a
href="https://pulsic.com/analog-layout-stop-the-antenna-effect-from-destroying-your-circuit/">link</a>]</p>
<p>BuBuChen, 積體電路的天線效應 (Antenna Effect in IC) [<a
href="https://www.bubuchen.com/2020/04/Antenna-Effect.html">link</a>]</p>
<p>EDN, Antenna violations resolved using new method [<a
href="https://www.edn.com/antenna-violations-resolved-using-new-method/">link</a>]</p>
<p>edaboard.com, why jump up metal can solve the antenna effect? [<a
href="https://www.edaboard.com/threads/why-jump-up-metal-can-solve-the-antenna-effect.177890/post-745696">link</a>]</p>
<p>siliconvlsi.com, Antenna effect [<a
href="https://siliconvlsi.com/antenna-effect/">link</a>]</p>
<p>Prof. Adam Teman, Digital VLSI Design.
Lecture-10-The-Manufacturing-Process [<a
href="https://www.eng.biu.ac.il/temanad/files/2017/02/Lecture-10-The-Manufacturing-Process.pdf">pdf</a>]</p>
<p>Zongjian Chen, Processing and Reliability Issues That Impact Design
Practice. [<a
href="https://web.stanford.edu/class/archive/ee/ee371/ee371.1066/lectures/Old/lect_15_2up.pdf">https://web.stanford.edu/class/archive/ee/ee371/ee371.1066/lectures/Old/lect_15_2up.pdf</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Arithmetic in Verilog</title>
    <url>/2022/05/29/arthmetic-verilog/</url>
    <content><![CDATA[<h4 id="unsigned-unsigned-unsigned">unsigned + unsigned = unsigned</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">7</span>:<span class="number">0</span>] satadd_uuu8b;   <span class="comment">// unsigned + unsigned = unsigned</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] t;   <span class="comment">// extend 1b</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        t = &#123;<span class="number">1&#x27;b0</span>, a&#125; + &#123;<span class="number">1&#x27;b0</span>, b&#125;;</span><br><span class="line">        satop_uuu16b = t[<span class="number">8</span>] ? &#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125; : t[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>1'b1</code>: overflow</p>
</blockquote>
<h4 id="signed-signed-signed">signed + signed = signed</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">7</span>:<span class="number">0</span>] satadd_sss8b;    <span class="comment">// signed + signed = signed</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span>    [<span class="number">7</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span>    [<span class="number">7</span>:<span class="number">0</span>] b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] t; <span class="comment">// extend 1b</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        t = a + b;  <span class="comment">// extend sign bit automatically</span></span><br><span class="line">        satadd_sss8b =  (t[<span class="number">8</span>:<span class="number">7</span>] == <span class="number">2&#x27;b01</span>) ? &#123;<span class="number">1&#x27;b0</span>, <span class="number">7</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125; : <span class="comment">// up sat</span></span><br><span class="line">                        (t[<span class="number">8</span>:<span class="number">7</span>] == <span class="number">2&#x27;b10</span>) ? &#123;<span class="number">1&#x27;b1</span>, <span class="number">7</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125; : <span class="comment">// dn sat</span></span><br><span class="line">                                            t[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>2'b01</code>: overflow</p>
<p><code>2'b10</code>: underflow</p>
</blockquote>
<h4 id="signed-unsigned-unsigned">signed + unsigned = unsigned</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">7</span>:<span class="number">0</span>] satadd_suu8b;    <span class="comment">// signed + unsigned = unsigned</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span>    [<span class="number">7</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">input</span>           [<span class="number">7</span>:<span class="number">0</span>] b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] t; <span class="comment">// extend 1b</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        t = &#123;a[<span class="number">7</span>], a&#125; + &#123;<span class="number">1&#x27;b0</span>, b&#125;;</span><br><span class="line">        satadd_ssu8b =  (t[<span class="number">8</span>:<span class="number">7</span>] == <span class="number">2&#x27;b10</span>) ? &#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125; : <span class="comment">// up saturate for unsigned</span></span><br><span class="line">                        (t[<span class="number">8</span>:<span class="number">7</span>] == <span class="number">2&#x27;b11</span>) ? &#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125; : <span class="comment">// dn saturate for unsigned</span></span><br><span class="line">                                            t[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h4 id="signed-unsigned-signed">signed + unsigned = signed</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] satop_sus8b;    <span class="comment">//signed +/- unsigned = signed</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span>    [<span class="number">7</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">input</span>           [<span class="number">7</span>:<span class="number">0</span>] b;</span><br><span class="line">    <span class="keyword">input</span> plus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] t;    <span class="comment">// extend 1b</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(plus) <span class="keyword">begin</span></span><br><span class="line">            t = &#123;a[<span class="number">7</span>], a&#125; + &#123;<span class="number">1&#x27;b0</span>, b&#125;;</span><br><span class="line">            satop_sus8b = (t[<span class="number">8</span>:<span class="number">7</span>]==<span class="number">2&#x27;b01</span>) ? &#123;<span class="number">1&#x27;b0</span>, &#123;<span class="number">7</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;&#125;   <span class="comment">// up saturate for signed</span></span><br><span class="line">                                             : t[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            t = &#123;a[<span class="number">7</span>], a&#125; - &#123;<span class="number">1&#x27;b0</span>, b&#125;;</span><br><span class="line">            satop_sus8b = (t[<span class="number">8</span>:<span class="number">7</span>]==<span class="number">2&#x27;b10</span>) ? &#123;<span class="number">1&#x27;b1</span>, &#123;<span class="number">7</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;&#125;   <span class="comment">// dn saturate for signed</span></span><br><span class="line">                                             : t[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Bandgap Reference</title>
    <url>/2022/11/17/bgr/</url>
    <content><![CDATA[<h3 id="temperature-coefficient">temperature coefficient</h3>
<p>The parameter that shows the dependence of the reference voltage on
temperature variation is called the temperature coefficient and is
defined as: <span class="math display">\[
TC_F=\frac{1}{V_{\text{REF}}}\left[
\frac{V_{\text{max}}-V_{\text{min}}}{T_{\text{max}}-T_{\text{min}}}
\right]\times10^6\;ppm/^oC
\]</span></p>
<h3 id="choice-of-n">Choice of n</h3>
<p><img src="/2022/11/17/bgr/image-20221117002714125.png"
alt="image-20221117002714125" /></p>
<h3 id="reference">reference</h3>
<p>ECEN 607 (ESS) Bandgap Reference: Basics URL:<a
href="https://people.engr.tamu.edu/s-sanchez/607%20Lect%204%20Bandgap-2009.pdf">https://people.engr.tamu.edu/s-sanchez/607%20Lect%204%20Bandgap-2009.pdf</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>How to obtain channel bandwidth from pulse response</title>
    <url>/2022/05/20/bw-from-pulse-resp/</url>
    <content><![CDATA[<p>Convolution Property of the Fourier Transform <span
class="math display">\[
x(t)*h(t)\longleftrightarrow  X(\omega)H(\omega)
\]</span> pulse response can be obtained by convolve impulse response
with UI length rectangular <span class="math display">\[
H(\omega) = \frac{Y_{\text{pulse}}(\omega)}{X_{\text{rect}}(\omega)} =
\frac{Y_{\text{pulse}}(\omega)}{\text{sinc}(\omega)}
\]</span></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Convolution Property of the Fourier Transform</span></span><br><span class="line"><span class="comment">% pulse(t) = h(t) * rect(t)</span></span><br><span class="line"><span class="comment">% -&gt; fourier transform</span></span><br><span class="line"><span class="comment">% PULSE = H * RECT</span></span><br><span class="line"><span class="comment">% FT(RECT) = sinc</span></span><br><span class="line"><span class="comment">% H = PULSE/RECT = PULSE/sinc</span></span><br><span class="line">xx = <span class="built_in">pi</span>*ui.*w(<span class="number">1</span>:plt_num);</span><br><span class="line">y_sinc = ui.*<span class="built_in">sin</span>(xx)./xx;</span><br><span class="line">y_sinc(<span class="number">1</span>) = y_sinc(<span class="number">2</span>);</span><br><span class="line">y_sinc = y_sinc/y_sinc(<span class="number">1</span>);  <span class="comment">% we dont care the absoulte gain</span></span><br><span class="line">h_ban1 = <span class="built_in">abs</span>(h(<span class="number">1</span>:plt_num))./<span class="built_in">abs</span>(y_sinc);</span><br><span class="line"></span><br><span class="line">h_dB = <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(h_ban1));</span><br><span class="line">[hmin, Index] = <span class="built_in">min</span>(<span class="built_in">abs</span>(h_dB +<span class="number">3</span> ));</span><br><span class="line">f_3dB = w(Index);</span><br><span class="line">f_3dB = f_3dB/<span class="number">1e9</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/20/bw-from-pulse-resp/image-20220520223115184.png"
alt="image-20220520223115184" /></p>
<p><img src="/2022/05/20/bw-from-pulse-resp/image-20220520223621924.png"
alt="image-20220520223621924" /></p>
<h2 id="sinc-function">sinc function</h2>
<p>Notice that the complete definition of <span
class="math inline">\(\operatorname{sinc}\)</span> on <span
class="math inline">\(\mathbb R\)</span> is <span
class="math display">\[
\operatorname{Sa}(x)=\operatorname{sinc}(x) = \begin{cases} \frac{\sin
x}{x} &amp; x\ne 0, \\ 1, &amp; x = 0, \end{cases}
\]</span> which is <strong>continuous</strong>.</p>
<p><img src="/2022/05/20/bw-from-pulse-resp/image-20220521112425477.png"
alt="image-20220521112425477" /></p>
<p><img src="/2022/05/20/bw-from-pulse-resp/image-20220521112722838.png"
alt="image-20220521112722838" /></p>
<p>To approach to real spectrum of continuous rectangular waveform,
<span class="math inline">\(\text{NFFT}\)</span> has to be big
enough.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">500</span>; <span class="comment">%sampling frequency</span></span><br><span class="line">Ts = <span class="number">1</span>/fs;</span><br><span class="line">T=<span class="number">0.2</span>; <span class="comment">%width of the rectangule pulse in seconds</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">t=<span class="number">-0.5</span>:<span class="number">1</span>/fs:<span class="number">0.5</span>; <span class="comment">%time base</span></span><br><span class="line">x=rectpuls(t,T); <span class="comment">%generating the square wave</span></span><br><span class="line">sum(x&gt;<span class="number">0.5</span>)</span><br><span class="line">stem(t,x,<span class="string">&#x27;--k&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, x, <span class="string">&#x27;b.-&#x27;</span>)</span><br><span class="line">xstart = T/<span class="number">2</span>-Ts/<span class="number">2</span>;</span><br><span class="line">xend = -T/<span class="number">2</span>-Ts/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>([xstart, xstart], [<span class="number">-1</span>, <span class="number">1.02</span>], <span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>([xend, xend], [<span class="number">-1</span>, <span class="number">1.02</span>], <span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-0.11</span>, <span class="number">0.11</span>], [<span class="number">1</span>, <span class="number">1</span>], <span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">grid on;</span><br><span class="line">title([<span class="string">&#x27;Rectangular Pulse width=&#x27;</span>, num2str(T),<span class="string">&#x27;s&#x27;</span>]);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-0.12</span>, <span class="number">0.12</span>]);</span><br><span class="line">ylim([<span class="number">-0.05</span>, <span class="number">1.05</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">Titer = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>];</span><br><span class="line">color = &#123;<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">formatSpec = <span class="string">&#x27;NFFT=%d&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">length</span>(Titer)</span><br><span class="line">    t=-Titer(k):Ts:Titer(k); <span class="comment">%time base</span></span><br><span class="line">    x=rectpuls(t,T); <span class="comment">%generating the square wave</span></span><br><span class="line"></span><br><span class="line">    L=<span class="built_in">length</span>(x);</span><br><span class="line">    Np = <span class="built_in">nextpow2</span>(L)<span class="number">-1</span>;</span><br><span class="line">    NFFT = <span class="number">2</span>^Np;</span><br><span class="line">    X = fftshift(fft(x,NFFT)); <span class="comment">%FFT with FFTshift for both negative &amp; positive frequencies</span></span><br><span class="line">    f = fs*(-NFFT/<span class="number">2</span>:NFFT/<span class="number">2</span><span class="number">-1</span>)/NFFT; <span class="comment">%Frequency Vector</span></span><br><span class="line">    Xc = <span class="built_in">abs</span>(X)*Ts; <span class="comment">% continuous signal spectrum</span></span><br><span class="line">    <span class="built_in">plot</span>(f, Xc, <span class="string">&quot;Color&quot;</span>,color&#123;k&#125;, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">    legend_str&#123;k&#125; = [num2str(NFFT, formatSpec)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"><span class="built_in">legend</span>(legend_str);</span><br><span class="line">title(<span class="string">&#x27;Magnitude of X_c (original continuous signal)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Magnitude |X(f)|&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong></p>
<p>L.W. Couch, <em>Digital and Analog Communication</em>
<em>Systems</em>, 8th Edition, Pearson, 2013.</p>
<p><a
href="https://www.gaussianwaves.com/2014/07/generating-basic-signals-rectangule-pulse-and-power-spectral-density-using-fft/">Generating
Basic signals – Rectangular Pulse and Power Spectral Density using
FFT</a></p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Calibre Runsets</title>
    <url>/2023/08/10/calibreRunsets/</url>
    <content><![CDATA[<p>Calibre Interactive stores a list of your most recently opened
runsets in your <em>home directory</em> as <code>.cgidrcdb</code> or
<code>.cgilvsdb</code> for Calibre Interactive DRC or LVS,
respectively.</p>
<p>When invoked, the Calibre DRC and LVS windows automatically load the
runset used when the last session was closed.</p>
<blockquote>
<p>Runsets are ASCII files that set up Calibre Interactive for a Calibre
run. They contain only information that differs from the default
configuration of Calibre Interactive. There is a one-to-one
correspondence between entry lines in the runset file and fields and
button items in the Calibre Interactive user interface. Here is as
example of a DRC runset:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*drcRulesFile: rule_file</span><br><span class="line">*drcRulesFileLastLoad: 1009224452</span><br><span class="line">*drcLayoutPaths: ./lab3.gds</span><br><span class="line">*drcLayoutPrimary: lab3</span><br><span class="line">*drcResultsFile: ./lab3.db</span><br><span class="line">*drcSummaryFile: drc_report</span><br><span class="line">*drcRunTurbo: 0</span><br><span class="line">*drcRunRemoteOn: Cluster</span><br><span class="line">*drcRemoteLICENSEFILEName: MGLS_LICENSE_FILE</span><br><span class="line">*drcRemoteLICENSEFILEValue: /scratch1/mgls/mgclicenses</span><br><span class="line">*drcDontWaitForLicense: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<p>The runset filename opened at startup (if no runset is specified on
the command line) can also be specified by setting the
<code>MGC_CALIBRE_DRC_RUNSET_FILE</code> environment variable for DRC,
and the <code>MGC_CALIBRE_LVS_RUNSET_FILE</code> environment variable
for LVS. If these environment variables are set, they take precedence
over all other runset opening behavior options.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv RUNSET_DIR ../calibre</span><br><span class="line">setenv MGC_CALIBRE_DRC_RUNSET_FILE $RUNSET_DIR/tsmc180nm_drc_runset</span><br><span class="line">setenv MGC_CALIBRE_LVS_RUNSET_FILE $RUNSET_DIR/tsmc180nm_lvs_runset</span><br><span class="line">setenv MGC_CALIBRE_PEX_RUNSET_FILE $RUNSET_DIR/tsmc180nm_pex_runset</span><br><span class="line">setenv CALIBRE_DISABLE_RHEL5_WARNING 1</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>tsmc_template. <a
href="https://github.com/lnis-uofu/tsmc_template/tree/main">https://github.com/lnis-uofu/tsmc_template/tree/main</a></p>
<p>Calibre Verification User’s Manual</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>Linear model of the CDR</title>
    <url>/2022/05/04/cdr-linear/</url>
    <content><![CDATA[<p><img src="/2022/05/04/cdr-linear/image-20220504101924272.png"
alt="image-20220504101924272" /></p>
<blockquote>
<p>condition:</p>
<p>Linear model of the CDR is used in a <strong>frequency lock
condition</strong> and is approaching to achieve <strong>phase
lock</strong></p>
</blockquote>
<p>Using this model, the power spectral density (PSD) of jitter in the
recovered clock <span class="math inline">\(S_{out}(f)\)</span> is <span
class="math display">\[
S_{out}(f)=|H_T(f)|^2S_{in}(f)+|H_G(f)|^2S_{VCO}(f)
\]</span> Here, we assume <span
class="math inline">\(\varphi_{in}\)</span> and <span
class="math inline">\(\varphi_{VCO}\)</span> are uncorrelated as they
come from independent sources.</p>
<h2 id="jitter-transfer">Jitter Transfer</h2>
<p><span class="math display">\[
H_T(s) =
\frac{\varphi_{out}(s)}{\varphi_{in}(s)}|_{\varphi_{vco}=0}=\frac{K_{PD}K_{VCO}R_s+\frac{K_{PD}K_{VCO}}{C}}{s^2+K_{PD}K_{VCO}R_s+\frac{K_{PD}K_{VCO}}{C}}
\]</span></p>
<p>Using below notation <span class="math display">\[\begin{align}
\omega_n^2=\frac{K_{PD}K_{VCO}}{C} \\
\xi=\frac{K_{PD}K_{VCO}}{2\omega_n^2}
\end{align}\]</span></p>
<p>We can rewrite transfer function as follows <span
class="math display">\[
H_T(s)=\frac{2\xi\omega_n s+\omega_n^2}{s^2+2\xi \omega_n s+\omega_n^2}
\]</span></p>
<blockquote>
<p>The jitter transfer represents a <strong>low-pass filter</strong>
whose magnitude is around 1 (0 dB) for low jitter frequencies and drops
at 20 db/decade for frequencies above <span
class="math inline">\(\omega_n\)</span></p>
</blockquote>
<p><img src="/2022/05/04/cdr-linear/image-20220504104202197.png"
alt="image-20220504104202197" /></p>
<ul>
<li>the recovered clock <strong>track</strong> the <em>low-frequency
jitter</em> of the input data</li>
<li>the recovered clock <strong>DONT</strong> track the
<em>high-frequency jitter</em> of the input data</li>
</ul>
<p>The recovered clock does not suffer from high-frequency jitter even
though the input signal may contain high-frequency jitter, which will
limit the CDR tolerance to high-frequency jitter.</p>
<h2 id="jitter-peaking-in-jitter-transfer-function">Jitter Peaking in
Jitter Transfer Function</h2>
<p>The peak, slightly larger than 1 (0dB) implies that jitter will be
<strong>amplified</strong> at some frequencies in the CDR, producing a
jitter amplitude in the recovered clock, and thus also in the recovered
data, that is slightly <strong>larger</strong> than the jitter amplitude
in the input data.</p>
<p>This is certainly undesirable, especially in applications such as
repeaters.</p>
<p><img src="/2022/05/04/cdr-linear/image-20220504110722442.png"
alt="image-20220504110722442" /></p>
<h2 id="jitter-generation">Jitter Generation</h2>
<p>If the input data to the CDR is clean with no jitter, i.e., <span
class="math inline">\(\varphi_{in}=0\)</span>, the jitter of the
recovered clock comes directly from the VCO jitter. The transfer
function that relates the VCO jitter to the recovered clock jitter is
known as <strong>jitter generation</strong>. <span
class="math display">\[
H_G(s)=\frac{\varphi_{out}}{\varphi_{VCO}}|_{\varphi_{in}=0}=\frac{s^2}{s^2+2\xi
\omega_n s+\omega_n^2}
\]</span> Jitter generation is <strong>high-pass filter</strong> with
two zeros, at zero frequency, and two poles identical to those of the
jitter transfer function</p>
<p><img src="/2022/05/04/cdr-linear/image-20220504110737718.png"
alt="image-20220504110737718" /></p>
<h2 id="jitter-tolerance">Jitter Tolerance</h2>
<p>To quantify jitter tolerance, we often apply a sinusoidal jitter of a
fixed frequency to the CDR input data and observe the BER of the CDR</p>
<p>The jitter tolerance curve <strong>DONT</strong> capture a CDR's true
tolerance to <strong>random</strong> jitter. Because we are applying
"sinusoidal" jitter, which is <strong>deterministic</strong> signal.</p>
<p>We can deal only with the jitter's amplitude and frequency instead of
the PSD of the jitter thanks to deterministic sinusoidal jitter signal.
<span class="math display">\[
JTOL(f) = \left | \varphi_{in}(f)  \right |_{\text{pp-max}} \quad
\text{for a fixed BER}
\]</span> Where the subscript <span
class="math inline">\(\text{pp-max}\)</span> indicates the maximum
peak-to-peak amplitude. We can further expand this equation as follows
<span class="math display">\[
JTOL(f)=\left| \frac{\varphi_{in}(f)}{\varphi_{e}(f)} \right| \cdot
|\varphi_e(f)|_{pp-max}
\]</span> <img src="/2022/05/04/cdr-linear/image-20220504114650749.png"
alt="image-20220504114650749" /></p>
<blockquote>
<p>Relative jitter, <span class="math inline">\(\varphi_e\)</span> must
be less than 1UIpp for error-free operation</p>
</blockquote>
<p>In an ideal CDR, the <strong>maximum peak-to-peak amplitude</strong>
of <span class="math inline">\(|\varphi_e(f)|\)</span> is
<strong>1UI</strong>, i.e.,<span
class="math inline">\(|\varphi_e(f)|_{pp-max}=1UI\)</span></p>
<p>Accordingly, jitter tolerance can be expressed in terms of the number
of UIs as <span class="math display">\[
JTOL(f)=\left| \frac{\varphi_{in}(f)}{\varphi_{e}(f)} \right|\quad
\text{[UI]}
\]</span> Given the linear CDR model, we can write <span
class="math display">\[
JTOL(f)=\left| 1+\frac{K_{PD}K_{VCO}H_{LF}(f)}{j2\pi f} \right|\quad
\text{[UI]}
\]</span> Expand <span class="math inline">\(H_{LF}(f)\)</span> for the
CDR, we can write <span class="math display">\[
JTOL(f)=\left| 1-2\xi j \left(\frac{f_n}{f}\right) -
\left(\frac{f_n}{f}\right)^2 \right|\quad \text{[UI]}
\]</span> <img src="/2022/05/04/cdr-linear/image-20220504120538534.png"
alt="image-20220504120538534" /></p>
<p>At frequencies far below and above the natural frequency, the jitter
tolerance can be approximated by the following <span
class="math display">\[
JTOL(f) = \left\{ \begin{array}{cl}
\left(\frac{f_n}{f}\right)^2 &amp; : \ f\ll f_n \\
1 &amp; : \ f\gg f_n
\end{array} \right.
\]</span></p>
<ul>
<li>the jitter tolerance at very <strong>high jitter
frequencies</strong> is limited to <strong>1UIpp</strong>
<ul>
<li>This is consistent with that the recovered clock does not track the
high-frequency jitter, limiting the maximum peak-to-peak deviation of
the data edge from its nominal position to 1UI</li>
<li>The circumstance, (b) jittery data with ideal clock</li>
</ul></li>
<li>the jitter tolerance is increased at 40dB/decade for jitter
frequencies below <span class="math inline">\(f_c\)</span>
<ul>
<li>This is consistent with our obervation earlier that the recovered
clock better tracks data jitter at lower jitter frequencies</li>
<li>Equivalently, the data edge and the clock edge move together in the
<strong>same direction</strong>. As a result, the relative jitter
between the data and the clock remains small, i.e., below 1UI
peak-to-peak</li>
<li>The circumstance, (c) jittery data and jittery clock</li>
</ul></li>
</ul>
<h2 id="ojtf">OJTF</h2>
<h3 id="concepts-of-jtf-and-ojtf">Concepts of JTF and OJTF</h3>
<p>Simplified Block Diagram of a Clock-Recovery PLL <img
src="/2022/05/04/cdr-linear/pll_block_diagram.gif"
alt="pll_block_diagram" /></p>
<p><strong>Jitter Transfer Function (JTF)</strong></p>
<ul>
<li>Input Signal Versus Recovered Clock</li>
<li>JTF, by jitter frequency, compares how much input signal jitter is
transferred to the <strong>output of a clock-recovery's PLL (recovered
clock)</strong>
<ul>
<li>Input signal jitter that is within the clock recovery PLL's loop
bandwidth results in jitter that is faithfully transferred (closed-loop
gain) to the clock recovery PLL's output signal. JTF in this situation
is approximately 1.</li>
<li>Input signal jitter that is outside the clock recovery PLL's loop
bandwidth results in decreasing jitter (open-loop gain) on the clock
recovery PLL's output, because the jitter is filtered out and no longer
reaches the PLL's VCO</li>
</ul></li>
</ul>
<p><strong>Observed Jitter Transfer Function</strong></p>
<ul>
<li>Input Signal Versus Sampled Signal</li>
<li>OJTF compares how much input signal jitter is transferred to the
<strong>output of a receiver's decision making circuit</strong> as
effected by a clock recovery's PLL. As the recovered clock is the
reference for detecting the input signal
<ul>
<li>Input signal jitter that is <strong>within</strong> the clock
recovery PLL's loop bandwidth results in jitter on the recovered clock
which reduces the amount of jitter that can be detected. The input
signal and clock signal are closer in phase</li>
<li>Input signal jitter that is <strong>outside</strong> the clock
recovery PLL's loop bandwidth results in <strong>reduced jitter on the
recovered cloc</strong>k which increases the amount of jitter that can
be detected. The input signal and clock signal are more out of phase.
Jitter that is on both the input and clock signals can not detected or
is reduced</li>
</ul></li>
</ul>
<p>JTF and OJTF for 1st Order PLLs</p>
<p><img src="/2022/05/04/cdr-linear/jsa_1st_order_graph.png"
alt="jsa_1st_order_graph" /></p>
<p><img src="/2022/05/04/cdr-linear/neuhelium-jtf-ojtf.png"
alt="neuhelium-jtf-ojtf" /></p>
<blockquote>
<p>The observed jitter is a complement to the PLL jitter transfer
response OJTF=1-JTF <strong>(Phase matters!)</strong></p>
<p>OTJF gives the amount of jitter which is tracked and therefore not
observed at the output of the CDR as a function of the jitter rate
applied to the input.</p>
</blockquote>
<p><img src="/2022/05/04/cdr-linear/A-jtf-ojtf.png"
alt="A-jtf-ojtf" /></p>
<h3 id="jitter-measurement">Jitter Measurement</h3>
<p><span class="math display">\[
J_{\text{measured}} = JTF_{\text{DUT}} \cdot OJTF_{\text{instrument}}
\]</span> The combination of the OJTF of a jitter measurement device and
the JTF of the clock generator under test gives the measured jitter as a
function of frequency.</p>
<p><img src="/2022/05/04/cdr-linear/image-20220716094732273.png"
alt="image-20220716094732273" /></p>
<p>For example, a clock generator with a type 1, 1st order PLL measured
with a jitter measurement device employing a golden PLL is <span
class="math display">\[
J_{\text{measured}} = \frac{\omega_1}{s+\omega_1}\frac{s}{s+\omega_2}
\]</span></p>
<p>Accurate measurement of the clock JTF requires that the OJTF cutoff
of the jitter measurement be significantly below that of the clock JTF
and that the measurement is compensated for the instrument's OJTF.</p>
<p>The overall response is a band pass filter because the clock JTF is
low pass and the jitter measurement device OJTF is high pass.</p>
<p>The compensation for the instrument OJTF is performed by measuring
the jitter of the reference clock at each jitter rate being tested and
comparing the <strong>reference jitter</strong> with the <strong>jitter
measured at the output of the DUT</strong>.</p>
<p><img src="/2022/05/04/cdr-linear/jit_resp.png" alt="jtf-ojtf" /></p>
<p>The lower the cutoff frequency of the jitter measurement device the
better the accuracy of the measurement will be.</p>
<p>The cutoff frequency is limited by several factors including the
phase noise of the DUT and measurement time.</p>
<h3 id="digital-sampling-oscilloscope">Digital Sampling
Oscilloscope</h3>
<p>How to analyze jitter:</p>
<ul>
<li>TIE (Time Interval Error) track</li>
<li>histogram</li>
<li>FFT</li>
</ul>
<p><strong>TIE track</strong> provides a direct view of how the phase of
the clock evolves over time.</p>
<p><strong>histogram</strong> provides valuable information about the
long term variations in the timing.</p>
<p><strong>FFT</strong> allows jitter at specific rates to be measured
down to the femto-second range.</p>
<blockquote>
<p>Maintaining the record length at a minimum of <span
class="math inline">\(1/10\)</span> of the inverse of the PLL loop
bandwidth minimizes the response error</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Dalt, Nicola Da and Ali Sheikholeslami. “Understanding Jitter and
Phase Noise: A Circuits and Systems Perspective.” (2018).</p>
<p>neuhelium, 抖动、眼图和高速数字链路分析基础 URL: <a
href="http://www.neuhelium.com/ueditor/net/upload/file/20200826/DSOS254A/03.pdf">http://www.neuhelium.com/ueditor/net/upload/file/20200826/DSOS254A/03.pdf</a></p>
<p>Keysight JTF &amp; OJTF Concepts, <a
href="https://rfmw.em.keysight.com/DigitalPhotonics/flexdca/FlexPLL-UG/Content/Topics/Quick-Start/jtf-pll-theory.htm?TocPath=Quick%20Start%7C_____4">https://rfmw.em.keysight.com/DigitalPhotonics/flexdca/FlexPLL-UG/Content/Topics/Quick-Start/jtf-pll-theory.htm?TocPath=Quick%20Start%7C_____4</a></p>
<p>Complementary Transmitter and Receiver Jitter Test Methodlogy, URL:
<a
href="https://www.ieee802.org/3/bm/public/mar14/ghiasi_01_0314_optx.pdf">https://www.ieee802.org/3/bm/public/mar14/ghiasi_01_0314_optx.pdf</a></p>
<p>SerDesDesign.com CDR_BangBang_Model URL: <a
href="https://www.serdesdesign.com/home/web_documents/models/CDR_BangBang_Model.pdf">https://www.serdesdesign.com/home/web_documents/models/CDR_BangBang_Model.pdf</a></p>
<p>M. Schnecker, Jitter Transfer Measurement in Clock Circuits, LeCroy
Corporation, DesignCon 2009. URL: <a
href="http://cdn.teledynelecroy.com/files/whitepapers/designcon2009_lecroy_jitter_transfer_measurement_in_clock_circuits.pdf">http://cdn.teledynelecroy.com/files/whitepapers/designcon2009_lecroy_jitter_transfer_measurement_in_clock_circuits.pdf</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>channel and termination</title>
    <url>/2022/07/01/channel-termination/</url>
    <content><![CDATA[<h2 id="voltage-mode-driver">voltage mode driver</h2>
<p><img src="/2022/07/01/channel-termination/voltagemode20220704.PNG"
alt="voltagemode20220704" /></p>
<h2 id="current-mode-driver">current mode driver</h2>
<p><img
src="/2022/07/01/channel-termination/image-20220702003926289.png"
alt="image-20220702003926289" /></p>
<h2 id="reference">reference</h2>
<p>Byungsub Kim, 2022 IEEE International Solid-State Circuits
Conference, "T11: Basics of Equalization Techniques: Channels,
Equalization, and Circuits"</p>
<p>Minsoo Choi et al., “An Approximate Closed-Form Channel Model for
Diverse Interconnect Applications,” IEEE Transactions on Circuits and
Systems-I: Regular Papers, vol. 61, no. 10, pp. 3034-3043, Oct.
2014.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Clock Edges used for Setup and Hold in PrimeTime</title>
    <url>/2022/03/01/clock-edges-used-for-setup-and-hold-primetime/</url>
    <content><![CDATA[<p>PT picks the most restrictive pair of edges for setup and for hold.
It determines which edges to be used as follows:</p>
<ol type="1">
<li><p>Evaluate waveforms over the smallest common base period</p></li>
<li><p>For each capture edge, find the closest setup launch edge. Call
these the <strong>primary pairs</strong></p></li>
<li><p>Out of the <strong>primary pairs</strong>, pick the most
restrictive setup launch and capture edges.</p></li>
<li><p>For each <strong>primary pair</strong>, draw two hold
relationships:</p>
<ul>
<li><p>Launch to (capture - 1)</p></li>
<li><p>(Launch + 1) to Capture</p>
<p>From all of these hold relationships, pick the most
restrictive.</p></li>
</ul></li>
</ol>
<p>PrimeTime uses the ideal clock waveform (as reported in
<code>report_clock</code>) to determine the appropriate clock edges for
inter-clock analysis.</p>
<p><img
src="/2022/03/01/clock-edges-used-for-setup-and-hold-primetime/image-20220301203135490.png"
alt="image-20220301203135490" /></p>
<blockquote>
<p>The most restrictive setup pair is from Clk1 8ns to Clk2 9ns</p>
<p>The most restrictive hold pair is from Clk1 0ns to Clk2 0ns</p>
</blockquote>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Clock Gating</title>
    <url>/2023/04/05/clockgating/</url>
    <content><![CDATA[<p><strong>Clock Gating</strong> is defined as: "Clock gating is a
technique/methodology to turn off the clock to certain parts of the
digital design when not needed".</p>
<h3 id="clock-gating-overview">Clock Gating Overview</h3>
<h4 id="and-gate-based-clock-gating">AND gate-based clock gating</h4>
<p>In <em>simplest form</em> a clock gating can be achieved by using an
<em>AND gate</em> as shown in picture below</p>
<p><img src="/2023/04/05/clockgating/AND-gate-based-clock-gating.png"
alt="clock gating" /></p>
<p>However, this simplest form of clock gating technique has some
problem of generating <strong>glitches</strong> in the clock provide to
the FF, which are not desirable.</p>
<p><img src="/2023/04/05/clockgating/Glitches-in-enable-gated-clock.png"
alt="img" /></p>
<blockquote>
<p>Glitches in enable/gated clock</p>
</blockquote>
<h4 id="latch-based-clock-gating">Latch based clock gating</h4>
<p>These glitches can be removed by introducing a negative edge
triggered FF (assuming downstream FFs are positive edge) or low-level
sensitive latch at the output of the clock enable signal.</p>
<p><img src="/2023/04/05/clockgating/Latch-based-clock-gating.png"
alt="clock gating" /></p>
<p>This will make sure that any glitch in the clock enable signal will
not be visible to the gated clock output. The Latch output will only be
updated during the negative clock cycle and thus input to AND gate will
be stable high.</p>
<p><img src="/2023/04/05/clockgating/Glitch-Free-Gated-Clock.png"
alt="clock gating" /></p>
<blockquote>
<p>Glitch Free Gated Clock</p>
</blockquote>
<h3 id="reference">reference</h3>
<p>The Ultimate Guide to Clock Gating <a
href="https://anysilicon.com/the-ultimate-guide-to-clock-gating/">https://anysilicon.com/the-ultimate-guide-to-clock-gating/</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>primary clock, generated clock and virtual clock in SDC</title>
    <url>/2022/03/01/clocks-sta/</url>
    <content><![CDATA[<p><strong>primary clocks</strong></p>
<ul>
<li>Primary clocks should be created at input ports and output pins of
black boxes.</li>
<li>Never create clocks on hierarchy pins. Creating clocks on hierarchy
will cause problems when reading SDF. The net timing arc becomes
segmented at the hierarchy and PrimeTime will be unable to annotate the
net successfully.</li>
</ul>
<p><strong>generated clocks</strong></p>
<ul>
<li>Generated clocks are generally created for waveform modifications of
a primary clock (not including simple inversions). PrimeTime does not
simulate a design and thus will <strong>not</strong> derive internally
generated clocks automatically - these clocks must be created by the
user and applied as a constraint.</li>
<li>PrimeTime caculate source latency for generated clocks if primary
clock is <strong>propagated</strong>, otherwise its source latency is
zero.</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># primary clock</span></span><br><span class="line">create_clock -period <span class="number">4</span> [get_ports Clk]</span><br><span class="line">set_clock_latency -<span class="keyword">source</span> <span class="number">2</span> [get_clocks Clk]</span><br><span class="line">set_propagated_clock [get_clocks Clk]</span><br><span class="line">create_generated_clock -divide_by <span class="number">2</span> -name div_clk -<span class="keyword">source</span> [get_ports Clk] FF3/Q</span><br></pre></td></tr></table></figure>
<p><strong>virtual clocks</strong></p>
<ul>
<li>Are clock objects without a source</li>
<li>Do not clock sequential devices within the current_design</li>
<li>Serve as references of input or output delays</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create a virtual clock, vclk, for input and output delay constraints</span></span><br><span class="line">create_clock -period <span class="number">5</span> -name vclk</span><br><span class="line">set_input_delay -max <span class="number">2</span> -<span class="keyword">clock</span> vclk [get_ports in1]</span><br><span class="line">set_output_delay -max <span class="number">1</span> -<span class="keyword">clock</span> vclk [get_ports out2]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>There is <strong>no</strong> network latency to calculate, even if a
virtual clock is propagated.</p>
</blockquote>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>complex uvm project topology</title>
    <url>/2022/03/28/complex-uvm-topo/</url>
    <content><![CDATA[<p><img src="/2022/03/28/complex-uvm-topo/topo.drawio.svg"
alt="topo.drawio" /></p>
<h2 id="compile">compile</h2>
<ul>
<li><code>-incdir</code> for all UVC's `<code>include</code></li>
<li>all pkg.sv</li>
<li>all if.sv</li>
<li>all RTL DUT</li>
<li>uvm top module</li>
</ul>
<h2 id="uvm-top.sv">uvm top.sv</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// import the UVM library</span></span><br><span class="line">  <span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// include the UVM macros</span></span><br><span class="line">  <span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// import the yapp UVC</span></span><br><span class="line">  <span class="keyword">import</span> yapp_pkg::*;</span><br><span class="line">  <span class="keyword">import</span> hbus_pkg::*;</span><br><span class="line">  <span class="keyword">import</span> channel_pkg::*;</span><br><span class="line">  <span class="keyword">import</span> clock_and_reset_pkg::*;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// include the test library file</span></span><br><span class="line">  <span class="meta">`<span class="keyword">include</span> &quot;router_tb.sv&quot;</span></span><br><span class="line">  <span class="meta">`<span class="keyword">include</span> &quot;router_test_lib.sv&quot;</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    yapp_vif_config::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.tb.yapp.tx_agent.*&quot;</span>, <span class="string">&quot;vif&quot;</span>, hw_top<span class="variable">.in0</span>);</span><br><span class="line">    hbus_vif_config::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.tb.hbus.*&quot;</span>, <span class="string">&quot;vif&quot;</span>, hw_top<span class="variable">.hif</span> ); </span><br><span class="line">    channel_vif_config::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.tb.chan0.*&quot;</span>, <span class="string">&quot;vif&quot;</span>, hw_top<span class="variable">.ch0</span>);</span><br><span class="line">    channel_vif_config::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.tb.chan1.*&quot;</span>, <span class="string">&quot;vif&quot;</span>, hw_top<span class="variable">.ch1</span>);</span><br><span class="line">    channel_vif_config::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.tb.chan2.*&quot;</span>, <span class="string">&quot;vif&quot;</span>, hw_top<span class="variable">.ch2</span>);</span><br><span class="line">    clock_and_reset_vif_config::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.tb.clock_and_reset.*&quot;</span>, <span class="string">&quot;vif&quot;</span>, hw_top<span class="variable">.clk_rst_if</span>);</span><br><span class="line">    run_test();</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> : tb_top</span><br></pre></td></tr></table></figure>
<h2 id="rtl-top">RTL top</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hw_top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clock and reset signals</span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>]  clock_period;</span><br><span class="line">  <span class="keyword">logic</span>         run_clock;</span><br><span class="line">  <span class="keyword">logic</span>         clock;</span><br><span class="line">  <span class="keyword">logic</span>         reset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// YAPP Interface to the DUT</span></span><br><span class="line">  yapp_if in0(clock, reset);</span><br><span class="line">  <span class="comment">// reset will now be generated by the Clock and Reset UVC</span></span><br><span class="line">  <span class="comment">// input: clock; output: reset, run_clock, clock_period</span></span><br><span class="line">  clock_and_reset_if clk_rst_if(<span class="variable">.clock</span>(clock), <span class="variable">.reset</span>(reset), <span class="variable">.run_clock</span>(run_clock), <span class="variable">.clock_period</span>(clock_period));</span><br><span class="line">  hbus_if hif(<span class="variable">.clock</span>(clock), <span class="variable">.reset</span>(reset));</span><br><span class="line"></span><br><span class="line">  channel_if ch0(<span class="variable">.clock</span>(clock), <span class="variable">.reset</span>(reset));</span><br><span class="line">  channel_if ch1(<span class="variable">.clock</span>(clock), <span class="variable">.reset</span>(reset));</span><br><span class="line">  channel_if ch2(<span class="variable">.clock</span>(clock), <span class="variable">.reset</span>(reset));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLKGEN module generates clock</span></span><br><span class="line">  clkgen clkgen (</span><br><span class="line">    <span class="variable">.clock</span>(clock),</span><br><span class="line">    <span class="variable">.run_clock</span>(run_clock),</span><br><span class="line">    <span class="variable">.clock_period</span>(clock_period)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  yapp_router dut(</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="pkg.sv">pkg.sv</h2>
<p>`<code>include</code> all related uvm class in
<strong>pgk.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yapp_pkg;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uvm_config_db<span class="variable">#(virtual yapp_if)</span> yapp_vif_config;</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_packet.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_monitor.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_sequencer.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_seqs.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_env.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>
<h2 id="if.sv">if.sv</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> yapp_if (<span class="keyword">input</span> clock, <span class="keyword">input</span> reset );</span><br><span class="line"><span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line"><span class="keyword">timeprecision</span> <span class="number">100</span>ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> yapp_pkg::*;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endinterface</span> : yapp_if</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Complete Response used in single-pole filter model in systemverilog</title>
    <url>/2022/02/13/completeResponse/</url>
    <content><![CDATA[<div class="pdf-container" data-target="/pdfs/completeResponse.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>C++ conditional compilation</title>
    <url>/2022/02/07/cxx-conditional-compilation/</url>
    <content><![CDATA[<h4 id="using-g-only">Using g++ only</h4>
<p><strong>conditional.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> na 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a[na];</span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; na; n++) a[n] = a[n<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="comment">// Only kept by preprocessor if DEBUG defined</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; na; n++) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a[&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; a[n] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>-DDEBUG</strong> args</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ -Wall -Wextra -Wconversion conditional.cpp -o conditional</span><br><span class="line">$ ./conditional</span><br><span class="line">$ g++ -Wall -Wextra -Wconversion conditional.cpp -o conditional -DDEBUG</span><br><span class="line">$ ./conditional</span><br><span class="line">a[0] = 2</span><br><span class="line">a[1] = 3</span><br><span class="line">a[2] = 4</span><br><span class="line">a[3] = 5</span><br></pre></td></tr></table></figure>
<hr />
<hr />
<h4 id="using-cmakelists.txt-add_definitions">Using
<strong>CMakeLists.txt</strong> <em>add_definitions</em></h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(DEBUG <span class="string">&quot;Option description&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(DEBUG)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">endif</span>(DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(cond conditional.cpp)</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>without debug</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ ./cond</span><br></pre></td></tr></table></figure>
<p><strong>with debug</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cmake -DDEBUG=ON ..</span><br><span class="line">$ make</span><br><span class="line">$ ./cond</span><br><span class="line">a[0] = 2</span><br><span class="line">a[1] = 3</span><br><span class="line">a[2] = 4</span><br><span class="line">a[3] = 5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
  </entry>
  <entry>
    <title>simulation data dumping</title>
    <url>/2022/06/04/data-dump/</url>
    <content><![CDATA[<h2 id="fsdb">FSDB</h2>
<h3 id="fsdbdumpfile"><code>$fsdbDumpfile</code></h3>
<p>It specifies the FSDB file name created by the Novas object files for
FSDB dumping. If it is not specified, then the default FSDB file name is
"novas.fsdb".</p>
<blockquote>
<p>This command is valid only <strong>before</strong> executing
<code>$fsdbDumpvars</code> and is ignored if specified after
<code>$fsdbDumpvars</code></p>
</blockquote>
<h3 id="fsdbsuppress"><code>$fsdbSuppress</code></h3>
<p>The <code>fsdbSuppress</code>utility is used to skip dumping of few
instances, scopes, modules and signals. The
<code>fsdbSuppress</code>utility is a system task like other fsdb
tasks.</p>
<blockquote>
<p>For <code>$fsdbSuppress()</code> to be effective, it needs to be
specified/called <strong>before</strong> <code>$fsdbDumpvars</code></p>
</blockquote>
<h3
id="fsdbautoswitchdumpfile"><code>$fsdbAutoSwitchDumpfile</code></h3>
<p>Automatically switch to a new dump file when the working FSDB file
reaches the specified size or the specified wall time period.</p>
<blockquote>
<p>After the dumping is finished, a <strong>virtual FSDB file
(*.vf)</strong> is automatically created and list all of the generated
FSDB files with the correct sequence. Only the <strong>virtual FSDB
file</strong>, rather than all of the FSDB files, needs to be loaded to
view the simulation results</p>
</blockquote>
<p>When specified in the design to switch based on <strong>file
size</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$fsdbAutoSwitchDumpfile(File_Size | File_Size_var, &quot;FSDB_Name&quot; |FSDB_Name_var, Number_of_Files | Number_of_Files_var[ ,&quot;log_filename&quot; | ,log_filename_var ], [&quot;+no_overwrite&quot;]);</span><br></pre></td></tr></table></figure>
<p>When specified in the design to switch based on <strong>time
period</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$fsdbAutoSwitchDumpfile(File_Size | File_Size_var, &quot;FSDB_Name&quot; |FSDB_Name_var, Number_of_Files | Number_of_Files_var[ ,&quot;log_filename&quot; | ,log_filename_var ], [&quot;+no_overwrite&quot;], “+by_period”);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>“+by_period”</code></p>
</blockquote>
<h3 id="fsdbdumpvars"><code>$fsdbDumpvars</code></h3>
<p>This command dumps the change in signal value to the FSDB file.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$fsdbDumpvars([ depth, | &quot;level=&quot;,depth_var, ],[instance | &quot;instance=&quot;,instance_var])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>For VCS users, to include memory, MDA, packed array and structure
information in the generated FSDB file, the <code>-debug_access</code>
option must be included when VCS is invoked to <strong>compile the
design</strong></p>
</blockquote>
<ul>
<li><p><code>depth</code></p>
<p>Specify how many sub-scope levels under the given scope you want to
dump.</p>
<ul>
<li>Specify this argument as <strong>1</strong> to dump the signals
under the given scope</li>
<li>Specify this argument as <strong>0</strong> to dump all signals
under the given scope and its descendant scopes.</li>
</ul>
<p>0: all signals in all scopes.</p>
<p>1: all signals in current scope.</p>
<p>2: all signals in the current scope and all scopes one level
below.</p>
<p>n: all signals in the current scope and all scopes n-1 levels
below.</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 9%" />
<col style="width: 18%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>tb.clk</th>
<th>tb.u_div2.div2</th>
<th>tb.u_div2.u_div2neg.div2neg</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$fsdbDumpvars(0)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td>$fsdbDumpvars(1)</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr class="odd">
<td>$fsdbDumpvars(2)</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr class="even">
<td>$fsdbDumpvars(1, tb.u_div2)</td>
<td>✗</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr class="odd">
<td>$fsdbDumpvars(0, tb.u_div2)</td>
<td>✗</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">	divider2 u_div2(clk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">forever</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		#<span class="number">100</span>;</span><br><span class="line">		<span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		 #<span class="number">10</span>;</span><br><span class="line">		 $fsdbDumpfile(<span class="string">&quot;tb.fsdb&quot;</span>);</span><br><span class="line">		 <span class="comment">//$fsdbDumpvars(0);				// same with $fsdbDumpvars(0, tb)</span></span><br><span class="line">		 <span class="comment">//$fsdbDumpvars(1);				// same with $fsdbDumpvars(1, tb)</span></span><br><span class="line">		 <span class="comment">//$fsdbDumpvars(2);				// same with $fsdbDumpvars(2, tb)</span></span><br><span class="line">		 <span class="comment">//$fsdbDumpvars(1, tb.u_div2);</span></span><br><span class="line">		 $fsdbDumpvars(<span class="number">0</span>, tb<span class="variable">.u_div2</span>);</span><br><span class="line">		 #<span class="number">80</span> <span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> divider2 (</span><br><span class="line">	<span class="keyword">input</span> clk</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">reg</span> div2;</span><br><span class="line"></span><br><span class="line">	divider2neg u_div2neg(div2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">		div2 = ~div2;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		div2 = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> divider2neg (</span><br><span class="line">	<span class="keyword">input</span> clk</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">reg</span> div2neg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">		div2neg = ~div2neg;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		div2neg= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><em>compile</em> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcs -full64 -kdb -debug_access+all tb.v</span><br></pre></td></tr></table></figure></p>
<p><em>simulate</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./simv</span><br></pre></td></tr></table></figure>
<p><em>load fsdb</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verdi -ssf tb.fsdb</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/04/data-dump/image-20220604192421888.png"
alt="image-20220604192421888" /></p></li>
</ul>
<h3
id="fsdbdumpon-fsdbdumpoff"><code>$fsdbDumpon, $fsdbDumpoff</code></h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$fsdbDumpon([<span class="string">&quot;+fsdbfile+filename&quot;</span>])</span><br><span class="line"></span><br><span class="line">$fsdbDumpoff([<span class="string">&quot;+fsdbfile+filename&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>These FSDB dumping commands turn dumping on and off.
<code>fsdbDumpon/fsdbDumpoff</code> has the highest priority and
overrides all other FSDB dumping commands.</p>
<p><code>fsdbDumpon/fsdbDumpoff</code> is not restricted to only
<code>fsdbDumpvars</code>. If there is more than one FSDB file open for
dumping at one simulation run, <code>fsdbDumpon/fsdbDumpoff</code> may
only affect a specific FSDB file by specifying the specific file
name.</p>
<ul>
<li><code>+fsdbfile+filename</code>: Specify the FSDB file name. If not
specified, the default FSDB file name is "novas.fsdb"</li>
</ul>
<h3 id="fsdbdumpfinish"><code>$fsdbDumpFinish</code></h3>
<p>This command closes all FSDB files in the current simulation and
stops dumping of signals. Although all FSDB files are <em>closed
automatically at the end of simulation</em>, this dumping command can be
invoked to <em>explicitly</em> close the FSDB files during the
simulation</p>
<h2 id="vcd">VCD</h2>
<h3 id="dumpfile"><code>$dumpfile</code></h3>
<p>The declaration onf <code>$dumpfile</code> must come before the
<code>$dumpvars</code> or any other system tasks that specifies
dump.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$dumpfile</span>(<span class="string">&quot;test.vcd&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argument <strong>is necessary</strong>, there is no default value</p>
</blockquote>
<h3 id="dumpvars"><code>$dumpvars</code></h3>
<p>The <code>$dumpvars</code> is used to specify which variables are to
be dumped ( in the file mentioned by <code>$dumpfile</code>). The
simplest way to use it is without any argument.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$dumpvars</span>(&lt;levels&gt; &lt;, &lt;module_or_variable&gt;&gt;* );</span><br></pre></td></tr></table></figure>
<h3 id="dumplimit"><code>$dumplimit</code></h3>
<p>It is possible that you inadvertantly generate huge file in Gigabytes
( for examples while dumping a Gigahertz clock for one second). To
reduce such occurrences, we may use <code>$dumplimit</code>. It usage
is</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$dumplimit</span>(&lt;filesize&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="dumpoff-and-dumpon"><code>$dumpoff and $dumpon</code></h3>
<p>During the simulation if you are bothered about about only during a
certain interval then you can use <code>$dumpoff</code> and
<code>$dumpon</code>. The following example shows its usage. It will
dump the changes for first 100 units of time and then between 10200 and
10400 units of time.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot; reset=%b,clk_out=%b&quot;</span>,reset,clk_out);</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$dumpfile</span>(<span class="string">&quot;clkdiv2n_tb.vcd&quot;</span>);</span><br><span class="line">            <span class="built_in">$dumpvars</span>(<span class="number">0</span>,clkdiv2n_tb);</span><br><span class="line">            #<span class="number">100</span>;</span><br><span class="line">            <span class="built_in">$dumpoff</span>;</span><br><span class="line">            #<span class="number">10200</span>;</span><br><span class="line">            <span class="built_in">$dumpon</span>;</span><br><span class="line">            #<span class="number">10400</span>;</span><br><span class="line">            <span class="built_in">$dumpoff</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="demo">demo</h3>
<p>stimulus.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> stimulus;</span><br><span class="line">	<span class="comment">// Inputs</span></span><br><span class="line">	<span class="keyword">reg</span> x;</span><br><span class="line">	<span class="keyword">reg</span> y;</span><br><span class="line">	<span class="comment">// Outputs</span></span><br><span class="line">	<span class="keyword">wire</span> z;</span><br><span class="line">	<span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">	comparator uut (</span><br><span class="line">		<span class="variable">.x</span>(x),</span><br><span class="line">		<span class="variable">.y</span>(y),</span><br><span class="line">		<span class="variable">.z</span>(z)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="built_in">$dumpfile</span>(<span class="string">&quot;test.vcd&quot;</span>);</span><br><span class="line">		<span class="built_in">$dumpvars</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// Initialize Inputs</span></span><br><span class="line">		x = <span class="number">0</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		#<span class="number">20</span> x = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">20</span> y = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">20</span> y = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">20</span> x = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">40</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="built_in">$monitor</span>(<span class="string">&quot;t=%3d x=%d,y=%d,z=%d \n&quot;</span>,<span class="built_in">$time</span>,x,y,z, );</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>comparator.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> comparator(</span><br><span class="line">	<span class="keyword">input</span> x,</span><br><span class="line">	<span class="keyword">input</span> y,</span><br><span class="line">	<span class="keyword">output</span> z</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> z = (~x &amp; ~y) |(x &amp; y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ xrun stimulus.v comparator.v -access +rwc</span><br><span class="line">$ simvision test.vcd</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>$dumpvars and $dumpfile Verilog,
http://www.referencedesigner.com/tutorials/verilog/verilog_62.php</p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Data Converter Evaluation</title>
    <url>/2023/03/29/dataconverter-test/</url>
    <content><![CDATA[<h2 id="term-abbreviation">Term Abbreviation</h2>
<p>SNR: signal-to-noise ratio</p>
<p>SINAD: signal to noise and distortion</p>
<p>ENOB: effective number of bits</p>
<p>THD: total harmonic distortion</p>
<p>SFDR: spurious-free dynamic range</p>
<p>TTIMD: two-tone intermodulation distortion</p>
<p>MTIMD: multi-tone intermodulation distortion</p>
<p>VSWR: voltage standing-wave ratio</p>
<h2 id="coherent-sampling">Coherent Sampling</h2>
<p>To avoid <strong>spectral leakage</strong> completely, the method of
<strong>coherent sampling</strong> is recommended. Coherent sampling
requires that the input- and clock-frequency generators are
<strong>phase locked</strong>, and that the input frequency be chosen
based on the following relationship: <span class="math display">\[
\frac{f_{\text{in}}}{f_{\text{s}}}=\frac{M_C}{N_R}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(f_{\text{in}}\)</span> = the desired
input frequency</li>
<li><span class="math inline">\(f_s\)</span> = the clock frequency of
the data converter under test</li>
<li><span class="math inline">\(M_C\)</span> = the number of cycles in
the data window (to make all samples unique, choose odd or prime
numbers)</li>
<li><span class="math inline">\(N_R\)</span> = the data record length
(for an 8192-point FFT, the data record is 8192s long)</li>
</ul>
<p><span class="math display">\[\begin{align}
f_{\text{in}} &amp;=\frac{f_s}{N_R}\cdot M_C \\
&amp;= f_{\text{res}}\cdot M_C
\end{align}\]</span></p>
<h3 id="irreducible-ratio">irreducible ratio</h3>
<p>An <strong>irreducible ratio</strong> ensures identical code
sequences not to be repeated multiple times. Unnecessary repetition of
the same code is not desirable as it increases ADC test time.</p>
<blockquote>
<p>Given that <span class="math inline">\(\frac{M_C}{N_R}\)</span> is
irreducible, and <span class="math inline">\(N_R\)</span> is a power of
2, an <strong>odd number</strong> for <span
class="math inline">\(M_C\)</span> will always produce an
<strong>irreducible ratio</strong></p>
</blockquote>
<p>Assuming there is a common factor <span
class="math inline">\(k\)</span> between <span
class="math inline">\(M_C\)</span> and <span
class="math inline">\(N_R\)</span>, i.e. <span
class="math inline">\(\frac{M_C}{N_R}=\frac{k M_C&#39;}{k
N_R&#39;}\)</span></p>
<p>The samples (<span class="math inline">\(n\in[1, N_R]\)</span>)</p>
<p><span class="math display">\[\begin{align}
y[n] &amp;= \sin\left( \omega_{\text{in}} \cdot t_n \right) \\
&amp;= \sin\left( \omega_{\text{in}} \cdot n\frac{1}{f_s} \right)  \\
&amp; = \sin\left( \omega_{\text{in}} \cdot
n\frac{1}{f_{\text{in}}}\frac{M_C}{N_R} \right) \\
&amp; = \sin\left( 2\pi n\frac{M_C}{N_R} \right)
\end{align}\]</span></p>
<p>Then</p>
<p><span class="math display">\[\begin{align}
y[n+N_R&#39;] &amp;= \sin\left( 2\pi (n+N_R&#39;)\frac{M_C}{N_R} \right)
\\
&amp; = \sin\left( 2\pi n \frac{M_C}{N_R} + 2\pi
N_R&#39;\frac{M_C}{N_R}\right) \\
&amp; = \sin\left( 2\pi n \frac{M_C}{N_R} + 2\pi
N_R&#39;\frac{kM_C&#39;}{kN_R&#39;} \right) \\
&amp; = \sin\left( 2\pi n \frac{M_C}{N_R} + 2\pi M_C&#39; \right) \\
&amp; = \sin\left( 2\pi n \frac{M_C}{N_R}\right)
\end{align}\]</span></p>
<p>So, the samples is repeated <span class="math inline">\(y[n] =
y[n+N_R&#39;]\)</span>. Usually, no additional information is gained by
repeating with the same sampling points.</p>
<h3 id="general-simulation-setup">General Simulation Setup</h3>
<p><span class="math display">\[
N \cdot \frac{1}{F_s} = M \cdot \frac{1}{F_{in}}
\]</span> where <span class="math inline">\(F_s\)</span> is sample
frequency, <span class="math inline">\(F_{in}\)</span> input signal
frequency.</p>
<p>And <span class="math inline">\(N\)</span> often is 256, 512; M is 3,
5, 7, 11.</p>
<h2 id="reference">reference</h2>
<p>everynanocounts. Memos on FFT With Windowing. URL: <a
href="https://everynanocounts.com/2018/02/01/memos-on-fft-with-windowing/">https://everynanocounts.com/2018/02/01/memos-on-fft-with-windowing/</a></p>
<p>How to choose FFT depth for ADC performance analysis (SINAD, ENOB).
URL:<a
href="https://dsp.stackexchange.com/a/38201">https://dsp.stackexchange.com/a/38201</a></p>
<p>Computation of Effective Number of Bits, Signal to Noise Ratio, &amp;
Signal to Noise &amp; Distortion Ratio Using FFT. URL:<a
href="https://cdn.teledynelecroy.com/files/appnotes/computation_of_effective_no_bits.pdf">https://cdn.teledynelecroy.com/files/appnotes/computation_of_effective_no_bits.pdf</a></p>
<p>Kester, Walt. (2009). Understand SINAD, ENOB, SNR, THD, THD + N, and
SFDR so You Don't Get Lost in the Noise Floor. URL:<a
href="https://www.analog.com/media/en/training-seminars/tutorials/MT-003.pdf">https://www.analog.com/media/en/training-seminars/tutorials/MT-003.pdf</a></p>
<p>T. C. Hofner: Dynamic ADC testing part I. Defining and testing
dynamic ADC parameters, Microwaves &amp; RF, 2000, vol. 39, no. 11, pp.
75-84,162</p>
<p>T. C. Hofner: Dynamic ADC testing part 2. Measuring and evaluating
dynamic line parameters, Microwaves &amp; RF, 2000, vol. 39, no. 13, pp.
78-94</p>
<p>AN9675: A Tutorial in Coherent and Windowed Sampling with A/D
Converters <a
href="https://www.renesas.com/us/en/document/apn/an9675-tutorial-coherent-and-windowed-sampling-ad-converters">https://www.renesas.com/us/en/document/apn/an9675-tutorial-coherent-and-windowed-sampling-ad-converters</a></p>
<p>APPLICATION NOTE 3190: Coherent Sampling Calculator (CSC) <a
href="https://www.stg-maximintegrated.com/en/design/technical-documents/app-notes/3/3190.html">https://www.stg-maximintegrated.com/en/design/technical-documents/app-notes/3/3190.html</a></p>
<p>Coherent Sampling (Very Brief and Simple) <a
href="https://www.dsprelated.com/thread/469/coherent-sampling-very-brief-and-simple">https://www.dsprelated.com/thread/469/coherent-sampling-very-brief-and-simple</a></p>
<p>Signal Chain Basics #160: Making sense of coherent and noncoherent
sampling in data-converter testing <a
href="https://www.planetanalog.com/signal-chain-basics-160-making-sense-of-coherent-and-noncoherent-sampling-in-data-converter-testing/">https://www.planetanalog.com/signal-chain-basics-160-making-sense-of-coherent-and-noncoherent-sampling-in-data-converter-testing/</a></p>
<p>Signal Chain Basics #104: Understanding noise in ADCs <a
href="https://www.planetanalog.com/signal-chain-basics-part-104-understanding-noise-in-adcs/">https://www.planetanalog.com/signal-chain-basics-part-104-understanding-noise-in-adcs/</a></p>
<p>Signal Chain Basics #101: ENOB Degradation Analysis Over Frequency
Due to Jitter <a
href="https://www.planetanalog.com/signal-chain-basics-part-101-enob-degradation-analysis-over-frequency-due-to-jitter/">https://www.planetanalog.com/signal-chain-basics-part-101-enob-degradation-analysis-over-frequency-due-to-jitter/</a></p>
<p>Clock jitter analyzed in the time domain, Part 1, Texas Instruments
Analog Applications Journal (slyt379), Aug 2010 <a
href="https://www.ti.com/lit/an/slyt379/slyt379.pdf">https://www.ti.com/lit/an/slyt379/slyt379.pdf</a></p>
<p>Clock jitter analyzed in the time domain, Part 2 <a
href="https://www.ti.com/lit/slyt389">https://www.ti.com/lit/slyt389</a></p>
<p>Measurement of Total Harmonic Distortion and Its Related Parameters
using Multi-Instrument [<a
href="https://www.virtins.com/doc/Measurement-of-Total-Harmonic-Distortion-and-Its-Related-Parameters-using-Multi-Instrument.pdf">pdf</a>]</p>
<p>Application Note AN-4: Understanding Data Converters' Frequency
Domain Specifications [<a
href="https://www.datel.com/data/ads/adc-an4.pdf">pdf</a>]</p>
<p>Belleman, J. (2008). From analog to digital.
10.5170/CERN-2008-003.131. [<a
href="https://cds.cern.ch/record/1100535/files/p131.pdf">pdf</a>]</p>
<p>HandWiki. Coherent sampling [<a
href="https://handwiki.org/wiki/Coherent_sampling">link</a>]</p>
<p>Luis Chioye, TI. Leverage coherent sampling and FFT windows when
evaluating SAR ADCs (Part 1) [<a
href="https://e2e.ti.com/blogs_/archives/b/precisionhub/posts/leverage-coherent-sampling-and-fft-windows-when-evaluating-sar-adcs-part-1">link</a>]</p>
<p>Coherent Sampling vs. Window Sampling | Analog Devices <a
href="https://www.analog.com/en/technical-articles/coherent-sampling-vs-window-sampling.html">https://www.analog.com/en/technical-articles/coherent-sampling-vs-window-sampling.html</a></p>
<p>Understanding Effective Number of Bits <a
href="https://robustcircuitdesign.com/signal-chain-explorer/understanding-effective-number-of-bits/">https://robustcircuitdesign.com/signal-chain-explorer/understanding-effective-number-of-bits/</a></p>
<p>ADC Input Noise: The Good, The Bad, and The Ugly. Is No Noise Good
Noise? [<a
href="https://www.analog.com/en/resources/analog-dialogue/articles/adc-input-noise.html">https://www.analog.com/en/resources/analog-dialogue/articles/adc-input-noise.html</a>]</p>
<p>Walt Kester, Taking the Mystery out of the Infamous Formula, "SNR =
6.02N + 1.76dB," and Why You Should Care [<a
href="https://www.analog.com/media/en/training-seminars/tutorials/MT-001.pdf">https://www.analog.com/media/en/training-seminars/tutorials/MT-001.pdf</a>]</p>
<p>Dan Boschen, "How to choose FFT depth for ADC performance analysis
(SINAD, ENOB)", [<a
href="https://dsp.stackexchange.com/a/38201">https://dsp.stackexchange.com/a/38201</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Zero(DC component) and Nyquist Component in FFT</title>
    <url>/2022/05/14/dc-nyquist-fft/</url>
    <content><![CDATA[<h2 id="dc-offset">DC offset</h2>
<p>Performing FFT to a signal with a <em>large DC offset</em> would
often result in a big impulse around frequency 0 Hz, thus masking out
the signals of interests with relatively small amplitude.</p>
<p><img src="/2022/05/14/dc-nyquist-fft/Remove_DC_Offset_Blog_10.png"
alt="Remove_DC_Offset_Blog_10" /></p>
<p>One method to remove DC offset from the original signal before
performing FFT</p>
<ul>
<li>Subtracting the Mean of Original Signal</li>
</ul>
<p>You can also not filter the input, but set zero to the zero frequency
point for FFT result.</p>
<h2 id="nyquist-component">Nyquist component</h2>
<p>If we go back to the definition of the DFT <span
class="math display">\[
X(N/2)=\sum_{n=0}^{N-1}x[n]e^{-j2\pi
(N/2)n/2}=\sum_{n=0}^{N-1}x[n]e^{-j\pi n}=\sum_{n=0}^{N-1}x[n](-1)^n
\]</span> which is a real number.</p>
<p>The discrete function <span class="math display">\[
x[n]=\cos(\pi n)
\]</span> is always <span class="math inline">\((-1)^n\)</span> for
integer <span class="math inline">\(n\)</span></p>
<p>One general sinusoid at Nyquist and has phase shift <span
class="math inline">\(\theta\)</span>, this is <span
class="math inline">\(T=2\)</span> and <span
class="math inline">\(T_s=1\)</span></p>
<p><span class="math display">\[\begin{align}
x[n] &amp;= A \cos(\pi n + \theta) \\
     &amp;= A \big( \cos(\pi n) \cos(\theta) - \sin(\pi n) \sin(\theta)
\big) \\
     &amp;= \big(A\cos(\theta)\big) \cos(\pi
n)  +  \big(-A\sin(\theta)\big) \sin(\pi n) \\
     &amp;= \big(A\cos(\theta)\big) (-1)^n  +  \big(-A\sin(\theta)\big)
\cdot 0 \\
     &amp;= B \cdot (-1)^n \\
\end{align}\]</span></p>
<p>Where <span class="math inline">\(A\cos(\theta)=B\)</span>.</p>
<p>Moreover <span class="math inline">\(B \cdot (-1)^n = B\cdot \cos(\pi
n)\)</span>, then <span class="math display">\[
B\cdot \cos(\pi n) =  A \cdot \cos(\pi n + \theta)
\]</span> We can <strong>NOT</strong> distinguish one from another.</p>
<p>In other words, you <strong>CAN'T</strong> infer the signal from
<span class="math inline">\(X(\frac{N}{2})\)</span> <span
class="math display">\[\begin{align}
X(k)\frac{1}{N}e^{j 2 \pi \frac{nk}{N}}\bigg|_{k=\frac{N}{2}} &amp;=
\frac{X\left(\frac{N}{2} \right)}{N}(-1)^n  \\
&amp;= \frac{X\left(\frac{N}{2} \right)}{N}\cos(\pi n)  \\
&amp;= \frac{X\left(\frac{N}{2} \right)}{N}\left( \cos(\pi n) - \beta
\sin(\pi n) \right) \\
&amp;= \frac{X\left(\frac{N}{2}
\right)}{N}\sqrt{1+\beta^2}\left(\frac{1}{\sqrt{1+\beta^2}} \cos(\pi n)
- \frac{\beta}{\sqrt{1+\beta^2}} \sin(\pi n) \right) \\
&amp;= \frac{X\left(\frac{N}{2} \right)}{N}
\frac{1}{\cos(\theta)}\left(\cos(\theta) \cos(\pi n) - \sin(\theta)
\sin(\pi n) \right) \\
&amp;= \frac{X\left(\frac{N}{2} \right)}{N} \frac{1}{\cos(\theta)}
\cos(\pi n+\theta)
\end{align}\]</span></p>
<p>where <span class="math inline">\(\beta \in \mathbb{R}\)</span> and
you <strong>wouldn't</strong> know it because <span
class="math inline">\(\sin(\pi n)=0 \quad \forall n \in
\mathbb{Z}\)</span></p>
<p>For example, if <span class="math inline">\(\theta=0\)</span> <span
class="math display">\[
X(k)\frac{1}{N}e^{j 2 \pi \frac{nk}{N}}\bigg|_{k=\frac{N}{2}}=
\frac{X\left(\frac{N}{2} \right)}{N} \cos(\pi n)
\]</span> However, if <span
class="math inline">\(\theta=\frac{\pi}{3}\)</span> <span
class="math display">\[
X(k)\frac{1}{N}e^{j 2 \pi \frac{nk}{N}}\bigg|_{k=\frac{N}{2}}=
\frac{X\left(\frac{N}{2} \right)}{N}\cdot 2 \cos(\pi n+\frac{\pi}{3})
\]</span></p>
<p>That sort of ambiguity is the reason for the <strong>strict
inequality</strong> of the sampling theorem's condition.</p>
<h3 id="duty-cycle-distortion">Duty Cycle Distortion</h3>
<p><strong>Both edges</strong> is used for clock waveform to evaluate
the duty cycle distortion,</p>
<p>Assuming TIE is <code>[0 0.2 0 0.2 0 0.2 ...]</code>, then subtract
DC offset, we get <code>[-0.1 0.1 -0.1 0.1 ...]</code>, shown as
below</p>
<p><img src="/2022/05/14/dc-nyquist-fft/image-20220516224616908.png"
alt="image-20220516224616908" /></p>
<p>The amplitude is manifested in FFT amplitude spectrum, i.e. Nyquist
component, which is <strong>0.1</strong> in follow figure</p>
<p><img src="/2022/05/14/dc-nyquist-fft/image-20220516233618663.png"
alt="image-20220516233618663" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">32</span>;</span><br><span class="line">n = (<span class="number">1</span>:N);</span><br><span class="line">x = <span class="number">0.1</span>*(<span class="number">-1</span>).^n;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">stem(n<span class="number">-1</span>, x);</span><br><span class="line">X = fft(x)/N;</span><br><span class="line">Xshift = fftshift(X);</span><br><span class="line">fprintf(<span class="string">&quot;nyquist component: %.2f\n&quot;</span>, Xshift(<span class="number">1</span>));</span><br><span class="line">magXshift = <span class="built_in">abs</span>(Xshift);</span><br><span class="line">ph = phase(Xshift)/<span class="built_in">pi</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">fx = (-N/<span class="number">2</span>:N/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">stem(fx, magXshift);</span><br><span class="line">xlabel(<span class="string">&#x27;Freq&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;|X(k)|&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;mag of DFT&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">stem(fx, ph);</span><br><span class="line">xlabel(<span class="string">&#x27;Freq&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;\angle X(k)(^oC)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;phase of DFT&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% inverse dft</span></span><br><span class="line">ninv = (<span class="number">0</span>:<span class="number">32</span><span class="number">-1</span>);</span><br><span class="line">xinv = Xshift(<span class="number">1</span>)*<span class="built_in">cos</span>(<span class="built_in">pi</span>*ninv);</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">stem(ninv, x, <span class="string">&quot;filled&quot;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">stem(ninv, xinv,<span class="string">&#x27;bd-.&#x27;</span>);</span><br><span class="line">ninfer = (<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">32</span>+<span class="number">1</span>);</span><br><span class="line">xinfer1 = Xshift(<span class="number">1</span>)*<span class="built_in">cos</span>(<span class="built_in">pi</span>*ninfer); <span class="comment">% theta = 0</span></span><br><span class="line">xinfer2 = Xshift(<span class="number">1</span>)*<span class="number">2</span>*<span class="built_in">cos</span>(<span class="built_in">pi</span>*ninfer+<span class="built_in">pi</span>/<span class="number">3</span>); <span class="comment">% theta = pi/3</span></span><br><span class="line"><span class="built_in">plot</span>(ninfer, xinfer1, <span class="string">&#x27;m--&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(ninfer, xinfer2, <span class="string">&#x27;c--&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;original&#x27;</span>, <span class="string">&#x27;IDFT&#x27;</span>, <span class="string">&#x27;\theta=0&#x27;</span>, <span class="string">&#x27;\theta=\pi/3&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;sample points&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<h2 id="single-sided-amplitude-spectrum">Single-Sided Amplitude
Spectrum</h2>
<p>DC and Nyquist frequency of FFT left over</p>
<p><code>P1(2:end-1) = 2*P1(2:end-1);</code></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Fs = <span class="number">1000</span>;            <span class="comment">% Sampling frequency</span></span><br><span class="line">T = <span class="number">1</span>/Fs;             <span class="comment">% Sampling period</span></span><br><span class="line">L = <span class="number">1500</span>;             <span class="comment">% Length of signal</span></span><br><span class="line">t = (<span class="number">0</span>:L<span class="number">-1</span>)*T;        <span class="comment">% Time vector</span></span><br><span class="line">S = <span class="number">0.7</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">50</span>*t) + <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">120</span>*t);</span><br><span class="line">X = S + <span class="number">2</span>*<span class="built_in">randn</span>(<span class="built_in">size</span>(t));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1000</span>*t(<span class="number">1</span>:<span class="number">50</span>),X(<span class="number">1</span>:<span class="number">50</span>))</span><br><span class="line">title(<span class="string">&#x27;Signal Corrupted with Zero-Mean Random Noise&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;t (milliseconds)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;X(t)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">Y = fft(X);</span><br><span class="line">P2 = <span class="built_in">abs</span>(Y/L);      <span class="comment">%!!! two-sided spectrum P2.</span></span><br><span class="line">P1 = P2(<span class="number">1</span>:L/<span class="number">2</span>+<span class="number">1</span>);   <span class="comment">%!!! single-sided spectrum P1</span></span><br><span class="line">P1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>) = <span class="number">2</span>*P1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>);	<span class="comment">% exclude DC and Nyquist freqency</span></span><br><span class="line">f = Fs*(<span class="number">0</span>:(L/<span class="number">2</span>))/L;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(f,P1)</span><br><span class="line">title(<span class="string">&#x27;Single-Sided Amplitude Spectrum of X(t)&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;f (Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;|P1(f)|&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/14/dc-nyquist-fft/image-20220514221609734.png"
alt="image-20220514221609734" /></p>
<p><img src="/2022/05/14/dc-nyquist-fft/image-20220514221642170.png"
alt="image-20220514221642170" /></p>
<h2 id="alternative-view">Alternative View</h2>
<p>The direct current (DC) bin (<span
class="math inline">\(k=0\)</span>) and the bin at <span
class="math inline">\(k=N/2\)</span>, i.e., the bin that corresponds to
the Nyquist frequency are <strong>purely real and unique</strong>.</p>
<p>sinusoidal waveform with <span class="math inline">\(10Hz\)</span>,
amplitude 1 is <span class="math inline">\(cos(2\pi f_c t)\)</span>. The
plot is shown as below with sampling frequency is <span
class="math inline">\(20Hz\)</span></p>
<p><img src="/2022/05/14/dc-nyquist-fft/image-20220427172526711.png"
alt="image-20220427172526711" /></p>
<p>Amplitude and Phase spectrum, sampled with <span
class="math inline">\(f_s=20\)</span> Hz</p>
<p><img src="/2022/05/14/dc-nyquist-fft/image-20220427174557915.png"
alt="image-20220427174557915" /></p>
<p>The FFT magnitude of <span class="math inline">\(10Hz\)</span> is
<strong>1</strong> and its phase is <strong>0</strong> as shown as
above, which proves the DFT and IDFT.</p>
<p><strong>Caution:</strong> the power of FFT is related to samples (DFT
Parseval's theorem), which may not be the power of continuous signal.
The average power of samples is ([1 -1 1 -1 -1 1 ...]) is
<strong>1</strong>, that of corresponding continuous signal is <span
class="math inline">\(\frac{1}{2}\)</span>.</p>
<p>Power spectrum derived from FFT provide information of samples, i.e.
<strong>1</strong></p>
<p>Moreover, average power of sample [1 -1 1 -1 1 ...] is same with DC
[1 1 1 1 ...].</p>
<h3 id="code">code</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fc = <span class="number">10</span>;</span><br><span class="line">fs = <span class="number">2</span>*fc;</span><br><span class="line">fov = <span class="number">64</span>*fc;</span><br><span class="line"></span><br><span class="line">ts = (<span class="number">0</span>:<span class="number">1</span>/fs:<span class="number">26</span>);</span><br><span class="line">tov = (<span class="number">0</span>:<span class="number">1</span>/fov:<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">ys = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*ts);</span><br><span class="line">yov = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*tov);</span><br><span class="line"><span class="comment">%% waveform</span></span><br><span class="line">stem(ts, ys)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(tov, yov);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sample&#x27;</span>, <span class="string">&#x27;waveform&#x27;</span>)</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>])</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;time(s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;mag(V)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">nfft = <span class="number">256</span>;</span><br><span class="line">X = fftshift(fft(ys, nfft))/nfft;</span><br><span class="line">f = (-nfft/<span class="number">2</span>:nfft/<span class="number">2</span><span class="number">-1</span>)*fs/nfft;</span><br><span class="line">magX = <span class="built_in">abs</span>(X);</span><br><span class="line">phsX = <span class="built_in">atan2</span>(<span class="built_in">imag</span>(X),<span class="built_in">real</span>(X));</span><br><span class="line"><span class="comment">%% fft spectrum</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">stem(f, magX);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>)</span><br><span class="line">xlim([<span class="built_in">min</span>(f)<span class="number">-1</span> <span class="built_in">max</span>(f)+<span class="number">1</span>])</span><br><span class="line">title(<span class="string">&#x27;Amplitude spectrum&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(f, phsX);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;phase (rad)&#x27;</span>)</span><br><span class="line">xlim([<span class="built_in">min</span>(f)<span class="number">-1</span> <span class="built_in">max</span>(f)+<span class="number">1</span>])</span><br><span class="line">title(<span class="string">&#x27;Phase spectrum&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% power spectrum</span></span><br><span class="line">yssq_sum_avg = sum(ys(<span class="number">1</span>:nfft).^<span class="number">2</span>)/nfft;</span><br><span class="line">specsq_sum_avg = sum(<span class="built_in">abs</span>(X).^<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>OriginLab, How to Remove DC Offset before Performing FFT URL: <a
href="http://blog.originlab.com/how-to-remove-dc-offset-before-performing-fft">http://blog.originlab.com/how-to-remove-dc-offset-before-performing-fft</a></p>
<p>How to remove DC component in FFT? URL: <a
href="https://www.mathworks.com/matlabcentral/answers/712808-how-to-remove-dc-component-in-fft#answer_594373">https://www.mathworks.com/matlabcentral/answers/712808-how-to-remove-dc-component-in-fft#answer_594373</a></p>
<p>Analyzing a signal that contains frequency content at Fs/2 doesn't
seem to work unless there is a phase shift URL: <a
href="https://dsp.stackexchange.com/a/59807/59253">https://dsp.stackexchange.com/a/59807/59253</a></p>
<p>Nyquist–Shannon sampling theorem, Critical frequency URL: <a
href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem#Critical_frequency">https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem#Critical_frequency</a></p>
<p>Why remove energy at Nyquist before ifft? URL: <a
href="https://dsp.stackexchange.com/a/22851/59253">https://dsp.stackexchange.com/a/22851/59253</a></p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Delta-Sigma Modulator</title>
    <url>/2023/11/06/delta-sigma/</url>
    <content><![CDATA[<h2 id="oversampling">Oversampling</h2>
<p>In the oversampling process, samples per second are more than what is
required, according to Nyquist-Shannon criteria. Allowing more sample
rates does not influence the signal power and total quantization noise
power. Therefore, the SNR remains unchanged.</p>
<p>The advantage of oversampling is that the quantization noises are
spread over a larger frequency range. This reduces the quantization
noise spectral density (the SNR over the frequency of interest is
increased).</p>
<blockquote>
<p>Comparing normal sampling and oversampling, the quantization noise
power is reduced by 3 dB for every doubling of oversampling ratio (OSR),
where OSR is the ratio of sampling frequency to twice the frequency of
the signal.</p>
</blockquote>
<h2 id="the-delta-modulator">The Delta Modulator</h2>
<ol type="a">
<li>A delta modulator and (b) its simple implementation</li>
</ol>
<p><img src="/2023/11/06/delta-sigma/image-20230202224406667.png"
alt="image-20230202224406667" /></p>
<p>The high loop gain ensures that <span class="math inline">\(V_F
\simeq V_{in}\)</span></p>
<p>The principal difficulty with the delta modulator is that the output
digital representation in fact contains only the <strong>derivative of
the input</strong>, as can be seen by noting <span
class="math inline">\(V_F=\int D_{out}dt\)</span>, i.e. <span
class="math display">\[
D_{out} = \frac{dV_F}{dt}
\]</span></p>
<ul>
<li>This differentiation alters the signal spectrum</li>
<li>attenuates the low-frequency content of the signal</li>
<li>and amplifies high-frequency noise</li>
</ul>
<h2 id="delta-sigma-modulators">Delta-Sigma modulators</h2>
<h2 id="charge-balancing">Charge Balancing</h2>
<h2 id="decimation-filters">Decimation Filters</h2>
<p>A simple time-domain analysis shows that a <strong>sinc
filter</strong> is a suitable decimation filter for a first-order
modulator. Such a filter has a rectangular impulse response, and can be
implemented as a <strong>counter</strong>.</p>
<h2 id="reference">reference</h2>
<p>B. Razavi, "The Delta-Sigma Modulator [A Circuit for All Seasons],"
IEEE Solid-State Circuits Magazine, Volume. 8, Issue. 20, pp. 10-15,
Spring 2016.</p>
<p>Pavan, Shanthi, Richard Schreier, and Gabor Temes. (2016) 2016.
Understanding Delta-Sigma Data Converters. 2nd ed. Wiley.</p>
<p>Richard Schreier (2022). Delta Sigma Toolbox
(https://www.mathworks.com/matlabcentral/fileexchange/19-delta-sigma-toolbox),
MATLAB Central File Exchange. Retrieved June 28, 2022.</p>
<p>Micheal, A., P., Pertijs., Johan, H., Huijsing., Pertijs., Johan, H.,
Huijsing. (2006). Precision Temperature Sensors in CMOS Technology.</p>
<p>Manolis Terrovitis and Ken Kundert. <a
href="https://designers-guide.org/analysis/delta-sigma.pdf">Device noise
simulation of delta-sigma modulators</a> and associated Matlab scripts:
<a
href="https://designers-guide.org/analysis/scripts.tar.gz">scripts.tar.gz</a>,
<a
href="https://designers-guide.org/analysis/scripts.zip">scripts.zip</a>.</p>
<p>Oversampling and Noise Shaping in Delta-Sigma Modulation [<a
href="https://resources.system-analysis.cadence.com/blog/msa2021-oversampling-and-noise-shaping-in-delta-sigma-modulation">https://resources.system-analysis.cadence.com/blog/msa2021-oversampling-and-noise-shaping-in-delta-sigma-modulation</a>]</p>
<p>David A. Johns. ECE1371H - Advanced Analog Circuits - Spring 2014 [<a
href="https://www.eecg.toronto.edu/~johns/ece1371/ece1371.html">https://www.eecg.toronto.edu/~johns/ece1371/ece1371.html</a>]</p>
<p>R.S. Ashwin Kumar. EE698I: Mixed-signal IC design [<a
href="https://home.iitk.ac.in/~ashwinrs/2023_EE698I.html">https://home.iitk.ac.in/~ashwinrs/2023_EE698I.html</a>]</p>
<p>R.S. Ashwin Kumar. EE698W: Analog circuits for signal processing [<a
href="https://home.iitk.ac.in/~ashwinrs/2022_EE698W.html">https://home.iitk.ac.in/~ashwinrs/2022_EE698W.html</a>]</p>
<p>Vishal Saxena. ECE 697 Delta-Sigma Data Converter Design [<a
href="https://www.eecis.udel.edu/~vsaxena/courses/ece697A/s10/ECE697.htm">https://www.eecis.udel.edu/~vsaxena/courses/ece697A/s10/ECE697.htm</a>]</p>
<p>-, ECE 615 Mixed Signal IC Design Spring 2016, Boise State University
[<a
href="https://www.eecis.udel.edu/~vsaxena/courses/ece615/s16/ECE615.htm">https://www.eecis.udel.edu/~vsaxena/courses/ece615/s16/ECE615.htm</a>]</p>
<p>Richard E. Schreier, ECE 1371 Advanced Analog Circuits Notes 2015 [<a
href="http://individual.utoronto.ca/schreier/ece1371-2015.html">http://individual.utoronto.ca/schreier/ece1371-2015.html</a>]</p>
<p>Dai, Getting Started With Delta-Sigma ADC Design [<a
href="https://everynanocounts.com/2022/06/02/getting-started-with-delta-sigma-adc-design/">https://everynanocounts.com/2022/06/02/getting-started-with-delta-sigma-adc-design/</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Dynamic Element Matching (DEM)</title>
    <url>/2022/11/24/dem/</url>
    <content><![CDATA[<p><img src="/2022/11/24/dem/image-20221124201852745.png"
alt="image-20221124201852745" /></p>
<p><img src="/2022/11/24/dem/image-20221124201914625.png"
alt="image-20221124201914625" /></p>
<p><img src="/2022/11/24/dem/image-20221124202015662.png"
alt="image-20221124202015662" /></p>
<h2 id="precision-amplifier">Precision amplifier ?</h2>
<h3 id="solution-1-feedback">Solution 1: Feedback</h3>
<p><img src="/2022/11/24/dem/image-20221124202052715.png"
alt="image-20221124202052715" /></p>
<h3 id="solution-2-trim">Solution 2: Trim</h3>
<p><img src="/2022/11/24/dem/image-20221124202113126.png"
alt="image-20221124202113126" /></p>
<p><img src="/2022/11/24/dem/image-20221124202205049.png"
alt="image-20221124202205049" /></p>
<h3 id="solution-3-dynamic-error-correction">Solution 3: Dynamic Error
Correction</h3>
<p><img src="/2022/11/24/dem/image-20221124202255847.png"
alt="image-20221124202255847" /></p>
<p><img src="/2022/11/24/dem/image-20221124202321948.png"
alt="image-20221124202321948" /></p>
<p><strong>DEM in the Frequency Domain</strong></p>
<p><img src="/2022/11/24/dem/image-20221124202354540.png"
alt="image-20221124202354540" /></p>
<p><img src="/2022/11/24/dem/image-20221124202431040.png"
alt="image-20221124202431040" /></p>
<p><img src="/2022/11/24/dem/image-20221124202453114.png"
alt="image-20221124202453114" /></p>
<h2 id="reference">reference</h2>
<p>Kofi Makinwa, Coping with Variability URL: <a
href="https://youtu.be/nA_DZtRqrTQ">https://youtu.be/nA_DZtRqrTQ</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Windowing Technique for Accurate DFT</title>
    <url>/2023/05/27/dft-window/</url>
    <content><![CDATA[<blockquote>
<p>A finite-length data record = an infinite record multiplied by a
rectangular window</p>
<p><strong>Windowing is unavoidable</strong></p>
</blockquote>
<hr />
<blockquote>
<p>Applying the Hanning window (or any window) to a <strong>periodic
signal</strong> creates leakage.</p>
</blockquote>
<p><strong>leakage</strong>:</p>
<p>​ The component at one frequency leaks into the vicinity of another
compnent owing to the spectral smearing introdued by
<em>window</em>.</p>
<blockquote>
<p>Notice side lobes <em>adding out of phase</em> can <em>reduce</em>
the heights of the peaks</p>
</blockquote>
<h2 id="windowed-signal">Windowed Signal</h2>
<p>Short transient signals in the time domain produce high, broadband
frequency content.</p>
<p><img src="/2023/05/27/dft-window/sharpTransient.png"
alt="sharpTransient" /></p>
<p>To reduce leakage, a mathematical function called a
<strong>window</strong> is applied to the data. Windows are designed to
<em>reduce the sharp transient</em> in the re-created signal as much as
possible.</p>
<p><img src="/2023/05/27/dft-window/windowedsignal.png"
alt="windowedsignal" /></p>
<p>Because the sharp transients are reduced and smoothed, the broadband
frequency of the spectral leakage is also reduced.</p>
<h2 id="periodic-versus-non-periodic-background">Periodic versus
Non-Periodic Background</h2>
<p>When performing a Fourier Transform on measurement data, a window
affects periodic and non-periodic data differently:</p>
<ul>
<li><p><strong>Periodic (No Window needed)</strong>: A signal captured
in a periodic manner does not require a window, and a resulting Fourier
Transform has no leakage. Applying a window alters the resulting Fourier
transform, and even creates spectral leakage where there would have been
no leakage otherwise.</p></li>
<li><p><strong>Non-periodic (Window needed)</strong>: Windows are used
on signals that are captured in a non-periodic manner to reduce spectral
leakage and get closer to the periodic results. A window can minimize
the leakage present in a non-periodic signal, but cannot eliminate
it.</p></li>
</ul>
<blockquote>
<p>The signal is repeated and appended mathematically because the
measured data is assumed to be representative of the entire original
signal</p>
</blockquote>
<h3 id="periodic">Periodic</h3>
<p>When a measurement signal is captured in a periodic manner, the
Fourier Transform of the captured signal will have <strong>no
leakage</strong> in the frequency domain.</p>
<p>A window is not recommended for a periodic signal as it will distort
the signal in an unnecessary manner, and actually creates spectral
leakage.</p>
<p><img src="/2023/05/27/dft-window/captured-periodic.png"
alt="captured-periodic" /></p>
<h3 id="non-periodic">Non-periodic</h3>
<p>The same sine wave, with a different measurement time, results in a
non-periodic captured signal. Here, when the captured signal is
repeated, the original sine wave signal is not re-created.</p>
<p><img src="/2023/05/27/dft-window/captured-nonperiodic.png"
alt="captured-nonperiodic" /></p>
<p>In fact, several broadband transient events (circled in red) are
introduced. These transients create a broadband response, or
<strong>leakage</strong>.</p>
<p><strong>Windows</strong> are used to minimize this leakage effect in
the frequency domain.</p>
<p><img src="/2023/05/27/dft-window/leakage-vs-nonleakage.png"
alt="leakage-vs-nonleakage" /></p>
<h2 id="hanning">Hanning</h2>
<p>When doing operational noise and vibration measurements, the Hanning
window is commonly used.</p>
<p>Random data has spectral leakage due to the <em>abrupt cutoff</em> at
the beginning and end of the time block. It is
<em>non-periodic</em>.</p>
<p>There is <strong>no</strong> way to ensure that the captured random
signal is periodic by varying the measurement time.</p>
<p><strong>Hanning windows</strong> are often used with random data
because they have moderate impact on the frequency resolution and
amplitude accuracy of the resulting frequency spectrum.</p>
<ul>
<li><p>The maximum <em>amplitude error</em> of a Hanning window is
<em>15%</em></p>
<blockquote>
<p>In the cited article, all spectral data <em>had an amplitude
correction factor applied</em>.</p>
</blockquote></li>
<li><p>while the frequency leakage is typically confined to <em>1.5
spectral lines</em> to each side of the original sine wave
signal</p></li>
</ul>
<p><img src="/2023/05/27/dft-window/rtaImage.png"
alt="hanning.png" /></p>
<h3 id="periodic-signal">periodic signal</h3>
<p>Applying the Hanning window (or any window) to a periodic signal
creates <strong>leakage</strong>.</p>
<p><img src="/2023/05/27/dft-window/hanning-periodicsignal.png"
alt="hanning-periodicsignal" /></p>
<blockquote>
<p>The <em>periodically captured</em> sine wave with the Hanning window
(blue) is <em>wider</em> in frequency than the original signal (red)</p>
</blockquote>
<p>In the figure, the sine wave with the Hanning window (blue) is
<em>wider</em> in frequency than the original signal (red).</p>
<h3 id="non-periodic-signal">non-periodic signal</h3>
<p>When a Hanning window is applied to a non-periodic signal, the
leakage is greatly reduced and the amplitude is higher.</p>
<p><img src="/2023/05/27/dft-window/hanning-nonperiodicsignal.png"
alt="hanning-nonperiodicsignal" /></p>
<blockquote>
<p>A <em>non-periodically captured</em> sine wave (magenta) has a
spectral leakage over the entire bandwidth, applying a Hanning window
minimized the leakage (green)</p>
</blockquote>
<h3 id="rms-calculation">RMS calculation</h3>
<p>A <em>RMS calculation</em> <strong>sums up the energy within a
frequency range</strong>.</p>
<p><img src="/2023/05/27/dft-window/rms-cal.png" alt="rms-cal" /></p>
<ul>
<li><p>both the RMS of the periodic and non-periodic signals with a
Hanning window are equal to the RMS of the leakage-free sine
wave.</p></li>
<li><p>Only the RMS of the non-periodic sine wave without a window
applied is not equal to the others</p></li>
</ul>
<blockquote>
<p>With the leakage spread over a smaller frequency range, doing
analysis calculations like <em>RMS</em> yields more accurate
results.</p>
</blockquote>
<h2 id="flattop">Flattop</h2>
<ul>
<li><p>The Flattop window has a <em>better amplitude accuracy</em> in
frequency domain compared to the Hanning window,</p>
<blockquote>
<p>The maximum amplitude error of a Flattop window is <em>less than
0.01%</em>. By contrast, the Hanning window maximum amplitude error is
15%.</p>
</blockquote></li>
<li><p>A Flattop window confines leakage to <em>3.43 spectral lines</em>
to each side of the original signal.</p></li>
</ul>
<h3 id="amplitude-errors">amplitude errors</h3>
<p>These maximum amplitude errors assume that <em>amplitude correction
factors are applied to the frequency spectrums</em>. These amplitude
correction factors compensate for any reduction caused by applying a
window.</p>
<p><img src="/2023/05/27/dft-window/flattop-amplitude.png"
alt="flattop-amplitude" /></p>
<h3 id="leakage">leakage</h3>
<p>The frequency accuracy of the Flattop window is more coarse compared
to a Hanning window. As a result, the Flattop window is typically
employed on data where frequency peaks are distinct and well separated
from each other.</p>
<p><img src="/2023/05/27/dft-window/flattop-leakage.png"
alt="flattop-leakage" /></p>
<p>When the frequency peaks are not guaranteed to be well separated, the
Hanning window is preferred because it is less likely to cause
individual peaks to be lost in the spectrum</p>
<p><img src="/2023/05/27/dft-window/flattop-2tone.png"
alt="flattop-2tone" /></p>
<p>Spectrum of two periodically captured tones that are <span
class="math inline">\(4Hz\)</span> apart with a <span
class="math inline">\(1Hz\)</span> frequency resolution. The spectrum
with a Hanning window (green) shows two peaks while the spectrum with a
Flattop window (blue) shows one peak.</p>
<blockquote>
<p>Note that at the original frequencies of the tones the amplitude is
correct and equal to one for both windows.</p>
</blockquote>
<blockquote>
<p>One common application for a flattop window is performing
<em>calibration</em>. For example, a sound pistonphone only produces
<em>one single</em> and <em>distinct frequency</em> during microphone
calibration.</p>
</blockquote>
<h2 id="uniform">Uniform</h2>
<p>A Uniform window has a value of <em>1.0</em> across the entire
measurement time. In reality, a <strong>Uniform window</strong> could be
called <strong>no window</strong>.</p>
<blockquote>
<p>Depending on the data acquisition system used, sometimes the term
<strong>Rectangular</strong> window is also used.</p>
</blockquote>
<ul>
<li><p>A Uniform window creates no frequency or amplitude distortion
when the measured signal is periodic.</p></li>
<li><p>When a measured signal is not periodic, the amplitude is reduced
by a maximum of <em>36%</em> and the frequency content is spread over
the <em>entire bandwidth of the measurement</em>.</p>
<blockquote>
<p>This is due to <em>sharp transients</em> that are created by
repeating and appending the measured signal.</p>
</blockquote></li>
</ul>
<blockquote>
<p>Whenever a measurement signal is periodic, a Uniform window is
preferred.</p>
<p>Applying a Hanning or Flattop window to a periodic signal will
actually create amplitude and frequency distortion.</p>
</blockquote>
<p><img src="/2023/05/27/dft-window/uniformwindow.png"
alt="uniformwindow" /></p>
<h2 id="benefit-of-reducing-leakage">Benefit of Reducing Leakage</h2>
<p>The benefit is <strong>not</strong> that the captured signal is
perfectly replicated.</p>
<p><strong>The main benefit is that the leakage is now confined over a
smaller frequency range</strong>, instead of affecting the entire
frequency bandwidth of the measurement.</p>
<blockquote>
<p>With the leakage spread over a smaller frequency range, doing
analysis calculations like RMS yields more accurate results.</p>
</blockquote>
<p><img src="/2023/05/27/dft-window/rms-windowed.png"
alt="rms-windowed" /></p>
<p>It is impossible to calculate the proper RMS amplitude estimate over
a limited frequency range of the <em>un-windowed sine wave</em>, since
the leakage is <em>over the full frequency range</em>. Therefore the RMS
amplitude is not correct.</p>
<h3 id="two-tones">Two tones</h3>
<p>In the case of two closely spaced sine tones, without a window being
applied, two tones frequencies would leak into each other, which make
determining the true amplitude of individual peaks very difficult.</p>
<p>The window makes it easier to separate and distinguish each tone so a
proper analysis could be performed.</p>
<p><img src="/2023/05/27/dft-window/windowed-2tone.png"
alt="windowed-2tone" /></p>
<h2 id="window-function-in-frequency-domain">window function in
frequency domain</h2>
<p>The transfer function <span class="math inline">\(a(f)\)</span> of a
window <span class="math inline">\(w_j, j \in [0, N-1]\)</span>
expresses the response of the window to a sinusoidal signal at an offset
of <span class="math inline">\(f\)</span> frequency bins, i.e. DFT .</p>
<p><strong>real part:</strong> <span class="math display">\[
a_r(f)=\sum_{j=0}^{N-1}w_j\cos (2\pi f j/N)
\]</span></p>
<p><strong>imaginary part:</strong> <span class="math display">\[
a_i(f)=\sum_{j=0}^{N-1}w_j\sin (2\pi f j/N)
\]</span></p>
<p>frequency response can be obtained as <span class="math display">\[
a(f) = \frac{\sqrt{a_r^2+a_i^2}}{S_1}
\]</span> where <span class="math inline">\(S_1 = \sum
_{k=0}^{N-1}w_k\)</span></p>
<h3 id="rectangle-window-example">rectangle window example</h3>
<blockquote>
<p>aka. Uniform window, "Rectangular" window, "no window"</p>
<p>Whenever a measurement signal is periodic, a Uniform window is
preferred. Applying a Hanning or Flattop window to a periodic signal
will actually create amplitude and frequency distortion.</p>
</blockquote>
<ol type="1">
<li>When <span class="math inline">\(f=0\)</span></li>
</ol>
<p><span class="math display">\[
a_r(f) + ja_i(f) = \sum_{k=0}^{N-1}w_k = N
\]</span></p>
<ol start="3" type="1">
<li>When <span class="math inline">\(f \neq 0\)</span></li>
</ol>
<p><span class="math display">\[\begin{align}
a_r(f) + ja_i(f) &amp;= \sum_{k=0}^{N-1} e^{\frac{j2\pi k f}{N}} \\
&amp;= \sum_{k=0}^{N/2} e^{\frac{j2\pi k f}{N}} + e^{\frac{j2\pi (k+N/2)
f}{N}} \\
&amp;= \sum_{k=0}^{N/2} e^{\frac{j2\pi k f}{N}} + e^{j\pi}
e^{\frac{j2\pi k f}{N}} \\
&amp;= \sum_{k=0}^{N/2} e^{\frac{j2\pi k f}{N}} - e^{\frac{j2\pi k
f}{N}} \\
&amp;= 0
\end{align}\]</span></p>
<blockquote>
<p>A Uniform window creates no frequency or amplitude distortion when
the <strong>measured signal</strong> is <strong>periodic</strong>.</p>
<p>However, if the signal cannot be guaranteed to be periodic, a Uniform
window should be avoided.</p>
</blockquote>
<h2 id="window-properties">Window Properties</h2>
<p>There is <strong>no</strong> possibility of trade-off between
<em>main-lobe width</em> and <em>sied-lobe amplitude</em>, since the
<em>window length</em> is the only variable parameter.</p>
<blockquote>
<p>The rectangular window has the narrowest main lobe for a given
length, i.e. <span class="math inline">\(\Delta
_{ml}=4\pi/L\)</span></p>
<p>Other windows include the Bartlett, Hann, and Hamming windows. The
DTFTs of all these windows have main-lobe width <span
class="math inline">\(\Delta _{ml}=8\pi/(L-1)\)</span>, which is
approximately twice that of the rectangular window, but they have
significantly smaller side-lobe amplitudes.</p>
</blockquote>
<h2 id="demo">Demo</h2>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"></span><br><span class="line">N = <span class="number">512</span>;</span><br><span class="line">fs = <span class="number">40</span>*<span class="number">1e3</span>; <span class="comment">% 40kHz</span></span><br><span class="line">fres = fs/N; <span class="comment">% 78.125</span></span><br><span class="line">tt = (<span class="number">0</span>:N<span class="number">-1</span>)*<span class="number">1</span>/fs;</span><br><span class="line">ff = (<span class="number">0</span>:N/<span class="number">2</span>)*fres;</span><br><span class="line">fin = <span class="number">390.625</span>;</span><br><span class="line"></span><br><span class="line">whan = hanning(N); <span class="comment">% hanning window</span></span><br><span class="line">wrect = rectwin(N); <span class="comment">% rect window</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% fin/fs = 5/N, periodically captured sine wave</span></span><br><span class="line">wv = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fin*tt);</span><br><span class="line">power = periodogram(wv, whan, N, fs, <span class="string">&#x27;power&#x27;</span>);</span><br><span class="line">X = (power).^<span class="number">0.5</span>*<span class="number">2</span>^<span class="number">0.5</span>;</span><br><span class="line">psd = periodogram(wv, whan, N, fs, <span class="string">&#x27;psd&#x27;</span>);</span><br><span class="line">rms = sum(psd*fres)^<span class="number">0.5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;RMS@periodic &amp; hanning: %.5f\n&#x27;</span>, rms);</span><br><span class="line"></span><br><span class="line">power_rect = periodogram(wv, wrect, N, fs, <span class="string">&#x27;power&#x27;</span>);</span><br><span class="line">X_rect = (power_rect).^<span class="number">0.5</span>*<span class="number">2</span>^<span class="number">0.5</span>;</span><br><span class="line">psd_rect = periodogram(wv, wrect, N, fs, <span class="string">&#x27;psd&#x27;</span>);</span><br><span class="line">rms_rect = sum(psd_rect*fres)^<span class="number">0.5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;RMS@periodic &amp; rect: %.5f\n&#x27;</span>, rms_rect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(ff, X, <span class="string">&#x27;r-o&#x27;</span>, ff, X_rect, <span class="string">&#x27;b-s&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;|X|&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Amplitude spectrum of periodically captured sine wave&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;w/ hanning&#x27;</span>, <span class="string">&#x27;w/ rect&#x27;</span>);</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"><span class="comment">% rectangular window provide higher frequency resolution</span></span><br><span class="line"><span class="comment">% hanning window induce leakage for the periodically captured sine wave</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% fin - 0.5fres</span></span><br><span class="line">fin_lkg0d5 = fin - <span class="number">0.5</span>*fres;</span><br><span class="line">wv_lkg0d5 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fin_lkg0d5*tt);</span><br><span class="line">power_lkg0d5 = periodogram(wv_lkg0d5, whan, N, fs, <span class="string">&#x27;power&#x27;</span>);</span><br><span class="line">X_lkg0d5 = (power_lkg0d5).^<span class="number">0.5</span>*<span class="number">2</span>^<span class="number">0.5</span>;</span><br><span class="line">psd_lkg0d5 = periodogram(wv_lkg0d5, whan, N, fs, <span class="string">&#x27;psd&#x27;</span>);</span><br><span class="line">rms_lkg0d5 = sum(psd_lkg0d5*fres)^<span class="number">0.5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;RMS@-0.5fres &amp; hanning: %.5f\n&#x27;</span>, rms_lkg0d5);</span><br><span class="line"></span><br><span class="line">power_lkg0d5_rect = periodogram(wv_lkg0d5, wrect, N, fs, <span class="string">&#x27;power&#x27;</span>);</span><br><span class="line">X_lkg0d5_rect = (power_lkg0d5_rect).^<span class="number">0.5</span>*<span class="number">2</span>^<span class="number">0.5</span>;</span><br><span class="line">psd_lkg0d5_rect = periodogram(wv_lkg0d5, wrect, N, fs, <span class="string">&#x27;psd&#x27;</span>);</span><br><span class="line">rms_lkg0d5_rect = sum(psd_lkg0d5_rect*fres)^<span class="number">0.5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;RMS@-0.5fres &amp; rect: %.5f\n&#x27;</span>, rms_lkg0d5_rect);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(ff, X_lkg0d5, <span class="string">&#x27;r-o&#x27;</span>, ff, X_lkg0d5_rect, <span class="string">&#x27;b-s&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;|X|&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Amplitude spectrum of -0.5fres&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;w/ hanning&#x27;</span>, <span class="string">&#x27;w/ rect&#x27;</span>);</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"><span class="comment">% hanning reduce leakage and max amplitude error 15%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% fin - 0.25fres</span></span><br><span class="line">fin_lkg0d25 = fin - <span class="number">0.25</span>*fres;</span><br><span class="line">wv_lkg0d25 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fin_lkg0d25*tt);</span><br><span class="line">power_lkg0d25 = periodogram(wv_lkg0d25, whan, N, fs, <span class="string">&#x27;power&#x27;</span>);</span><br><span class="line">X_lkg0d25 = (power_lkg0d25).^<span class="number">0.5</span>*<span class="number">2</span>^<span class="number">0.5</span>;</span><br><span class="line">psd_lkg0d25 = periodogram(wv_lkg0d25, whan, N, fs, <span class="string">&#x27;psd&#x27;</span>);</span><br><span class="line">rms_lkg0d25 = sum(psd_lkg0d25*fres)^<span class="number">0.5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;RMS@-0.25fres &amp; hanning: %.5f\n&#x27;</span>, rms_lkg0d25);</span><br><span class="line"></span><br><span class="line">power_lkg0d25_rect = periodogram(wv_lkg0d25, wrect, N, fs, <span class="string">&#x27;power&#x27;</span>);</span><br><span class="line">X_lkg0d25_rect = (power_lkg0d25_rect).^<span class="number">0.5</span>*<span class="number">2</span>^<span class="number">0.5</span>;</span><br><span class="line">psd_lkg0d25_rect = periodogram(wv_lkg0d25, wrect, N, fs, <span class="string">&#x27;psd&#x27;</span>);</span><br><span class="line">rms_lkg0d25_rect = sum(psd_lkg0d25_rect*fres)^<span class="number">0.5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;RMS@-0.25fres &amp; rect: %.5f\n&#x27;</span>, rms_lkg0d25_rect);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(ff, X_lkg0d25, <span class="string">&#x27;r-o&#x27;</span>, ff, X_lkg0d25_rect, <span class="string">&#x27;b-s&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;|X|&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Amplitude spectrum of -0.25fres&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;w/ hanning&#x27;</span>, <span class="string">&#x27;w/ rect&#x27;</span>);</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"><span class="comment">% hanning reduce leakage</span></span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RMS@periodic &amp; hanning: 0.70711</span><br><span class="line">RMS@periodic &amp; rect: 0.70711</span><br><span class="line">RMS@-0.5fres &amp; hanning: 0.70711</span><br><span class="line">RMS@-0.5fres &amp; rect: 0.70711</span><br><span class="line">RMS@-0.25fres &amp; hanning: 0.70711</span><br><span class="line">RMS@-0.25fres &amp; rect: 0.70780</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/27/dft-window/image-20230526005823613.png"
alt="image-20230526005823613" /></p>
<blockquote>
<p>rectangular window provide higher frequency resolution</p>
</blockquote>
<p><img src="/2023/05/27/dft-window/image-20230526005934411.png"
alt="image-20230526005934411" /></p>
<blockquote>
<p>hanning reduce leakage and max amplitude error 15%</p>
</blockquote>
<p><img src="/2023/05/27/dft-window/image-20230526010047826.png"
alt="image-20230526010047826" /></p>
<blockquote>
<p>hanning reduce leakage and reduce amplitude error</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Windows and Spectral Leakage. URL:<a
href="https://community.sw.siemens.com/s/article/windows-and-spectral-leakage">https://community.sw.siemens.com/s/article/windows-and-spectral-leakage</a></p>
<p>Article (20416822) Title: How to Utilize a Windowing Technique for
Accurate DFT URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od000000050UrEAI">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od000000050UrEAI</a></p>
<p>B.P. Lathi, Roger Green. Linear Systems and Signals (The Oxford
Series in Electrical and Computer Engineering) 3rd Edition</p>
<p>Window Types: Hanning, Flattop, Uniform, Tukey, and Exponential
URL:<a
href="https://community.sw.siemens.com/s/article/window-types-hanning-flattop-uniform-tukey-and-exponential">https://community.sw.siemens.com/s/article/window-types-hanning-flattop-uniform-tukey-and-exponential</a></p>
<p>Window Correction Factors URL:<a
href="https://community.sw.siemens.com/s/article/window-correction-factors">https://community.sw.siemens.com/s/article/window-correction-factors</a></p>
<p>Root Mean Square (RMS) and Overall Level. URL:<a
href="https://community.sw.siemens.com/s/article/root-mean-square-rms-and-overall-level">https://community.sw.siemens.com/s/article/root-mean-square-rms-and-overall-level</a></p>
<p>Alan V Oppenheim, Ronald W. Schafer. Discrete-Time Signal Processing,
3rd edition</p>
<p>Stefan Scholl, "Exact Signal Measurements using FFT
Analysis",Microelectronic Systems Design Research Group, TU
Kaiserslautern, Germany. [ <a
href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/4293/file/exact_fft_measurements.pdf">pdf</a>
]</p>
<p>Harris, F. (1978). On the use of windows for harmonic analysis with
the discrete Fourier transform. Proceedings of the IEEE, 66, 51-83. [<a
href="https://www.fceia.unr.edu.ar/prodivoz/Harris_1978.pdf">pdf</a>]</p>
<p>Equivalent noise bandwidth (ENBW) of window functions URL:<a
href="https://www.gaussianwaves.com/2020/09/equivalent-noise-bandwidth-enbw-of-window-functions/">https://www.gaussianwaves.com/2020/09/equivalent-noise-bandwidth-enbw-of-window-functions/</a></p>
<p>Why should I zero-pad a signal before taking the Fourier transform?
URL:<a
href="https://dsp.stackexchange.com/q/741">https://dsp.stackexchange.com/q/741</a></p>
<p>enbw function in MATLAB URL:<a
href="https://www.mathworks.com/help/signal/ref/enbw.html">https://www.mathworks.com/help/signal/ref/enbw.html</a></p>
<p>Window function – figure of merits URL:<a
href="https://www.gaussianwaves.com/2020/09/window-function-figure-of-merits/">https://www.gaussianwaves.com/2020/09/window-function-figure-of-merits/</a></p>
<p>Memos on FFT With Windowing URL:<a
href="https://everynanocounts.com/2018/02/01/memos-on-fft-with-windowing/">https://everynanocounts.com/2018/02/01/memos-on-fft-with-windowing/</a></p>
<p>Jens Ahrens, "Some Notes on Windows in Spectral Analysis," Tech.
Report, Chalmers Univeristy of Technology, 2020. URL:<a
href="https://appliedacousticschalmers.github.io/scaling-of-the-dft/notes_on_windows/">https://appliedacousticschalmers.github.io/scaling-of-the-dft/notes_on_windows/</a></p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Random &amp; Deterministic Jitters Simulation</title>
    <url>/2022/05/16/dj-rj/</url>
    <content><![CDATA[<p><img src="/2022/05/16/dj-rj/image-20220516004008878.png"
alt="image-20220516004008878" /></p>
<h2 id="deterministic-jitter">Deterministic Jitter</h2>
<p><img src="/2022/05/16/dj-rj/image-20220516004058916.png"
alt="image-20220516004058916" /></p>
<p><img src="/2022/05/16/dj-rj/image-20220516004206118.png"
alt="image-20220516004206118" /></p>
<p><code>j_Djpp</code> can be calculated by PSD,too</p>
<p><img src="/2022/05/16/dj-rj/image-20220516004615033.png"
alt="image-20220516004615033" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fck = <span class="number">38.4e6</span>;</span><br><span class="line">Nfft = <span class="number">15000</span>;</span><br><span class="line">fres = fck/Nfft;</span><br><span class="line">psddBc = <span class="number">-99.3343</span>;</span><br><span class="line">psBc = psddBc + <span class="number">10</span>*<span class="built_in">log10</span>(fres);	<span class="comment">% psd -&gt; ps; </span></span><br><span class="line">phrad2 = <span class="number">10</span>^(psBc/<span class="number">10</span>);</span><br><span class="line">phrms = <span class="built_in">sqrt</span>(phrad2);</span><br><span class="line">Jrms = phrms/<span class="number">2</span>/<span class="built_in">pi</span>*<span class="number">1</span>/fck;</span><br><span class="line">Jpp = <span class="number">2</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*Jrms;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jpp =</span><br><span class="line"></span><br><span class="line">   6.4038e-12</span><br></pre></td></tr></table></figure>
<p>For DJ, we usually use peak to peak value</p>
<blockquote>
<p>BTW, the psd value at half of fundamental frequency (<span
class="math inline">\(f_s/2\)</span>) is misleading and ambiguity, we
won't use this value</p>
</blockquote>
<h2 id="random-jitter">Random Jitter</h2>
<p>RJ can be accurately and efficiently measured using
<strong>PSS/Pnoise</strong> or <strong>HB/HBnoise</strong>.</p>
<p>Note that the <strong>transient noise</strong> can also be used to
compute RJ;</p>
<blockquote>
<p>However, the computation cost is typically very high, and the
accuracy is lesser as compared to PSS/Pnoise and HB/HBnoise.</p>
</blockquote>
<p>Since RJ follows a Gaussian distribution, it can be fully
characterized using its Root-Mean-Squared value (RMS) or the standard
deviation value (<span class="math inline">\(\sigma\)</span>)</p>
<p>The Peak-to-Peak value of RJ (<span
class="math inline">\(\text{RJ}_{\text{p-p}}\)</span>) can be calculated
under certain observation conditions <span class="math display">\[
\text{RJ}_{\text{p-p}}\equiv K \ast \text{RJ}_{\text{RMS}}
\]</span> Here, <span class="math inline">\(K\)</span> is a constant
determined by the BER specification of the system given in the following
Table</p>
<table>
<thead>
<tr class="header">
<th>BER</th>
<th>Crest factor (K)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(10^{-3}\)</span></td>
<td>6.18</td>
</tr>
<tr class="even">
<td><span class="math inline">\(10^{-4}\)</span></td>
<td>7.438</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(10^{-5}\)</span></td>
<td>8.53</td>
</tr>
<tr class="even">
<td><span class="math inline">\(10^{-6}\)</span></td>
<td>9.507</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(10^{-7}\)</span></td>
<td>10.399</td>
</tr>
<tr class="even">
<td><span class="math inline">\(10^{-8}\)</span></td>
<td>11.224</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(10^{-9}\)</span></td>
<td>11.996</td>
</tr>
<tr class="even">
<td><span class="math inline">\(10^{-10}\)</span></td>
<td>12.723</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(10^{-11}\)</span></td>
<td>13.412</td>
</tr>
<tr class="even">
<td><span class="math inline">\(10^{-12}\)</span></td>
<td>14.069</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(10^{-13}\)</span></td>
<td>14.698</td>
</tr>
</tbody>
</table>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">K = <span class="number">14.698</span>;</span><br><span class="line">Ks = K/<span class="number">2</span>;</span><br><span class="line">p = normcdf([-Ks Ks]);</span><br><span class="line">BER = <span class="number">1</span> - (p(<span class="number">2</span>)-p(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BER =</span><br><span class="line"></span><br><span class="line">   1.9962e-13</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/16/dj-rj/image-20220516160050961.png"
alt="image-20220516160050961" /></p>
<p><img src="/2022/05/16/dj-rj/image-20220516193125490.png"
alt="image-20220516193125490" /></p>
<h2 id="total-jitter">Total Jitter</h2>
<p><span class="math display">\[
\text{TJ}_{\text{p-p}}\equiv \text{DJ}_{\text{p-p}} +
\text{RJ}_{\text{p-p}}(\text{BER})
\]</span></p>
<p><img src="/2022/05/16/dj-rj/tj.drawio.svg" alt="tj.drawio" /></p>
<p><img src="/2022/05/16/dj-rj/image-20220516160006909.png"
alt="image-20220516160006909" /></p>
<p><img src="/2022/05/16/dj-rj/image-20220516012200383.png"
alt="image-20220516012200383" /></p>
<blockquote>
<p>In the psd of TJ, the spur is DJ and floor is RJ</p>
</blockquote>
<h2 id="phase-noise-to-jitter">Phase Noise to Jitter</h2>
<p>The <strong>phase noise</strong> is traditionally defined as the
ratio of the power of the signal in 1Hz bandwidth at offset <span
class="math inline">\(f\)</span> from the carrier <span
class="math inline">\(P\)</span>, divided by the power of the carrier
<span class="math display">\[
\ell (f) = \frac {S_v&#39;(f_0+f)}{P}
\]</span> where <span class="math inline">\(S_v&#39;\)</span> is is
<strong>one-sided voltage PSD</strong> and <span class="math inline">\(f
\geqslant 0\)</span></p>
<p>Under <strong>narrow angle assumption</strong> <span
class="math display">\[
S_{\varphi}(f)= \frac {S_v&#39;(f_0+f)}{P}
\]</span> where <span class="math inline">\(\forall f\in \left[-\infty
+\infty\right]\)</span></p>
<p>Using the Wiener-Khinchin theorem, it is possible to easily derive
the variance of the absolute jitter(<span
class="math inline">\(J_{ee}\)</span>)via integration of the
corresponding PSD <span class="math display">\[
J_{ee,rms}^2 = \int S_{J_{ee}}(f)df
\]</span></p>
<p>And we know the relationship between absolute jitter and excess phase
is <span class="math display">\[
J_{ee}=\frac {\varphi}{\omega_0}
\]</span> Considering that phase noise is normally symmetrical about the
zero frequency, multiplied by <strong>two</strong> is shown as below
<span class="math display">\[
J_{ee,rms} = \frac{\sqrt{2\int_{0}^{+\infty}\ell(f)df}}{\omega_0}
\]</span> where phase noise is in linear units not in logarithmic
ones.</p>
<p>Because the unit of phase noise in <em>Spectre-RF</em> is logarithmic
unit (<em>dBc</em>), we have to convert the unit before applying the
above equation <span class="math display">\[
\ell[linear] = 10^{\frac {\ell [dBc/Hz]}{10}}
\]</span> The complete equation using the simulation result of
<em>Spectre-RF Pnoise</em> is <span class="math display">\[
J_{ee,rms} = \frac{\sqrt{2\int_{0}^{+\infty}10^{\frac {\ell
[dBc/Hz]}{10}}df}}{\omega_0}
\]</span></p>
<p>The above equation has been verified for <em>sampled pnoise</em>,
i.e. <em>J<sub>ee</sub></em> and <em>Edge Phase Noise</em>.</p>
<blockquote>
<ul>
<li>For <strong>pnoise-sampled(jitter)</strong>, <em>Direct Plot Form -
Function: Jee:Integration Limits</em> can calculate it conveniently</li>
<li>But for <strong>pnoise-timeaveage</strong>, you have to use the
below equation to get RMS jitter.</li>
</ul>
</blockquote>
<p>One example, integrate to <span
class="math inline">\(\frac{f_{osc}}{2}\)</span> and <span
class="math inline">\(f_{osc} = 16GHz\)</span></p>
<p><img src="/2022/05/16/dj-rj/image-20220415100034220.png"
alt="image-20220415100034220" /></p>
<p>Of course, it apply to conventional pnoise simulation.</p>
<p>On the other hand, output rms voltage noise, <span
class="math inline">\(V_{out,rms}\)</span> divied by slope should be
close to <span class="math inline">\(J_{ee,rms}\)</span> <span
class="math display">\[
J_{ee,rms} = \frac {V_{out,rms}}{slope}
\]</span></p>
<h2 id="reference">reference</h2>
<p>Article (20500632) Title: How to simulate Random and Deterministic
Jitters URL:
https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009fiXeEAI</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Impact of Deep N-well Implantation</title>
    <url>/2023/05/29/dnw/</url>
    <content><![CDATA[<h2 id="substrate-noise">Substrate noise</h2>
<p>A variety of techniques can be used to minimize this noise, for
example by keeping analog devices surrounded by guard rings, or using a
separate supply for the substrate/well taps.</p>
<p>However <em>guard rings alone cannot prevent noise coupling deep in
the substrate, only surface currents</em>.</p>
<blockquote>
<p>PMOS are less noisy than NMOS since PMOS has its nwell which isolates
the substrate noise, but such is not valid for NMOS .</p>
</blockquote>
<h2 id="dnw">DNW</h2>
<p>The N-channel devices built directly into the P-type substrate are
not as effectively isolated as P-channel devices in their N-wells. This
is because despite creating a P+ guard ring around the devices, there
remains an electrical path below the guard ring for charge to flow.</p>
<p>To overcome this issue, a <em>deep N-well</em> can be used to more
effectively isolate these N-channel devices.</p>
<p><img src="/2023/05/29/dnw/image-20230529001556060.png"
alt="image-20230529001556060" /></p>
<p><img src="/2023/05/29/dnw/image-20230529010836003.png"
alt="image-20230529010836003" /></p>
<p><img src="/2023/05/29/dnw/BM_SS_Fig1-520x288.jpg"
alt="BM_SS_Together at Last_Fig1" /></p>
<blockquote>
<p>pwdnw: PW/DNW diode</p>
<p>dnwpsub: DNW/PSUB diode</p>
<p><a
href="https://blogs.sw.siemens.com/calibre/2015/11/03/together-at-last-combining-netlist-and-layout-data-for-power-aware-verification/">Together
At Last – Combining Netlist and Layout Data for Power-Aware
Verification</a></p>
</blockquote>
<p><img src="/2023/05/29/dnw/image-20230529002733114.png"
alt="image-20230529002733114" /></p>
<ul>
<li>the P-well is separated, allowing the voltage to be controlled</li>
<li>because the circuit within the deep N-well is separated from the
p-substrate in this structure, there is the benefit that this circuitry
is less susceptible to noise that propagates through the
p-substrate.</li>
</ul>
<h2 id="reference">reference</h2>
<p>Chew, K.W., Zhang, J., Shao, K., Loh, W., &amp; Chu, S.F. (2002).
Impact of Deep N-well Implantation on Substrate Noise Coupling and RF
Transistor Performance for Systems-on-a-Chip Integration. 32nd European
Solid-State Device Research Conference, 251-254. URL:[<a
href="http://www.essderc2002.deis.unibo.it/ESSDERC_web/Session_D11/D11_1.pdf">slides</a>,
<a
href="http://www.essderc2002.deis.unibo.it/data/pdf/Chew.pdf">paper</a>]</p>
<p>Mark Waller, <a
href="https://www.planetanalog.com/analog-layout-why-wells-taps-and-guard-rings-are-crucial/">Analog
layout: Why wells, taps, and guard rings are crucial</a></p>
<p>KEITH SABINE <a
href="https://www.planetanalog.com/using-deep-n-wells-in-analog-design/">Using
Deep N Wells in Analog Design</a></p>
<p>Faricelli, J. (2010). Layout-dependent proximity effects in deep
nanoscale CMOS. IEEE Custom Integrated Circuits Conference 2010,
1-8.</p>
<p>cmos_processing, URL:<a
href="http://users.ece.utexas.edu/~athomsen/cmos_processing.pdf">http://users.ece.utexas.edu/~athomsen/cmos_processing.pdf</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>How to preserve hand-instantiated cells</title>
    <url>/2023/02/10/dont-touch/</url>
    <content><![CDATA[<p>To preserve the hand-instantiated cells</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_dont_touch [get_cells -hierarchical *dont_touch_*]</span><br></pre></td></tr></table></figure>
<p>The instances whose name contain "dont_touch_" shall be preserved
during synthesis</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// no performace concerns, rest sync use sync3 is enough</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> CN_resetb_sync_cell</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> resetb_in,</span><br><span class="line">    <span class="keyword">input</span> clkdst,</span><br><span class="line">    <span class="keyword">output</span> resetb_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">ifdef</span> USE_VERILOG</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] resetb_dly;</span><br><span class="line"><span class="meta">`<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] resetb_dly;</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">ifdef</span> USE_VERILOG</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clkdst <span class="keyword">or</span> <span class="keyword">negedge</span> resetb_in)</span><br><span class="line">    <span class="keyword">if</span> (~resetb_in) resetb_dly &lt;= <span class="number">3&#x27;b000</span>;</span><br><span class="line">    <span class="keyword">else</span> resetb_dly &lt;= &#123;resetb_dly[<span class="number">1</span>:<span class="number">0</span>], <span class="number">1&#x27;b1</span>&#125;;</span><br><span class="line"><span class="meta">`<span class="keyword">else</span></span></span><br><span class="line">SDFCNQD4 dont_touch_sync_flop0 (</span><br><span class="line">    <span class="variable">.SI</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.SE</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.CP</span>(clkdst),</span><br><span class="line">    <span class="variable">.CDN</span>(resetb_in),</span><br><span class="line">    <span class="variable">.D</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.Q</span>(resetb_dly[<span class="number">0</span>])</span><br><span class="line">);</span><br><span class="line">SDFCNQD4 dont_touch_sync_flop1 (</span><br><span class="line">    <span class="variable">.SI</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.SE</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.CP</span>(clkdst),</span><br><span class="line">    <span class="variable">.CDN</span>(resetb_in),</span><br><span class="line">    <span class="variable">.D</span>(resetb_dly[<span class="number">0</span>]),</span><br><span class="line">    <span class="variable">.Q</span>(resetb_dly[<span class="number">1</span>])</span><br><span class="line">);</span><br><span class="line">SDFCNQD4 dont_touch_sync_flop2 (</span><br><span class="line">    <span class="variable">.SI</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.SE</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.CP</span>(clkdst),</span><br><span class="line">    <span class="variable">.CDN</span>(resetb_in),</span><br><span class="line">    <span class="variable">.D</span>(resetb_dly[<span class="number">1</span>]),</span><br><span class="line">    <span class="variable">.Q</span>(resetb_dly[<span class="number">2</span>])</span><br><span class="line">);</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> resetb_out = resetb_dly[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Script to remove .cdslck files</title>
    <url>/2022/02/02/dot-cdslck-clear/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#!/bin/sh</span></span><br><span class="line">tree -<span class="keyword">if</span> | grep <span class="string">&#x27;cdslck&#x27;</span> &gt; txt</span><br><span class="line">var=`<span class="built_in">cat</span> txt`</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$var</span>; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">rm</span> -i <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">rm</span> -i txt</span><br></pre></td></tr></table></figure>
<p><a
href="https://wikis.ece.iastate.edu/vlsi/index.php/Tips_%26_Tricks#Locked_Files_in_Cadence"
class="uri">https://wikis.ece.iastate.edu/vlsi/index.php/Tips_%26_Tricks#Locked_Files_in_Cadence</a></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>different DSPF files for each corner</title>
    <url>/2023/01/29/dspf-in-corner/</url>
    <content><![CDATA[<p>Create a new file with an extension <strong>scs</strong> like
<em>myDSPF_Files.scs</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* DSPF files to use with Corner Definitions</span><br><span class="line">* This is an example file showing how to define different dspf files for different corners</span><br><span class="line">* using model files for individual components as the</span><br><span class="line">* building blocks.</span><br><span class="line">simulator lang=spectre</span><br><span class="line">library dspf_files_corners</span><br><span class="line"></span><br><span class="line">section rctyp_25</span><br><span class="line">dspf_include &quot;DSPF_RC_TYPNOM25.spf&quot;</span><br><span class="line">endsection rctyp_25</span><br><span class="line"></span><br><span class="line">section rctyp_125</span><br><span class="line">dspf_include &quot;DSPF_RC_TYP125.spf&quot;</span><br><span class="line">endsection rctyp_125</span><br><span class="line"></span><br><span class="line">section rcworst_25</span><br><span class="line">dspf_include &quot;DSPF_RC_WORSE25.spf&quot;</span><br><span class="line">end section rcworst_25</span><br><span class="line"></span><br><span class="line">section rcworst_125</span><br><span class="line">dspf_include &quot;DSPF_RC_WORSE125.spf&quot;</span><br><span class="line">end section rcworst_125</span><br><span class="line"></span><br><span class="line">endlibrary dspf_files_corners</span><br></pre></td></tr></table></figure>
<p>Add the file created above ‘<em>myDSPF_File.scs</em>’ in
‘<em>Add/Edit Model Files</em>’ of Corners setup form</p>
<p><img src="/2023/01/29/dspf-in-corner/image-20230129223248655.png"
alt="image-20230129223248655" /></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>How to Save Node in DSPF?</title>
    <url>/2022/04/15/dspf-saveopt/</url>
    <content><![CDATA[<h2 id="dspf-semantics">DSPF Semantics</h2>
<p><code>*|DIVIDER &lt;divider&gt;</code></p>
<p><code>&lt;divider&gt;</code> represents the hierarchical pathname
divider. The default hierarchical character is forward slash
(<strong>/</strong>).</p>
<p><code>*|DELIMITER &lt;delimiter&gt;</code></p>
<ul>
<li><code>&lt;delimiter&gt;</code> represents the delimiter character
used to concatenate an instance name and pin name to form an instance
pin name.</li>
<li>It is also represents the delimiter character used to concatenate a
net name and subnode number to form a subnode name. The default
character is colon (<strong>:</strong>)</li>
</ul>
<p><code>*|BUSBIT &lt;left_busbit_char&gt;&lt;right_busbit_char&gt;</code></p>
<p><code>&lt;left_busbit_char&gt;</code> and
<code>&lt;right_busbit_char&gt;</code> are used at the end of an
identifier of an array to select a single object of the array.</p>
<p>Objects which may be indexed include <em>nets, primary pins, and
instance pins</em></p>
<p><code>*|NET &lt;netName&gt; &lt;netCap&gt;</code></p>
<ul>
<li><code>&lt;netName&gt;</code> represents the name of a net. It can be
a user-provided net name, the name of the driving pin, or the name of
the driving instance pin.</li>
<li><code>&lt;netCap&gt;</code> represents the <strong>total</strong>
capacitance value in farads associated with the net. This may be
comprised of capacitances to ground and capacitances to nearby
wires.</li>
</ul>
<p><code>*|P &lt;pinName&gt; &lt;pinType&gt; &lt;pinCap&gt; &#123;&lt;coord&gt;&#125;</code></p>
<ul>
<li><code>&lt;pinName&gt;</code> represents the name of the pin.</li>
<li><code>&lt;pinType&gt;</code> represents the type of the pin. It can
be any of the following: <em>I (Input), O (Output), B (Bidirectional), X
(don’t care), S (Switch), and J (Jumper)</em>.</li>
<li><code>&lt;pinCap&gt;</code> represents the capacitance value
associated with the pin.</li>
<li><code>&lt;coord&gt;</code> is optional. It represents the location
of the pin. Multiple pin locations are allowed.</li>
</ul>
<p><code>*|S &lt;subNodeName&gt; &#123;&lt;coord&gt;&#125;</code></p>
<p>subnodes in the net</p>
<ul>
<li><code>&lt;subNodeName&gt;</code> represents the name of the subnode.
A subnode name is obtained by concatenating the net name and a subnode
number using the delimiter specified in the DELIMITER statement. The
default delimiter is colon (:).</li>
<li><code>&lt;coord&gt;</code> represents the location of the
subnode.</li>
</ul>
<p><code>*|I &lt;instPinName&gt; &lt;instName&gt; &lt;pinName&gt; &lt;pinType&gt;&lt;pinCap&gt; &#123;&lt;coord&gt;?&#125;</code></p>
<p>describes instance pins in the net</p>
<ul>
<li><code>&lt;instPinName&gt;</code> represents the name of the instance
pin. An instance pin name is obtained by concatenating the
<code>&lt;instName&gt;</code> and the <code>&lt;pinName&gt;</code> with
a delimiting character which is specified by the DELIMITER
statement</li>
<li><code>&lt;instName&gt;</code> represents the name of the
instance</li>
</ul>
<p><code>*|DeviceFingerDelim "@"</code></p>
<p>MOS finger delimiter</p>
<p>For example, <code>M8</code>'s finger is 4, then split into 4 Devices
in DSPF</p>
<blockquote>
<p><code>MM8</code>, <code>MM8@2</code>, <code>MM8@3</code>,
<code>MM8@4</code></p>
</blockquote>
<p>its drain terminal will be</p>
<blockquote>
<p><code>MM8:d</code>, <code>MM8@2:d</code>, <code>MM8@3:d</code>,
<code>MM8@4:d</code></p>
</blockquote>
<h3 id="dspf-syntax">DSPF Syntax</h3>
<p>DSPF has two sections:</p>
<ul>
<li><p>a <strong>net section</strong></p>
<p>The net section consists of a series of net description blocks. Each
net description block corresponds to a net in the physical design. A net
description block begins with a net statement followed by pins, instance
pins, subnodes, and parasitic resistor/capacitor
(<code>R</code>/<code>C</code>) components that characterize the
electrical behavior of the net.</p></li>
<li><p>an <strong>instance section</strong></p>
<p>The instance section consists of a series of SPICE instance
statements. SPICE instance statements begin with an
<code>X</code>.</p></li>
</ul>
<p>Each file consists of hierarchical cells and interconnects only.</p>
<p>The DSPF format is as generic and as much like SPICE as possible.
While native SPICE statements describe the R/C sections, some non-native
SPICE statements complete the net descriptions. These non-native SPICE
statements start with the notation "*|" to differentiate them from
native SPICE statements. For native SPICE statements, a continuation
line begins with the conventional "+" sign in the first column.</p>
<p>The native SPICE statements used by the DSPF format are listed
below:</p>
<ul>
<li><code>.SUBCKT</code> represents a subcircuit statement.</li>
<li><code>.ENDS</code> represents the end of a subcircuit
statement.</li>
<li><code>R</code> represents a resistor element.</li>
<li><code>C</code> represents a capacitor element.</li>
<li><code>E</code> represents a voltage-controlled voltage sources
element.</li>
<li><code>X</code> represents an instance of a cell;</li>
<li><code>*</code> represents a comment line unless it is
<code>*|</code> or <code>*+</code>.</li>
<li><code>.END</code> is an optional statement that represents the end
of a simulation session</li>
</ul>
<h2 id="spectre-netlist">spectre netlist</h2>
<p><code>hier_delimiter="."</code></p>
<p>Used to set hierarchical delimiter. Length of
<code>hier_delimiter</code> should not be longer than 1, except the
leader escape character</p>
<p><code>spfbusdelim = busdelim_schematic [busdelim_parasitic]</code></p>
<p>This option maps the bus delimiter between schematic netlist and
parasitic file (i.e. DSPF, SPEF, or DPF). The option defines the bus
delimiter in the schematic netlist, and optionally the bus delimiter in
the parasitic file. By default, the bus delimiter of the parasitic file
is taken from the parasitic file header (i.e. <em>|BUSBIT [],
</em>|BUS_BIT [], or *|BUS_DELIMITER []). If the bus delimiter is not
defined in the parasitic file header, you need to specify it by using
the spfbusdelim option in schematic netlist.</p>
<blockquote>
<p>Exampel</p>
<ul>
<li>spfbusdelim=&lt;&gt; - A&lt;1&gt; in the schematic netlist is mapped
to A_1 in the DSPF file, if the bus delimiter header in the DSPF file is
"_".</li>
<li>spfbusdelim=@ [] - A@1 in the schematic netlist is mapped to to A[1]
in the DSPF file (the bus delimiter in DSPF header will be
ignored).</li>
</ul>
</blockquote>
<h2 id="how-to-save-net-voltage-in-dspf">How to Save Net voltage in
DSPF</h2>
<blockquote>
<p>!!! follow the name of net section in DSPF - prepend to top-level
devices in the schematic with <code>X</code></p>
</blockquote>
<p><img src="/2022/04/15/dspf-saveopt/hierbench.drawio.svg"
alt="hierbench.drawio" /></p>
<p>Assume node n1...n4 are named as below in DSPF file (prefix
<code>X</code>)</p>
<blockquote>
<ul>
<li><p>n1</p>
<p>XXosc/zip:1</p></li>
<li><p>n2</p>
<p>XXosc/zip:2</p></li>
<li><p>n3</p>
<p>XXosc/zip:3</p></li>
<li><p>n4</p>
<p>XXosc/zip:4</p></li>
</ul>
</blockquote>
<p>To save these nodes, you can add follow code in <em>Definition
Files</em></p>
<p><em>saveopt.scs</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save Xwrapper.Xvco.XXosc\/zip\:1</span><br><span class="line">save Xwrapper.Xvco.XXosc\/zip\:2</span><br><span class="line">save Xwrapper.Xvco.XXosc\/zip\:3</span><br><span class="line">save Xwrapper.Xvco.XXosc\/zip\:4</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>Escape character <code>\</code> is used for hierarchical pathname
divider <code>/</code> and subnode <code>:</code></p></li>
<li><p>By the way, <code>.</code> is hierarchical delimiter of
Spectre</p></li>
<li><p>Calibre always prepend one <strong>X</strong> to instance name of
schematic in generated DSPF file</p></li>
<li><p>The DSPF design is <em>flatten</em>, the DIVIDER character
indicate the hierarchy</p></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save Xwrapper.Xvco.XXosc\/zip</span><br></pre></td></tr></table></figure>
<p>The above save voltage, however I'm NOT sure which node it save.</p>
<p>To avoid this unsure problem, the MOS terminal may be better choice
to save.</p>
<p>But keep in mind</p>
<ul>
<li>OD resistance is lumped in the FEOL model</li>
<li>M0OD and above layer resistances are extracted by RC tool</li>
</ul>
<h2 id="how-to-save-current-in-dspf">How to Save Current in DSPF</h2>
<blockquote>
<p>!!! follow the name of instance section of DSPF - prepend to
top-level devices in the schematic with <code>XX</code></p>
</blockquote>
<p>MOS in schematic: <code>Xsupply.M4</code></p>
<p>MOS related information in DSPF (prefix <code>XX</code> in instance
section):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">// net section</span><br><span class="line">*|I XXsupply/MM4:d XXsupply/MM4 d B 0.0 </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">//instance section</span><br><span class="line">XXXsupply/MM4 XXsupply/MM4:d XXsupply/MM4:g XXsupply/MM4:s XXsupply/MM4:b pch_svt_mac</span><br><span class="line">+ L=... W=... nfin=...</span><br><span class="line">+ ...</span><br></pre></td></tr></table></figure>
<p>To save drain current:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save Xvco.XXXsupply\/MM4:d</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;instName&gt;</code> in
<code>*|I &lt;instPinName&gt; &lt;instName&gt; &lt;pinName&gt; &lt;pinType&gt;&lt;pinCap&gt; &#123;&lt;coord&gt;?&#125;</code>
which has prefix <code>X</code> corresponding to schematic is
<strong>NOT </strong> the instance name in DSPF. The instance name is in
<strong>instance section</strong> and has prefix <code>XX</code></p>
</blockquote>
<p><img src="/2022/04/15/dspf-saveopt/image-20220417010807592.png"
alt="image-20220417010807592" /></p>
<p><img src="/2022/04/15/dspf-saveopt/image-20220417010919588.png"
alt="image-20220417010919588" /></p>
<blockquote>
<p>!!! Only work for MOS terminal current. Fail to apply to block
pin</p>
</blockquote>
<h2 id="thinking-about-voltage-and-current-save">Thinking about voltage
and current save</h2>
<ul>
<li>MOS device always prepend with <code>M</code></li>
<li>To save <strong>net voltage</strong>, take account of the prefix
<code>X</code> of top-level device</li>
<li>To save <strong>MOS terminal</strong>, take account of the prefix
<code>XX</code> of top-level device</li>
</ul>
<blockquote>
<p>Post-layout netlists are created by layout extraction tools - Mentor
Calibre</p>
</blockquote>
<h2 id="differences-between-dspf-and-schematic-names">Differences
Between DSPF and Schematic Names</h2>
<p><img src="/2022/04/15/dspf-saveopt/image-20220416201019986.png"
alt="image-20220416201019986" /></p>
<blockquote>
<ul>
<li>MOS Terminal Mismatch ( ‘s’ vs ‘1’)
<ul>
<li>Schematic: number '1' ,'2', '3','4'</li>
<li>DSPF: 'd', 'g', 's','b'</li>
</ul></li>
</ul>
</blockquote>
<h2 id="simrc-file">.simrc file</h2>
<p>If DSPF files show such differences, you can set options in the
<strong>.simrc</strong> file to <strong>update the save statement in the
netlist</strong> so that the device names match with those in the DSPF
file</p>
<p>Additionally, <code>dspf_include</code> reads all the DSPF lines
starting with <strong>* (<em>|NET, </em>|I, *|P,*|S)</strong>, while
<code>include</code> considers all related lines as comments.</p>
<p>Only verified to DSPF output of Mentor Calibre</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ensure that the netlist is recreated each time</span><br><span class="line">nlReNetlistAll=t</span><br><span class="line"></span><br><span class="line">dspfFileEnvOptions = &#x27;(</span><br><span class="line">        nil</span><br><span class="line">        spfFileNameMappingFormat &quot;cdl“</span><br><span class="line">        spfFileTermDelimiter “:”</span><br><span class="line">        spfFileHierDelimiter “/”</span><br><span class="line">        spfFileFingerDelimiter “@”</span><br><span class="line">        spfFileNetMapping “mixed”</span><br><span class="line">        spfFileTerminalMapping “lower”</span><br><span class="line">        spfFileAddPrefixToDevice t</span><br><span class="line">        spfFileAddContextSensitivePrefix t</span><br><span class="line">        spfFileDeviceDefaultPrefix “X”</span><br><span class="line">        spfFileDevicePrefixForTermCurrent “X”</span><br><span class="line">        spfFileDevicePrefixForOppoints “X“</span><br><span class="line">        </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>spfFileDevicePrefixForTermCurrent</code> and
<code>spfFileDevicePrefixForOppoints</code> are applicable to MOS
devices only.</p>
</blockquote>
<p><img src="/2022/04/15/dspf-saveopt/image-20220418113416484.png"
alt="image-20220418113416484" /></p>
<blockquote>
<p>Both <code>@</code> and <code>__</code> have been observed as Finger
Delimiter in single DSPF . wired...</p>
</blockquote>
<h2 id="signal-name-saved-using-wildcard-operator">signal name saved
using wildcard operator</h2>
<p>How to find the signal name saved using wildcard operator with save
statement in spectre?</p>
<h3 id="method-1">method 1</h3>
<p>From ADE L or ADE XL Test Editor, you can use menu <em>Simulation →
Options → Analog→ Miscellaneous → Addition arguments
field:<code>dump_wildcard_info=yes</code></em></p>
<h3 id="method-2">method 2</h3>
<p>add below in netlist file or <em>Simulation Files → Definition
Files:<code>saveopt.scs</code></em></p>
<p><em>saveopt.scs</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wcOption options dump_wildcard_info=yes</span><br></pre></td></tr></table></figure>
<h3 id="saved-file">saved file</h3>
<p>After running simulation, saved wildcard summary is save into file
<code>&lt;netlist_file_name&gt;.wildcard.out*</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wildcard match summary:</span><br><span class="line"></span><br><span class="line">save * nodes: 68</span><br><span class="line">    0</span><br><span class="line">    vdd!</span><br><span class="line">    I0.net10</span><br><span class="line">    I0.net15</span><br><span class="line">    I0.I8.net30</span><br></pre></td></tr></table></figure>
<h2
id="save-and-plot-terminal-voltage-in-ade-explorer-and-assembler">Save
and Plot terminal voltage in ADE Explorer and Assembler</h2>
<p><strong>.cdsinit</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">envSetVal(&quot;auCore.selection&quot; &quot;terminalSelectionType&quot; &#x27;cyclic &quot;current&quot;)</span><br></pre></td></tr></table></figure>
<p>Available options are <strong>current</strong>,
<strong>voltage</strong>, <strong>both</strong> or
<strong>prompt</strong> and the default is current which matches the
default behavior in previous releases.</p>
<ul>
<li>The schematic will have an <strong>ellipse</strong> annotation where
a current probe has been saved,</li>
<li>a <strong>V</strong> annotation for a voltage probe,</li>
<li>and both annotations for both.</li>
</ul>
<blockquote>
<p>NOTE: Starting with IC 6.1.8 ISR5, you can now set this from
Options-&gt;Plotting/Printing</p>
</blockquote>
<p><img src="/2022/04/15/dspf-saveopt/image-20220415204157341.png"
alt="image-20220415204157341" /></p>
<h2 id="interpreting-_noxref-entries">Interpreting _noxref Entries</h2>
<blockquote>
<p>You enable gate recognition in the Calibre nmLVS-H tool. Normally,
the <strong>_noxref</strong> names are internal to the gate</p>
</blockquote>
<p><img src="/2022/04/15/dspf-saveopt/image-20220416125348491.png"
alt="image-20220416125348491" /></p>
<p><img src="/2022/04/15/dspf-saveopt/image-20220416125416504.png"
alt="image-20220416125416504" /></p>
<h2
id="saving-net-with-hierarchy-delimiter-and-colon-in-net-name-gives-warning-spectre-8282-during-simulation">Saving
net with hierarchy delimiter and colon (:) in net name gives WARNING
(SPECTRE-8282) during simulation</h2>
<h3 id="problem">Problem</h3>
<p>I am running simulation using an spf/spef file which has a net name
definition as shown in the below example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// input.scs</span><br><span class="line">simulator lang=spice</span><br><span class="line">.subckt pi_rc a z</span><br><span class="line">r1 a x1a 1k</span><br><span class="line">r2 x1a x1/x1:DRN 1k</span><br><span class="line">cb x1/x1:DRN z 200f</span><br><span class="line">.ends</span><br><span class="line"></span><br><span class="line">xpi1 in 0 pi_rc</span><br><span class="line">vdd in 0 pwl (0 0 1n 0 1.1n 10)</span><br><span class="line"></span><br><span class="line">simulator lang=spectre</span><br><span class="line">myopt options hier_ambiguity=lower</span><br><span class="line">tran tran stop=2u</span><br><span class="line"></span><br><span class="line">save xpi1.x1\/x1:DRN</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>The net name is x1/x1:DRN. During the simulation, the following
warning is reported:</p>
<p>Warning from spectre during initial setup. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WARNING (SPECTRE-8282): `xpi1.x1/x1&#x27; is not a device or subcircuit instance name.</span><br><span class="line">WARNING (SPECTRE-8287): Ignoring invalid item `xpi1.x1/x1:DRN&#x27; in save statement.</span><br></pre></td></tr></table></figure></p>
<p>How can I save this net for plotting and measurements?</p>
<h3 id="solution">Solution</h3>
<p><strong>The colon (:) in the save statement specifies terminal
current</strong>. So, the save statement used above is for terminal
current and, hence, the warning messages are reported.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save xpi1.x1\/x1:DRN</span><br></pre></td></tr></table></figure>
<p>You need to modify the save statement as below: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save xpi1.x1\/x1\:DRN</span><br></pre></td></tr></table></figure></p>
<p>Now, run the simulation and the issue will be resolved.</p>
<h2 id="dspf-r-vs-rcc">DSPF r vs rcc</h2>
<p><strong>rcc</strong></p>
<p><img src="/2022/04/15/dspf-saveopt/image-20220618131626913.png"
alt="image-20220618131626913" /></p>
<p><strong>c</strong></p>
<p><img src="/2022/04/15/dspf-saveopt/image-20220618131649065.png"
alt="image-20220618131649065" /></p>
<p>only <strong>c</strong> dspf give the <strong>lumped
capacitance</strong></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>split pins in dspf_emir</title>
    <url>/2023/04/04/dspf-split-pins-emir/</url>
    <content><![CDATA[<h3 id="dspf-extract-using-starrc">dspf extract using starrc</h3>
<p>multiple label and rectangle in vssa net</p>
<p><img
src="/2023/04/04/dspf-split-pins-emir/image-20230405003705354.png"
alt="image-20230405003705354" /></p>
<ul>
<li><p>general dspf</p>
<p><code>SHORT_PINS: YES</code></p>
<p><img
src="/2023/04/04/dspf-split-pins-emir/image-20230405002824842.png"
alt="image-20230405002824842" /></p>
<blockquote>
<p>other pin are short together</p>
</blockquote></li>
<li><p>dspf for emir analysis</p></li>
</ul>
<p><img
src="/2023/04/04/dspf-split-pins-emir/image-20230405000013461.png"
alt="image-20230405000013461" /></p>
<p><img
src="/2023/04/04/dspf-split-pins-emir/image-20230405001944418.png"
alt="image-20230405001944418" /></p>
<p><img
src="/2023/04/04/dspf-split-pins-emir/image-20230405230611522.png"
alt="image-20230405230611522" /></p>
<blockquote>
<p>It seems that dspf_emir <strong>don't</strong> contain the
<em>rectangle pin</em> information.</p>
<p>only <strong>label</strong> is necessary</p>
</blockquote>
<table style="width:100%;">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 26%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>setup</th>
<th></th>
<th></th>
<th>spectre result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>netlist type</strong></td>
<td><strong>dspf option</strong></td>
<td><strong>emir analysis</strong></td>
<td></td>
</tr>
<tr class="even">
<td>dspf</td>
<td>/</td>
<td>disable</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>dspf_emir</td>
<td>/</td>
<td>disable</td>
<td>✗</td>
</tr>
<tr class="even">
<td>dspf_emir</td>
<td>=shortPins=”yes”</td>
<td>disable</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>dspf_emir</td>
<td>=shortPins=”no”</td>
<td>disable</td>
<td>✗</td>
</tr>
<tr class="even">
<td>dspf_emir</td>
<td>/</td>
<td>enable</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>dspf_emir</td>
<td>=shortPins=”yes”</td>
<td>enable</td>
<td>✓</td>
</tr>
<tr class="even">
<td>dspf_emir</td>
<td>=shortPins=”no”</td>
<td>enable</td>
<td>✓</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>shortPins=”yes”</strong> is preferred default option for
dspf_emir, which has <strong>split pins</strong></p>
</blockquote>
<p><img
src="/2023/04/04/dspf-split-pins-emir/image-20230405005151550.png"
alt="image-20230405005151550" /></p>
<h3 id="dspf-syntax">DSPF Syntax</h3>
<ul>
<li><p><pin_def>::=*<strong>|P <pin_element>?</strong> <pin_element>
describes pins in the net. Multiple pin descriptions can be listed in
one line.</p></li>
<li><p><pin_element>::=(<pinName> <pinType> <pinCap> {<coord>}?)
<pinName> represents the name of the pin. <pinType> represents the type
of the pin. It can be any of the following: I (Input), O (Output),</p>
<p>​ B (Bidirectional), X (don’t care), S (Switch), and J (Jumper). ​
<pinCap> represents the capacitance value associated with the pin. ​
<coord> is optional. It represents the location of the pin. Multiple pin
locations are allowed</p></li>
</ul>
<h4 id="split-pins">split pins</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*|P (avss_1 O 0 207.7555 59.9170)</span><br><span class="line">*|P (avss_10 O 0 181.1610 151.1130)</span><br><span class="line">*|P (avss_11 O 0 186.6330 151.1130)</span><br><span class="line">*|P (avss_12 O 0 192.1050 151.1130)</span><br><span class="line">*|P (avss_13 O 0 197.5770 151.1130)</span><br></pre></td></tr></table></figure>
<h3 id="reference">reference</h3>
<p>Article (20467964) Title: Difference in result on running Spectre APS
with EMIR and without EMIR analysis URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V00000679GRUAY">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V00000679GRUAY</a></p>
<p>StarRC User Guide and Command Reference Version O-2018.06, June
2018</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>DTFT &amp; DFT</title>
    <url>/2023/05/27/dtft-dft/</url>
    <content><![CDATA[<h2 id="sampling-theorem">sampling theorem</h2>
<h3 id="time-sampling-theorem">time-sampling theorem</h3>
<p><img src="/2023/05/27/dtft-dft/image-20230527154334304.png"
alt="image-20230527154334304" /></p>
<p>The spectrum <span
class="math inline">\(\overline{X}(\omega)\)</span> consists of <span
class="math inline">\(X(\omega)\)</span> repeating periodically with
period <span class="math inline">\(\omega _s = 2\pi/T\)</span> rad/s, or
<span class="math inline">\(f_s = 1/T\)</span> Hz <span
class="math display">\[
\overline{X}(\omega) = \frac{1}{T}\sum_{n=-\infty}^{\infty}X(\omega -
n\omega _s)
\]</span></p>
<h3 id="spectral-sampling-theorem">spectral-sampling theorem</h3>
<p><img src="/2023/05/27/dtft-dft/image-20230527155436179.png"
alt="image-20230527155436179" /></p>
<p>The Fourier transform <span class="math inline">\(X(\omega)\)</span>
of a <strong>timelimited</strong> signal <span
class="math inline">\(x(t)\)</span> is given by <span
class="math display">\[
X(\omega)=\int_{-\infty}^{\infty}x(t)e^{-j\omega t}dt =
\int_0^{\tau}x(t)e^{-j\omega t}dt
\]</span> <span class="math inline">\(x_{T_0}(t)\)</span>, a
<strong>periodic</strong> signal formed by repeating <span
class="math inline">\(x(t)\)</span> every <span
class="math inline">\(T_0\)</span> seconds (<span
class="math inline">\(T_0 \gt \tau\)</span>), which can be expressed by
the exponential Fourier series <span class="math display">\[
x_{T_0}(t) = \sum_{-\infty}^{\infty}D_ne^{jn\omega _0t}
\]</span> where <span class="math inline">\(\omega_0 =
\frac{2\pi}{T_0}\)</span></p>
<p>And <span class="math inline">\(D_n\)</span> can be obtained by
(assuming <span class="math inline">\(T_0 \gt \tau\)</span>) <span
class="math display">\[
D_n = \frac{1}{T_0}\int_0^{T_0}x(t)e^{-jn\omega _0 t}dt =
\frac{1}{T_0}\int_0^{\tau}x(t)e^{-jn\omega _0 t}dt
\]</span> Then it follows that <span class="math display">\[
D_n = \frac{1}{T_0}X(n\omega _0)
\]</span> This result indicates that the <em>coefficients of the Fourier
series</em> for <span class="math inline">\(x_{T_0}(t)\)</span> are
<span class="math inline">\((1/T_0)\)</span> times the <em>sample values
of the spectrum</em> <span class="math inline">\(X(\omega)\)</span>
taken at intervals of <span class="math inline">\(\omega
_0\)</span>.</p>
<h4 id="spectral-interpolation">spectral interpolation</h4>
<p>Consider a signal <em>timelimited</em> to <span
class="math inline">\(\tau\)</span> seconds and <em>centered at</em>
<span class="math inline">\(T_c\)</span>. The spectrum <span
class="math inline">\(X(\omega)\)</span> of <span
class="math inline">\(x(t)\)</span> can be reconstructed from the
samples of <span class="math inline">\(X(\omega)\)</span> and the
<strong>spectral interpolation formula</strong> is obtained as <span
class="math display">\[
X(\omega) = \sum_{-\infty}^{\infty}X(n\omega _0)
\text{sinc}\left(\frac{\omega T_0}{2}-n\pi\right)e^{-j(\omega - n\omega
_0)T_c}
\]</span> step by step:</p>
<ol type="1">
<li><p>The Fourier transform of <span
class="math inline">\(x_{T_0}(t)\)</span> is <span
class="math display">\[
2\pi\sum_n D_n \delta(\omega - n\omega_0) = \frac{2\pi}{T_0}\sum_n
X(n\omega_0) \delta(\omega - n\omega_0)
\]</span></p></li>
<li><p>The Fourier transform of rectangular pulse <span
class="math inline">\(\text{rect}((t-T_c)/T_0)\)</span> centered at
<span class="math inline">\(T_c\)</span> and duration <span
class="math inline">\(T_0\)</span> <span class="math display">\[
T_0 \text{sinc}(\omega T_0/2)e^{-j\omega T_c}
\]</span></p></li>
<li><p>Hence, <span class="math inline">\(X(\omega)\)</span> is <span
class="math inline">\(1/2\pi\)</span> times the <em>convolution</em> of
these two Fourier</p></li>
</ol>
<h2 id="numerical-computation-of-the-fourier-transform">Numerical
Computation of The Fourier Transform</h2>
<h3 id="finite-length-signal-periodic-signal">Finite-length signal &amp;
periodic signal</h3>
<p><img src="/2023/05/27/dtft-dft/image-20230528112723460.png"
alt="image-20230528112723460" /></p>
<blockquote>
<p><span class="math display">\[
x[n] = \left\{ \begin{array}{cl}
\tilde{x}[n] &amp; : \ 0 \leq n \leq N-1 \\
0 &amp; : \text{otherwise}
\end{array} \right.
\]</span></p>
</blockquote>
<p>Consider a finite-length signal <span
class="math inline">\(x[n]\)</span> such that <span
class="math inline">\(x[n] = 0\)</span> except in the interval <span
class="math inline">\(0 \leq n \leq N − 1\)</span>, and consider the
convolution of <span class="math inline">\(x[n]\)</span> with the
periodic impulse train <span
class="math inline">\(\tilde{p}[n]\)</span>: <span
class="math display">\[
\tilde{x}[n] = x[n]*\tilde{p}[n] = x[n]*
\sum_{r=-\infty}^{\infty}\delta[n-rN] = \sum_{r=-\infty}^{\infty}x[n-rN]
\]</span> Thanks to Fourier Transform <em>convolution property</em>, the
DTFT of <span class="math inline">\(\tilde{x}[n]\)</span> is
obtained</p>
<p><span class="math display">\[\begin{align}
\tilde{X}(e^{j\omega}) &amp;= X(e^{j\omega}) \tilde{P}(e^{j\omega})\\
&amp;= X(e^{j\omega})
\sum_{k=-\infty}^{\infty}\frac{2\pi}{N}\delta\left(\omega - \frac{2\pi
k}{N}\right) \\
&amp; =
\sum_{k=-\infty}^{\infty}\frac{2\pi}{N}X(e^{j(2\pi/N)k})\delta\left(\omega
- \frac{2\pi k}{N}\right)
\end{align}\]</span></p>
<p>⭐ we conclude the DFS coefficients of <span
class="math inline">\(\tilde{x}[n]\)</span> is <span
class="math display">\[
\tilde{X}[k] = X(e^{j\omega})|_{\omega=2\pi k/N}
\]</span> where <span class="math inline">\(\tilde{X}[k]\)</span> is
<strong>DFS coefficients</strong> of <span
class="math inline">\(\tilde{X}[k]\)</span>;</p>
<p><span class="math inline">\(X(e^{j\omega})|_{\omega=2\pi
k/N}\)</span> is samples of the <strong>DTFT</strong> of the
<em>finite-length sequence</em> <span
class="math inline">\(x[n]\)</span></p>
<h3 id="sampling-the-fourier-transform">sampling the Fourier
transform</h3>
<p>Assuming an <em>aperiodic sequence</em> with Fourier transform <span
class="math inline">\(X(e^{j\omega})\)</span>, the <strong>sequences of
samples</strong> <span class="math inline">\(\tilde{X}[k] =
X(e^{j\omega})|_{\omega=2\pi k/N}\)</span> being periodic with period
<span class="math inline">\(N\)</span> could be the <strong>sequence of
<em>DFS</em> coefficients</strong> of sequence <span
class="math inline">\(\tilde{x}[n]\)</span></p>
<p>⭐To obtain <span class="math inline">\(\tilde{x}[n]\)</span>,
substitute <span class="math inline">\(\tilde{X}[k]\)</span> into DFS
synthesis equation <span class="math display">\[
\tilde{x}[n] =x[n]*\sum_{r=-\infty}^{\infty}\delta[n-rN] =
\sum_{r=-\infty}^{\infty}x[n-rN]
\]</span> Thus, the periodic sequence <span
class="math inline">\(\tilde{x}[n]\)</span>, corresponding to <span
class="math inline">\(\tilde{X}[k]\)</span> obtained by sampling <span
class="math inline">\(X(e^{j\omega})\)</span>, is formed from <span
class="math inline">\(x[n]\)</span> by <em>adding together an infinite
number of shifted replicas of <span
class="math inline">\(x[n]\)</span></em>.</p>
<h3 id="discrete-fourier-transform-dft">Discrete Fourier Transform
(DFT)</h3>
<blockquote>
<p>When the <strong>Fourier series</strong> is used in this way to
represent <em>finite-length sequences</em>, it is called the discrete
Fourier transform or <strong>DFT</strong></p>
<p>In developing, discussing, and applying the DFT, it is always
important to remember that the representation through <em>samples of the
Fourier transform</em> is in effect <em>a representation of the
finite-duration sequence by a periodic sequence</em>, <strong>one period
of which is the finite duration sequence that we wish to
represent</strong></p>
</blockquote>
<ul>
<li><p>Considering a <em>finite-length</em> sequence <span
class="math inline">\(x[n]\)</span> of length <span
class="math inline">\(N\)</span> samples such that <span
class="math inline">\(x[n]=0\)</span> outside the range <span
class="math inline">\(0\leq n \leq N-1\)</span>.</p>
<p>To each finite-length sequence of length <span
class="math inline">\(N\)</span>, we can always associate a periodic
sequence <span class="math inline">\(\tilde{x}[n]\)</span></p>
<p><span class="math inline">\(\tilde{x}[n] =
\sum_{r=-\infty}^{\infty}x[n-rN]\)</span></p></li>
<li><p>Since <span class="math inline">\(x[n]\)</span> is assumed to
have finite length <span class="math inline">\(N\)</span>, there is
<em>no overlap</em> between the terms <span class="math inline">\(x[n −
rN]\)</span> for different values of <span
class="math inline">\(r\)</span>.</p>
<p><span class="math inline">\(\tilde{x}[n] = x[(n \; \text{modulo}\;
N)]\)</span></p></li>
</ul>
<p>As discussed the sequence of <em>DFS coefficients</em> <span
class="math inline">\(\tilde{X}[k]\)</span> of <em>the periodic
sequence</em> <span class="math inline">\(\tilde{x}[n]\)</span> is
itself a periodic sequence with <em>period</em> <span
class="math inline">\(N\)</span>.</p>
<p>To maintain a duality between the time and frequency domains, This
finite-duration sequence, <span class="math inline">\(X [k]\)</span>,
one period of <span class="math inline">\(\tilde{X}[k]\)</span> will be
referred to as the <strong>DFT</strong> <span class="math display">\[
X[k] = \left\{ \begin{array}{cl}
\tilde{X}[k] &amp; : \ 0 \leq k \leq N-1 \\
0 &amp; : \ \text{otherwise}
\end{array} \right.
\]</span> and <span class="math display">\[
\tilde{X}[k] = X[(k \; \text{modulo}\; N)]
\]</span> <span class="math inline">\(\tilde{X}[k]\)</span> and <span
class="math inline">\(\tilde{x}[n]\)</span> are related by</p>
<p><span class="math display">\[\begin{align}
\tilde{X}[k] &amp;= \sum_{n=0}^{N-1}\tilde{x}[n]W_N^{kn} \\
\tilde{x}[n] &amp;=\frac{1}{N} \sum_{k=0}^{N-1}\tilde{X}[k]W_N^{-kn}
\end{align}\]</span></p>
<p>where <span class="math inline">\(W_N = e^{-j(2\pi/N)}\)</span></p>
<p>DFT analysis and synthesis equations , <span
class="math inline">\(X[k]\)</span> and <span
class="math inline">\(x[n]\)</span> are related by</p>
<p>⭐ Analysis equation: <span class="math display">\[
X[k] = \left\{ \begin{array}{cl}
\sum_{n=0}^{N-1}x[n]W_N^{kn} &amp; : \ 0 \leq k \leq N-1 \\
0 &amp; : \ \text{otherwise}
\end{array} \right.
\]</span> ⭐ Synthesis equation: <span class="math display">\[
x[n] = \left\{ \begin{array}{cl}
\frac{1}{N} \sum_{k=0}^{N-1}X[k]W_N^{-kn} &amp; : \ 0 \leq n \leq N-1 \\
0 &amp; : \ \text{otherwise}
\end{array} \right.
\]</span></p>
<blockquote>
<p>That is, the fact that <span class="math inline">\(X[k]=0\)</span>
for <span class="math inline">\(k\)</span> outside the interval <span
class="math inline">\(0 \leq k \leq N −1\)</span> and that <span
class="math inline">\(x[n] = 0\)</span> for <span
class="math inline">\(n\)</span> outside the interval <span
class="math inline">\(0 \leq n \leq N − 1\)</span> is implied, but not
always stated explicitly.</p>
</blockquote>
<blockquote>
<p>The inherent periodicity is always present. Sometimes, it causes us
difficulty, and sometimes we can exploit it, but to totally ignore it is
to invite trouble.</p>
<p>In defining the DFT representation,</p>
<ul>
<li>we are simply recognizing that we are interested in values of <span
class="math inline">\(x[n]\)</span> only in the interval <span
class="math inline">\(0 \leq n \leq N-1\)</span>, because <span
class="math inline">\(x[n]\)</span> is really zero outside that
interval,</li>
<li>and we are interested in values of <span
class="math inline">\(X[k]\)</span> only in the interval <span
class="math inline">\(0 \leq k \leq N-1\)</span> because these are the
only values needed to reconstruct <span
class="math inline">\(x[n]\)</span></li>
</ul>
</blockquote>
<h3 id="multiplication-property-modulation-property">Multiplication
Property (Modulation Property)</h3>
<p><span class="math display">\[
x_1(t)x_2(t)\overset{FT}{\longrightarrow}\frac{1}{2\pi}X_1(\omega)*X_2(\omega)
\]</span></p>
<p>Then sampled signal fourier transform is <span
class="math display">\[\begin{align}
X_s(\omega) &amp;= \frac{1}{2\pi}X_{\delta}(\omega)*X(\omega) \\
&amp;= \frac{1}{T} \left(\sum_{k\in \mathbb{Z}}\delta(\omega -
k\frac{2\pi}{T})\right) * X(\omega)
\end{align}\]</span></p>
<p><a
href="https://web.stanford.edu/class/ee179/lectures/notes11.pdf">Lecture
11: Sampling and Pulse Modulation</a></p>
<p><img src="/2023/05/27/dtft-dft/image-20220520221108500.png"
alt="image-20220520221108500" /></p>
<h3 id="multiplication-property-convolution-property">multiplication
property &amp; convolution property</h3>
<p>Because a digital computer can work only with <em>discrete data</em>
(sequence of numbers), moreover, it can compute <span
class="math inline">\(X(\omega)\)</span> only at some <em>discrete
values</em> of <span class="math inline">\(\omega\)</span> (samples of
<span class="math inline">\(X(\omega)\)</span>).</p>
<p><img src="/2023/05/27/dtft-dft/image-20230527181614818.png"
alt="image-20230527181614818" /></p>
<ul>
<li><p><strong>{ (a), (b) } -&gt; { (c), (d) }</strong>:</p>
<p>with CT multiplication property, <span
class="math inline">\(X(\omega) = T
\overline{X}(\omega)\)</span></p></li>
<li><p><strong>{ (c), (d) } -&gt; { (e), (f) }</strong>:</p>
<p>with DT convolution property, <span class="math inline">\(X_N(\omega)
= \frac{2\pi}{N}\overline{X}(\omega)\)</span></p></li>
<li><p>Assuming <span class="math inline">\(x_{T0}(t)
=\sum_{r=-\infty}^{\infty}x(t-rT_0)\)</span>, formed by adding together
an infinite number of shifted replicas of <span
class="math inline">\(x(t)\)</span>: with CT convolution property, <span
class="math inline">\(X_{T0}(\omega)=X(\omega)\frac{2\pi}{T_0}=\overline{X}(\omega)\frac{2\pi
T}{T_0}\)</span> which is <span
class="math inline">\(X_{T0}(\omega)=\frac{2\pi}{N}\overline{X}(\omega)\)</span></p></li>
</ul>
<p><span class="math inline">\(X_N(\omega) = X_{T0}(\omega)\)</span>
indicates that finite-length discrete-time sequence provide Fourier
Transform of continuous-time periodic signal</p>
<p>⭐when a signal <span class="math inline">\(x(t)\)</span> is sampled
and then periodically repeated, the corresponding spectrum is also
sampled and periodically repeated</p>
<h2 id="zero-padding">zero-padding</h2>
<h3 id="the-number-of-zero-padding">The number of zero-padding</h3>
<p>When you tack on a bunch of zeros to a sequence and then compute the
<em>DFT</em>, you're just getting <strong>more and more samples</strong>
of the <em>DTFT</em> of the original sequence.</p>
<p>Let's look at a simple rectangular pulse, <span
class="math inline">\(x[n]=1\)</span> for <span class="math inline">\(0
\leq n \lt M\)</span>. The DTFT of <span
class="math inline">\(x[n]\)</span> is: <span class="math display">\[
X(\omega) = \frac{\sin(\omega M/2)}{\sin(\omega/2)} e^{-j \omega
(M-1)/2}
\]</span> Let's plot <span class="math inline">\(|X(\omega)|\)</span>
for <span class="math inline">\(M=8\)</span> over a couple of
periods:</p>
<p><img src="/2023/05/27/dtft-dft/image-20230527210507334.png"
alt="image-20230527210507334" /></p>
<p>Here's the <em>P</em>-point DFT of our 8-point rectangular pulse:</p>
<ul>
<li><p>8-point DFT</p>
<p><img src="/2023/05/27/dtft-dft/image-20230526231448884.png"
alt="image-20230526231448884" /></p></li>
<li><p>16-point DFT</p>
<p><img src="/2023/05/27/dtft-dft/image-20230526231531076.png"
alt="image-20230526231531076" /></p></li>
<li><p>32-point DFT</p>
<p><img src="/2023/05/27/dtft-dft/image-20230526231633067.png"
alt="image-20230526231633067" /></p></li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"></span><br><span class="line">M = <span class="number">8</span>;</span><br><span class="line">w = <span class="built_in">linspace</span>(<span class="number">-2</span>*<span class="built_in">pi</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">800</span>);</span><br><span class="line">X_dtft = (<span class="built_in">sin</span>(w*M/<span class="number">2</span>) ./ <span class="built_in">sin</span>(w/<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span> * w * (M<span class="number">-1</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(w, <span class="built_in">abs</span>(X_dtft))</span><br><span class="line">title(<span class="string">&#x27;DTFT (|X(\omega)|)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">ones</span>(<span class="number">1</span>, M);</span><br><span class="line"></span><br><span class="line"><span class="comment">% P = 8</span></span><br><span class="line">P = <span class="number">8</span>;</span><br><span class="line">X_8pt = fft(x, P);</span><br><span class="line">w_k_8pt = (<span class="number">0</span>:P<span class="number">-1</span>) * (<span class="number">2</span>*<span class="built_in">pi</span>/P);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 16-point dft</span></span><br><span class="line">P = <span class="number">16</span>;</span><br><span class="line">X_16pt = fft(x, P); <span class="comment">% pad 8 point</span></span><br><span class="line">w_k_16pt = (<span class="number">0</span>:P<span class="number">-1</span>) * (<span class="number">2</span>*<span class="built_in">pi</span>/P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 32-point dft</span></span><br><span class="line">P = <span class="number">32</span>;</span><br><span class="line">X_32pt = fft(x, P); <span class="comment">% pad 24 point</span></span><br><span class="line">w_k_32pt = (<span class="number">0</span>:P<span class="number">-1</span>) * (<span class="number">2</span>*<span class="built_in">pi</span>/P);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(w, <span class="built_in">abs</span>(X_dtft))</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(w_k_8pt, <span class="built_in">abs</span>(X_8pt), <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;dtft&#x27;</span>, <span class="string">&#x27;8-point dft&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;8-point dft (without zero-padding)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(w, <span class="built_in">abs</span>(X_dtft))</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(w_k_16pt, <span class="built_in">abs</span>(X_16pt), <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;dtft&#x27;</span>, <span class="string">&#x27;16-point dft with 8 point zero-padding&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;16-point dft&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(w, <span class="built_in">abs</span>(X_dtft))</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(w_k_32pt, <span class="built_in">abs</span>(X_32pt), <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;dtft&#x27;</span>, <span class="string">&#x27;32-point dft&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;32-point dft with 24 point zero-padding&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Zero padding does not improve accuracy or
resolution.</strong></p>
<ul>
<li><p>Zero padding only allows us to look at more samples of that
imperfect reality. It can never reduce the imperfection which caused by
<strong>aliasing</strong>.</p></li>
<li><p>The only way to obtain the detailed signal spectrum with a fine
frequency resolution is to apply more available data samples, that is, a
longer sequence of data.</p></li>
</ul>
<p><img src="/2023/05/27/dtft-dft/image-20230529232357283.png"
alt="image-20230529232357283" /></p>
<p><img src="/2023/05/27/dtft-dft/image-20230529232704566.png"
alt="image-20230529232704566" /></p>
<h3 id="prepend-vs-postpend-vs-both">prepend vs postpend vs both</h3>
<p><em>TODO</em> 📅</p>
<h2 id="reference">reference</h2>
<p>Proakis, J. G., &amp; Manolakis, D. G. (2007). Digital signal
processing (4th ed.). Pearson Prentice Hall.</p>
<p>Tan, &amp; Jiang, J. (2019). Digital signal processing : fundamentals
and applications / Lizhe Tan and Jean Jiang. (Third edition.). Academic
Press.</p>
<p>Steve Eddins, The DFT and the DTFT <a
href="https://blogs.mathworks.com/steve/2010/03/15/the-dft-and-the-dtft-mathjax/?doing_wp_cron=1648269838.4060609340667724609375">https://blogs.mathworks.com/steve/2010/03/15/the-dft-and-the-dtft-mathjax/?doing_wp_cron=1648269838.4060609340667724609375</a></p>
<p>Lathi, B. P., &amp; Green, R. A. (2018). Linear systems and signals
(Third Edition.). Oxford University Press.</p>
<p>Oppenheim, A. V., &amp; Schafer, R. W. (2014). Discrete-time signal
processing (Third ed., Pearson new internat. ed.). Pearson.</p>
<p>Lyons, R. G. (2011). Understanding digital signal processing (3rd
ed.). Prentice Hall.</p>
<p>Dr. Wang Hongwei. FFT Basics and Case Study using Multi-Instrument
[<a
href="https://www.virtins.com/doc/D1002/FFT_Basics_and_Case_Study_using_Multi-Instrument_D1002.pdf">https://www.virtins.com/doc/D1002/FFT_Basics_and_Case_Study_using_Multi-Instrument_D1002.pdf</a>]</p>
<p>Spectral Leakage and Zero-Padding of the Discrete Fourier Transform
[<a
href="https://dspillustrations.com/pages/posts/misc/spectral-leakage-zero-padding-and-frequency-resolution.html">https://dspillustrations.com/pages/posts/misc/spectral-leakage-zero-padding-and-frequency-resolution.html</a>]</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>verilog-mode.el</title>
    <url>/2022/05/13/emacs-verilog-mode/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">emacs --no-site-file --load path/to/verilog-mode.el --batch filename.v -f verilog-auto-save-compile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CAUTION: <em>filename.v</em> is <strong>overwrite</strong> by
command</p>
</blockquote>
<h2 id="verilog-mode.el">verilog-mode.el</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*AUTOINPUT*/</span></span><br><span class="line"><span class="comment">/*AUTOWIRE*/</span></span><br><span class="line"><span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">/*AUTO_TEMPLATE*/</span></span><br></pre></td></tr></table></figure>
<h3 id="f-verilog-batch-auto"><code>-f verilog-batch-auto</code></h3>
<blockquote>
<p>For use with <code>--batch</code>, perform automatic expansions as a
stand-alone tool. This sets up the appropriate Verilog mode environment,
updates automatics with M-x verilog-auto on all command-line files, and
saves the buffers. For proper results, multiple filenames need to be
passed on the command line in bottom-up order.</p>
</blockquote>
<h3
id="f-verilog-auto-save-compile"><code>-f verilog-auto-save-compile</code></h3>
<blockquote>
<p>Update automatics with M-x verilog-auto, save the buffer, and
<em>compile</em></p>
</blockquote>
<h2 id="emacs">Emacs</h2>
<h3 id="no-site-file"><code>--no-site-file</code></h3>
<p>Another file for site-customization is <code>site-start.el</code>.
Emacs loads this <em>before</em> the user's init file
(<code>.emacs</code>, <code>.emacs.el</code> or
<code>.emacs.d/.emacs.d</code>). You can inhibit the loading of this
file with the option <code>--no-site-file</code></p>
<h3 id="batch"><code>--batch</code></h3>
<p>The command-line option <code>--batch</code> causes Emacs to run
noninteractively. The idea is that you specify Lisp programs to run;
when they are finished, Emacs should exit.</p>
<p><code>--load, -l FILE</code>, load Emacs Lisp FILE using the load
function;</p>
<p><code>--funcall, -f FUNC</code>, call Emacs Lisp function FUNC with
no arguments</p>
<h3 id="f-func"><code>-f FUNC</code></h3>
<p><code>--funcall, -f FUNC</code>, call Emacs Lisp function FUNC with
no arguments</p>
<h3 id="load--l-file"><code>--load, -l FILE</code></h3>
<p><code>--load, -l FILE</code>, load Emacs Lisp FILE using the load
function</p>
<blockquote>
<p>Verilog-mode is a standard part of GNU Emacs as of 22.2.</p>
</blockquote>
<h2 id="multiple-directories">multiple directories</h2>
<p><strong>AUTOINST</strong> only search in the file's directory
default.</p>
<p>You can append below <code>verilog-library-directories</code> for
multiple directories search</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Local Variables:</span><br><span class="line">// verilog-library-directories:(&quot;.&quot; &quot;subdir&quot; &quot;subdir2&quot;)</span><br><span class="line">// End:</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>Emacs Online Documentation <a
href="https://doc.endlessparentheses.com/">https://doc.endlessparentheses.com/</a></p>
<p>Emacs verilog-mode 的使用 URL: <a
href="https://www.wenhui.space/docs/02-emacs/verilog_mode_useguide/">https://www.wenhui.space/docs/02-emacs/verilog_mode_useguide/</a></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>EMIR via Voltus-Fi</title>
    <url>/2022/02/23/emir-voltus-fi/</url>
    <content><![CDATA[<h2 id="general-terminology">general terminology</h2>
<h3 id="dc-related">DC related</h3>
<p><strong>Imax</strong> in T*'s DRC document is the maximum allowed
<strong>DC current</strong>, which depends on <em>Length and Width</em>
only</p>
<p><strong>Iavg</strong> is the average value of the current, which is
the effective <em>DC current</em>. Therefore, <strong>Iavg
rules</strong> are <strong>identical</strong> to <strong>Imax</strong>
rules <span class="math display">\[
I_{\text{avg}}=\frac{\int_0^\tau I(t)dt}{\tau}
\]</span> Similarly, <strong>Iabsavg rules</strong> are
<strong>identical</strong> to <strong>Imax</strong> rules, too <span
class="math display">\[
I_{\text{AbsAvg}}=\frac{\int_0^\tau |I(t)|dt}{\tau}
\]</span></p>
<h3 id="rms">rms</h3>
<p><strong>Irms</strong> is the root-mean-square of the current through
a metal line, which depends <strong>w(in um)</strong>, the <em>drawn
width</em> of the metal line and <span class="math inline">\(\Delta
T\)</span>, the temperature rise due to Joule heating. <span
class="math display">\[
I_{\text{rms}}=\left[\frac{\int_0^\tau I(t)^2dt}{\tau} \right]^{1/2}
\]</span></p>
<h3 id="peak-current">peak current</h3>
<p><strong>Ipeak</strong> in T*'s DRC document is the current at which a
metal line undergoes excessive Joule heating and can begin to melt.
<strong>Ipeak</strong> is corresponding to
<code>EM Current Analysis: max</code> in Voltus-Fi Analysis Setup <span
class="math display">\[
I_{\text{peak}}=\max(|I(t)|)
\]</span> The limit for the peak current is <span
class="math display">\[
I_{\text{peak,limit}}=\frac{I_{\text{peak\_DC}}}{\sqrt{r
} }
\]</span> where <strong>r</strong> is the duty ratio</p>
<p>The relationship between <strong>Ipeak</strong> and
<strong>Ipeak_DC</strong> is merged in DRC document so that there is
only <strong>Ipeak</strong> equation in document</p>
<blockquote>
<p><span class="math inline">\(I_{\text{peak,limit}}\)</span> depends on
<span class="math inline">\(t_D\)</span>, r, width and length</p>
</blockquote>
<p><span class="math display">\[
r=\frac{t_D}{\tau}
\]</span></p>
<p>where <span class="math inline">\(t_D\)</span> is equivalent duration
<span class="math display">\[
t_D =\frac{\int_0^\tau |I(t)|dt}{I_{\text{peak}}}
\]</span> or <span class="math display">\[
r=\frac{I_{\text{AbsAvg}}}{I_{\text{peak}}}
\]</span> <img
src="/2022/02/23/emir-voltus-fi/image-20220729023550943.png"
alt="image-20220729023550943" /></p>
<p>where the drawn width is 1um, r is 0.1</p>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220729023722754.png"
alt="image-20220729023722754" /></p>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220729023319156.png"
alt="image-20220729023319156" /> <span class="math display">\[
9.37*(1-0.004)/\sqrt0.1 = 29.512
\]</span></p>
<h3 id="acpeakpwc">acpeak/pwc</h3>
<p>It's same with <strong>max</strong> EM Current Analysis in
Voltus-Fi</p>
<h3 id="dynamicacpeak"><code>dynamicACPeak</code></h3>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220729023154009.png"
alt="image-20220729023154009" /></p>
<p>This option affect how duty ratio r is computed in <code>max</code>
and <code>acpeak/pwc</code> EM current Analysis</p>
<p>When the <code>dynamicACPeak</code> variable is set to
<strong>true</strong> or <strong>multiPeak</strong> <span
class="math display">\[
r=\frac{T_d}{T_{\text{total}}}
\]</span></p>
<p>​ where <span class="math inline">\(T_{\text{total}} = \text{EMIR
time window}\)</span></p>
<p>​ <span class="math inline">\(T_d\)</span> = the time duration in
microsecond of the total "On Time" period based on <code>IPWC</code></p>
<blockquote>
<p>Pulse-Wise Constant EM current calculation (IPWC)</p>
</blockquote>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220729032235649.png"
alt="image-20220729032235649" /></p>
<p>where <strong>Tau</strong> is <span
class="math inline">\(T_d\)</span> in above formula</p>
<blockquote>
<p>!!! It seems that t*'s PDK don't support
<code>dynamicACPeak=true</code></p>
</blockquote>
<h2 id="ir-drop-filter-layers">IR drop filter layers</h2>
<p>EM techfile (qrcTechFile) may take diffusion contact
(<em>n_odtap</em>, <em>p_odtap</em> in DSPF file) into account during IR
drop analysis. And these segment often dominate IR drop, but we as IC
designer can NOT improve them. In general, the IR drop to M1 layer is
enough and feasible.</p>
<h2 id="regular-analysis-statements-in-emir-configuration">Regular
analysis statements in emir configuration</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net name=[I0.vdd I0.vss] analysis=[vmax vavg]</span><br><span class="line">net name=[I0.*] analysis =[imax ivavg irms]</span><br></pre></td></tr></table></figure>
<h2 id="emirreport-command">emirreport command</h2>
<p>Creating reports for specific nets after simulation using
<code>emirreport</code></p>
<p>Create a new config file as shown below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** test.conf**</span><br><span class="line">net name=[I1.VDD I1.VSS] analysis=[iavg]</span><br><span class="line">net name=[I1.VBIAS] analysis=[imax]</span><br></pre></td></tr></table></figure>
<p>Run <code>emirreport</code> on the command line using the
<strong>emirdatabase</strong> (emir*.bin) and <strong>test.conf</strong>
created above in</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% emirreport -64 -c test.conf -db &lt;emirdatabase&gt; -outdir newreport</span><br></pre></td></tr></table></figure>
<h2 id="database">database</h2>
<h3 id="simulation-result">simulation result</h3>
<ul>
<li><code>input.emir0_bin</code>: The first EMIR Analysis which is DC or
Transient, which depends on <em>Analyses</em> order</li>
</ul>
<blockquote>
<ul>
<li><p><code>input_tran.emir0_bin</code>: EMIR Analysis in Transient
simulation</p></li>
<li><p><code>input_dcOp.emir0_bin</code>: EMIR Analysis in DC
simulation</p></li>
</ul>
</blockquote>
<p>For example</p>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220421203011393.png"
alt="image-20220421203011393" /></p>
<p>Two results are generated <code>input.emir0_bin</code> and
<code>input_dcOp.emir0_bin</code> and their reports respectly</p>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220421203657123.png"
alt="image-20220421203657123" /></p>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220421203554147.png"
alt="image-20220421203554147" /></p>
<h2 id="fix-electromigration">Fix Electromigration</h2>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>wider wire</th>
<th>downsize drivers</th>
<th>decrease fanout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RJ JMAX</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td>JAVG</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>JABSAVG</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>JACPEAK</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>JACRMS</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><p>Iavg</p>
<p>The average value of the current, which is the effective DC
current</p></li>
<li><p>Irms</p>
<p>Irms rule relates to the heat or Joule-heating of metal
lines</p></li>
<li><p>Ipeak</p>
<p>The main goal of the Ipeak limits is to ensure that no thermal
breakdown could occur on single overshoot events. If the signal may not
have a high current density but if it has a very large peak current
density, then, local melting will happen and cause failures</p></li>
</ul>
</blockquote>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220503205418275.png"
alt="image-20220503205418275" /></p>
<h2 id="qa">QA</h2>
<ol type="1">
<li><p>Q. Why “length” column in EM results form doesn’t show extracted
length, it shows “NA”.</p>
<p>A. Voltus-Fi reports the “length” column only when length rules are
present in the emDataFile.</p></li>
<li><p>Seeing different port currents with and without emir simulations
for same dspf included in EMIR Direct method using dspf_include.</p>
<p>Split Pins (*|P) in DSPF are only shorted in the EMIR flow not in the
regular spectre flow. Islands patching is only performed in EMIR
only</p></li>
<li><p>Setting temperature for EM analysis</p></li>
</ol>
<p>By Default, Voltus-FI and VPS pick up the current density limit for
<strong>temperature at which simulation has been performed</strong>.</p>
<blockquote>
<p>By the way, <code>Design Variables</code> - <em>temperature</em> will
override the temperature in <em>Setup toolbar</em> which is gray in ADE
Explorer</p>
</blockquote>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220421184141363.png"
alt="image-20220421184141363" /></p>
<ol start="4" type="1">
<li><p>AC Peak EM analysis - Voltus-Fi</p>
<p>The available options within the EM current analysis section in the
EMIR Analysis Setup form are:</p>
<p><code>max / avg / avgabs / rms.</code></p>
<p>In order to enable the <em>AC Peak based information</em> when
loading the EM results, <strong>both max and avg</strong> should be
selected when setting up the EMIR Analysis Setup.</p>
<p>With this configuration, the AC Peak option becomes available and can
be used.</p></li>
<li><p>How to print average, rms, and peak current of <strong>device
tap</strong> in Spectre/Voltus FI EMIR analysis</p>
<p>The following option enables you to save the average, rms, and peak
tap currents in the <strong>emir0bin</strong> file and report it in the
<strong>input.rpt_tapi</strong> file.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">solver report_tapi=true</span><br></pre></td></tr></table></figure>
<p>Add this option in <strong>emir.conf</strong> to enable the reporting
of tap current after the Spectre EMIR simulation. The input.rpt_tapi
file will be saved in the psf/raw directory.</p>
<p><strong>Note:</strong> This feature is supported in SPECTRE20.1 ISR14
and later versions.</p></li>
<li><p>emir.conf file</p>
<p><code>emir.conf</code> file is generated automaticaly after configure
<em>EM/IR Analysis</em> in ADE, which is in <em>netlist</em>
directory.</p>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220421182327011.png"
alt="image-20220421182327011" /></p></li>
<li><p>Setting default path for EM rules file in APS EMIR analysis</p>
<ul>
<li><p>set the following environment variable in your terminal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv EMDATAFILE &lt; path to EM rules file&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>or set in <code>.cdsinit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setShellEnvVar(&quot;EMDATAFILE=&lt;path to EM rules file&gt;&quot;)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Print node names and length associated with parasitic resistors
in EM report file</p>
<blockquote>
<p><code>export CDS_MMSIM_VOLTUSFI_ROOT=$CDSHOME</code></p>
</blockquote>
<ul>
<li><p>Printing the parasitic resistor length in the EM report</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emirutil reportLength=true</span><br></pre></td></tr></table></figure></li>
<li><p>Printing nodes that are associated with the parasitic
resistor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emirutil reportNodeName=true</span><br></pre></td></tr></table></figure>
<p>Once these are enabled, you will have the <strong>Length</strong>,
<strong>Node_1</strong>, and <strong>Node_2</strong> columns printed in
the EM report file, as shown below:</p>
<p><img src="/2022/02/23/emir-voltus-fi/servlet.jpeg"
alt="servlet" /></p></li>
</ul></li>
<li><p>Is it possible to run RMS IR Drop analysis using Voltus-Fi?</p>
<p>Typically, in a simulation, Power/Ground nets are always biased with
a <strong>constant DC source</strong>. Hence, at present, Voltus-Fi only
supports <strong>Average and Maximum (Peak) IR Drop</strong>
analysis.</p>
<p>For a net to have data for IR analysis(vmax/vavg), the net/node must
be connected to a <strong>DC vsource or a vsource which is constant
within the emir time window</strong>.</p></li>
<li><p>Can we change the time window of EM computation after the
simulation completed ?</p>
<p>It is not possible to modify the EM time window without re-running
the full simulation.</p>
<p>However you can specify several time window in the emir conf file for
instance for 2 time window [0 to 10n] and [10n 20n]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time window=[0 10n 10n 20n]</span><br></pre></td></tr></table></figure>
<p>In that case it will create 2 <strong>emir_bin</strong> files and
then 2 different em report files according to the 2 different time
windows.</p></li>
<li><p>How to print segment_W values being used to compute EM limits</p>
<p>You can use the following option to print <code>segment_W</code> to
the report:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emirutil reportSegmentWidth=[true]</span><br></pre></td></tr></table></figure>
<p>This would print a <code>Segment_w</code> column in the report
containing the segment width values used for computing the limit:</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 3%" />
<col style="width: 7%" />
<col style="width: 3%" />
<col style="width: 6%" />
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 4%" />
<col style="width: 7%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 11%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>Pass/Fail %</th>
<th>Resistor</th>
<th>layer</th>
<th>Current</th>
<th>Width</th>
<th>PathLength</th>
<th>I limit</th>
<th>X1</th>
<th>Y1</th>
<th>X2</th>
<th>Y2</th>
<th>J/JMAX</th>
<th>Res</th>
<th>ViaArea</th>
<th>No of needed vias</th>
<th>width/#via</th>
<th>J limit</th>
<th>Segment_w</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td>(mA)</td>
<td>(um)</td>
<td>(um)</td>
<td></td>
<td>(um)</td>
<td>(um)</td>
<td>(um)</td>
<td>(um)</td>
<td></td>
<td></td>
<td>(nm^2)</td>
<td></td>
<td>(um/#)</td>
<td>(A/um)</td>
<td></td>
</tr>
<tr class="even">
<td>pass-100.0</td>
<td>Rj3292</td>
<td>Met1</td>
<td>9.02376e-12</td>
<td>0.1</td>
<td>42.72</td>
<td>1.10067</td>
<td>0.350</td>
<td>11.568</td>
<td>0.350</td>
<td>11.376</td>
<td>8.19843e-12</td>
<td>0.7382</td>
<td>NA</td>
<td>NA</td>
<td>0.0001</td>
<td>0.0110067</td>
<td>0.1</td>
</tr>
</tbody>
</table></li>
<li><p>pathLength vs Length in EM report file</p>
<ul>
<li><p>Length: parasitic resistor length, which is set by
<code>emirutil reportLength=true</code></p></li>
<li><p>pathlength: Blech length is also known as "Short length" or "Path
length", and can be explained as : The <strong>longest and continuous
centerline path from edge to edge</strong> among the connected wire
shapes on the <strong>same metal layer</strong>.</p>
<ul>
<li>For all resistors falling on this shape, <strong>same
pathLength</strong> is reported.</li>
<li>After the longest path in shape has been determined the tool applies
the same blech length to all the resistor falling on that shape.</li>
<li>This resistor length is <strong>NOT</strong> used in EM analysis
because EM rules consider Blech length of the resistor.</li>
</ul>
<p><img src="/2022/02/23/emir-voltus-fi/image-20220421001806689.png"
alt="image-20220421001806689" /></p>
<blockquote>
<p>where W is the wire width and L is the Blech length.</p>
</blockquote>
<ul>
<li><p>By default the tool will <strong>sum all branches of a given
metal layer</strong>. In other words the path length that will be used
to look up the EM density limit is :</p>
<p>Bl = $l(R1) + $l(R2) + $l(R3) + $l(R4) + $l(R5) + $l(R6) + $l(R7) +
$l(R8)</p>
<p><img src="/2022/02/23/emir-voltus-fi/servlet-16504730496591.jpeg"
alt="servlet" /></p></li>
</ul></li>
</ul></li>
<li><p>How to enable EMIR analysis in PSS simualtion ?</p>
<p>To enable EMIR in PSS, you have to enable DC and/or Tran simulation
simultaneously. Two or more binary results file should be generated and
select the file based file name or configure text file in
<code>psf</code> directory.</p>
<p>(given ICADVM 18.1 ISR11, Spectre 19.1 ISR6)</p></li>
</ol>
<h2 id="reference">reference</h2>
<p>AC Peak Analysis Using IPWC Rapid Adoption Kit (RAK) Product Version:
IC6.1.8 ISR10, SPECTRE19.1 ISR5 April 2020</p>
<p>Posser, Gracieli &amp; Sapatnekar, Sachin &amp; Reis, Ricardo.
(2017). Electromigration Inside Logic Cells.
10.1007/978-3-319-48899-8.</p>
<p>A. B. Kahng, S. Nath and T. S. Rosing, "On potential design impacts
of electromigration awareness," 2013 18th Asia and South Pacific Design
Automation Conference (ASP-DAC), 2013, pp. 527-532, doi:
10.1109/ASPDAC.2013.6509650.</p>
<p>Kumar, Neeraj and Mohammad S. Hashmi. “Study, analysis and modeling
of electromigration in SRAMs.” (2014).</p>
<p>N. S. Nagaraj, F. Cano, H. Haznedar and D. Young, "A practical
approach to static signal electromigration analysis," Proceedings 1998
Design and Automation Conference. 35th DAC. (Cat. No.98CH36175), 1998,
pp. 572-577, doi: 10.1109/DAC.1998.724536.</p>
<p>Blaauw, David &amp; Oh, Chanhee &amp; Zolotov, Vladimir &amp;
Dasgupta, Aurobindo. (2003). Static electromigration analysis for
on-chip signal interconnects. Computer-Aided Design of Integrated
Circuits and Systems, IEEE Transactions on. 22. 39 - 48.
10.1109/TCAD.2002.805728.</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>EMX &amp; PeakView</title>
    <url>/2022/03/15/emx-peakview/</url>
    <content><![CDATA[<h2 id="lvs-check">LVS check</h2>
<p>LVS issue for circuits with customized devices</p>
<ul>
<li><p>auCdl: Analog and Microwave CDL, is a netlister used for creating
CDL netlist for analog circuits</p></li>
<li><p>auLVS: Analog and Microwave LVS, is used for analog circuit
LVS</p></li>
</ul>
<h2 id="emx-ports">EMX ports</h2>
<h3 id="plain-labels">plain labels</h3>
<ul>
<li><strong>pin</strong> layer</li>
<li>uncheck <strong>Cadence pins</strong> in <strong>Advanced
options</strong></li>
</ul>
<h3 id="rectangle-pins">rectangle pins</h3>
<ul>
<li><strong>drawing</strong> layer rectangle pin and specify
<strong>Access Direction</strong> as intended</li>
<li>check <strong>Cadence pins</strong> in <strong>Advanced
options</strong></li>
</ul>
<blockquote>
<p>The rectangle pins are always selected as driven port while there are
<strong>only rectangle pin</strong> whether <strong>Cadence
pins</strong> checked or not.</p>
</blockquote>
<h3 id="check-ports-used-for-simulation">check ports used for
simulation</h3>
<p>use <strong>GDS view - EMX</strong></p>
<h3 id="emx-synthesis-kits">EMX Synthesis Kits</h3>
<p>Synthesis is a capability of the EMX <strong>Pcell</strong> library
and uses scalable model data pre-generated by Continuum for a specific
process and metal scheme combination.</p>
<p>Synthesis is supported by the Pcells that are suffixed
<strong>_scalable</strong>, and these Pcells have the additional fields
and buttons needed for synthesis.</p>
<h3 id="port-order-signals">port order (signals)</h3>
<blockquote>
<p>emxform.ils</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>type</th>
<th><strong>Port order</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>inductor</td>
<td>P1 P2</td>
</tr>
<tr class="even">
<td>shield inductor</td>
<td>P1 P2 SHIELD</td>
</tr>
<tr class="odd">
<td>tapped inductor</td>
<td>P1 P2 CT</td>
</tr>
<tr class="even">
<td>tapped shield inductor</td>
<td>P1 P2 CT SHIELD</td>
</tr>
<tr class="odd">
<td>mom/mim capacitor</td>
<td>P1 P2</td>
</tr>
<tr class="even">
<td>tcoil</td>
<td>P1 P2 TAP</td>
</tr>
<tr class="odd">
<td>shield tcoil</td>
<td>P1 P2 TAP SHIELD</td>
</tr>
<tr class="even">
<td>tline</td>
<td>P1 P2</td>
</tr>
<tr class="odd">
<td>differential tline</td>
<td>P1 P2 P3 P4</td>
</tr>
</tbody>
</table>
<h3 id="emx-device-info">EMX device info</h3>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 29%" />
<col style="width: 5%" />
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>menu_selection (split with _ )</th>
<th>num_ports</th>
<th>modelgen_type</th>
<th>generic_model_type</th>
<th>plot_fn</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Single-ended inductor</td>
<td>inductor_no tap_no shield_single-ended</td>
<td>2</td>
<td>inductor</td>
<td>inductor</td>
<td>EMX_plot_se_ind</td>
</tr>
<tr class="even">
<td>Differential inductor</td>
<td>inductor_no tap_no shield_differential</td>
<td>2</td>
<td>inductor</td>
<td>inductor</td>
<td>EMX_plot_diff_ind</td>
</tr>
<tr class="odd">
<td>Single-ended shield inductor</td>
<td>inductor_no tap_with shield_single-ended</td>
<td>3</td>
<td>shield_inductor</td>
<td>shield_inductor</td>
<td>EMX_plot_se_ind</td>
</tr>
<tr class="even">
<td>Differential shield inductor</td>
<td>inductor_no tap_with shield_differential</td>
<td>3</td>
<td>shield_inductor</td>
<td>shield_inductor</td>
<td>EMX_plot_diff_ind</td>
</tr>
<tr class="odd">
<td>Tapped inductor (diff mode only)</td>
<td>inductor_with tap_no shield_differential mode only</td>
<td>3</td>
<td>center_tapped_inductor</td>
<td>tapped_inductor</td>
<td>EMX_plot_ct_ind</td>
</tr>
<tr class="even">
<td>Tapped inductor (common mode too)</td>
<td>inductor_with tap_no shield_also fit common mode</td>
<td>3</td>
<td>center_tapped_inductor_common_mode</td>
<td>tapped_inductor</td>
<td>EMX_plot_ct_ind</td>
</tr>
<tr class="odd">
<td>Tapped shield inductor (diff only)</td>
<td>inductor_with tap_with shield_differential mode only</td>
<td>4</td>
<td>center_tapped_well_inductor_common_mode</td>
<td>tapped_shield_inductor</td>
<td>EMX_plot_ct_ind</td>
</tr>
<tr class="even">
<td>Single-ended cap (symm)</td>
<td>capacitor_symmetric single-ended</td>
<td>2</td>
<td>complex_mom_capacitor</td>
<td>mom_capacitor</td>
<td>EMX_plot_se_cap</td>
</tr>
<tr class="odd">
<td>Differential cap (symm)</td>
<td>capacitor_symmetric differential</td>
<td>2</td>
<td>complex_mom_capacitor</td>
<td>mom_capacitor</td>
<td>EMX_plot_diff_cap</td>
</tr>
<tr class="even">
<td>Single-ended cap (asymm)</td>
<td>capacitor_asymmetric single-ended</td>
<td>2</td>
<td>complex_asymmetric_mom_capacitor</td>
<td>mom_capacitor</td>
<td>EMX_plot_se_cap</td>
</tr>
<tr class="odd">
<td>Differential cap (asymm)</td>
<td>capacitor_asymmetric differential</td>
<td>2</td>
<td>complex_asymmetric_mom_capacitor</td>
<td>mom_capacitor</td>
<td>EMX_plot_diff_cap</td>
</tr>
<tr class="even">
<td>MiM capacitor</td>
<td>capacitor_MiM</td>
<td>2</td>
<td>mim_capacitor</td>
<td>mim_capacitor</td>
<td>EMX_plot_se_cap</td>
</tr>
<tr class="odd">
<td>Tcoil (simple model)</td>
<td>tcoil_simple model</td>
<td>3</td>
<td>tcoil</td>
<td>tcoil</td>
<td>EMX_plot_tcoil</td>
</tr>
<tr class="even">
<td>Tcoil (complex model)</td>
<td>tcoil_complex model</td>
<td>3</td>
<td>complex_tcoil</td>
<td>complex_tcoil</td>
<td>EMX_plot_tcoil</td>
</tr>
<tr class="odd">
<td>Shield tcoil</td>
<td>tcoil_with shield</td>
<td>4</td>
<td>shield_complex_tcoil</td>
<td>shield_tcoil</td>
<td>EMX_plot_shield_tcoil</td>
</tr>
<tr class="even">
<td>Transmission line</td>
<td>transmission line_single</td>
<td>2</td>
<td>xline</td>
<td>xline</td>
<td>EMX_plot_xline</td>
</tr>
<tr class="odd">
<td>Diff transmission line</td>
<td>transmission line_coupled (differential)</td>
<td>4</td>
<td>coupled_xline</td>
<td>diff_xline</td>
<td>EMX_plot_diff_xline</td>
</tr>
</tbody>
</table>
<h2 id="emx-plot-function">EMX plot function</h2>
<blockquote>
<p>EMX's formulation is defined in</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path/to/EMX/share/emx/virtuoso_ui/emxinterface/emxskill/emxform.ils</span><br></pre></td></tr></table></figure>
<p>EMX import this file at Virtuoso startup, you have to relaunch
Virtuoso if you change this file</p>
</blockquote>
<h3 id="single-ended-inductor">Single-ended inductor</h3>
<p>Both with and without shield apply</p>
<ul>
<li>port-1 impedance when port-2 short</li>
</ul>
<p><span class="math display">\[
Z_1 = \frac{1}{Y_{11}}
\]</span></p>
<ul>
<li>port-2 impedance when port-1 short</li>
</ul>
<p><span class="math display">\[
Z_2 = \frac{1}{Y_{22}}
\]</span> Then <span class="math display">\[\begin{align}
L1 &amp;= \frac{Im(Z_1)}{2\pi f} \\
Q1 &amp;= \frac{Im(Z_1)}{Re(Z_1)} \\
L2 &amp;= \frac{Im(Z_2)}{2\pi f} \\
Q2 &amp;= \frac{Im(Z_2)}{Re(Z_2)}
\end{align}\]</span></p>
<blockquote>
<p>EMX only plot L1 and Q1</p>
</blockquote>
<h3 id="differential-impedance">differential impedance</h3>
<p>Y parameters to Z parameters</p>
<p><span class="math display">\[\begin{align}
|Y| &amp;= Y_{11}*Y_{22} - Y_{12}*Y_{22} \\
\begin{bmatrix}
Z_{11} &amp; Z_{12}\\
Z_{21} &amp; Z_{22}
\end{bmatrix}
&amp;=
\begin{bmatrix}
\frac{Y_{22}}{|Y|} &amp; \frac{-Y_{12}}{|Y|}\\
\frac{-Y_{21}}{|Y|} &amp; \frac{Y_{11}}{|Y|}
\end{bmatrix}
\end{align}\]</span></p>
<p>Then <strong>differential impedance</strong> is <span
class="math display">\[
Z_{diff} = Z_{11} - Z_{12} - Z_{21} + Z_{22}
\]</span></p>
<p><img src="/2022/03/15/emx-peakview/image-20220330234833756.png"
alt="image-20220330234833756" /></p>
<blockquote>
<p>similarly, Z parameters to Y parameters <span class="math display">\[
\begin{bmatrix}
Y_{11} &amp; Y_{12}\\
Y_{21} &amp; Y_{22}
\end{bmatrix}
=
\begin{bmatrix}
\frac{Z_{22}}{|Z|} &amp; \frac{-Z_{12}}{|Z|}\\
\frac{-Z_{21}}{|Z|} &amp; \frac{Z_{11}}{|Z|}
\end{bmatrix}
\]</span> where <span class="math display">\[
|Z| = Z_{11}Z_{22} - Z_{12}Z_{21}
\]</span></p>
</blockquote>
<h3 id="differential-inductor">Differential inductor</h3>
<p>Both with and without shield apply</p>
<p><span class="math display">\[\begin{align}
L_{diff} &amp;= \frac{Im(Z_{diff})}{2\pi f} \\
Q_{diff} &amp;= \frac{Im(Z_{diff})}{Re(Z_{diff})}
\end{align}\]</span></p>
<h3 id="center-tapped-inductor">Center-tapped inductor</h3>
<p><span class="math display">\[
Y =
\begin{bmatrix}
Y_{11} &amp; Y_{12} &amp; Y_{13}\\
Y_{21} &amp; Y_{22} &amp; Y_{23}\\
Y_{31} &amp; Y_{32} &amp; Y_{33}
\end{bmatrix}
\]</span></p>
<p>where port order is <code>P1 P2 CT</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (EMX_plot_ct_ind bgui wid what)</span><br><span class="line">  (EMX_plot_aux bgui wid what 3</span><br><span class="line">		&#x27;(&quot;Differential inductance&quot; &quot;Differential Q&quot;)</span><br><span class="line">		&#x27;(&quot;Henry&quot; &quot;&quot;)</span><br><span class="line">		(lambda (ys)</span><br><span class="line">		  (letseq ((z (EMX_differential (nth 0 ys) (nth 1 ys) (nth 3 ys) (nth 4 ys)))</span><br><span class="line">			   (f (xval z))</span><br><span class="line">			   (L (imag z)/(2*3.14159265358979*f))</span><br><span class="line">			   (Q (imag z)/(real z)))</span><br><span class="line">		    `((,L) (,Q))))</span><br><span class="line">		&#x27;((&quot;L&quot;) (&quot;Q&quot;))))</span><br></pre></td></tr></table></figure>
<p>Assume <code>CT</code> i.e. port 3 in S-parameter is grounded,
<code>(z (EMX_differential (nth 0 ys) (nth 1 ys) (nth 3 ys) (nth 4 ys)))</code>
obtain differential impedance with <span
class="math inline">\(Y_{11}\)</span>, <span
class="math inline">\(Y_{12}\)</span>, <span
class="math inline">\(Y_{21}\)</span> and <span
class="math inline">\(Y_{22}\)</span>. <span class="math display">\[
Y =
\begin{bmatrix}
Y_{11} &amp; Y_{12}\\
Y_{21} &amp; Y_{22}
\end{bmatrix}
\]</span> Finally, differential inductance and Q are obtained, shown as
below</p>
<p><span class="math display">\[\begin{align}
L_{diff} &amp;= \frac{Im(Z_{diff})}{2\pi f} \\
Q_{diff} &amp;= \frac{Im(Z_{diff})}{Re(Z_{diff})}
\end{align}\]</span></p>
<p><img src="/2022/03/15/emx-peakview/image-20220331013735370.png"
alt="image-20220331013735370" /></p>
<h3 id="single-ended-cap">Single-ended cap</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (EMX_plot_se_cap bgui wid what)</span><br><span class="line">  (EMX_plot_aux bgui wid what 2</span><br><span class="line">		&#x27;(&quot;Capacitance&quot; &quot;Q&quot; &quot;Capacitance&quot; &quot;Q&quot;)</span><br><span class="line">		&#x27;(&quot;Farad&quot; &quot;&quot; &quot;Farad&quot; &quot;&quot;)</span><br><span class="line">		(lambda (ys)</span><br><span class="line">		  (letseq ((z1 1.0/(nth 0 ys))</span><br><span class="line">			   (y12 (nth 1 ys))</span><br><span class="line">			   (z2 1.0/(nth 3 ys))</span><br><span class="line">			   (f (xval z1))</span><br><span class="line">			   (C1 (-1.0/(imag z1))/(2*3.14159265358979*f))</span><br><span class="line">			   (C12 -(imag y12)/(2*3.14159265358979*f))</span><br><span class="line">			   (C2 (-1.0/(imag z2))/(2*3.14159265358979*f))</span><br><span class="line">			   (Q1 -(imag z1)/(real z1))</span><br><span class="line">			   (Q12 (imag y12)/(real y12))</span><br><span class="line">			   (Q2 -(imag z2)/(real z2)))</span><br><span class="line">		    `((,C1) (,Q1) (,C12))))</span><br><span class="line">		&#x27;((&quot;Cse&quot;) (&quot;Qse&quot;) (&quot;C12&quot;))))</span><br></pre></td></tr></table></figure>
<p>We define Port-1 impedance <span class="math inline">\(Z_1\)</span>,
Port-2 impedance <span class="math inline">\(Z_2\)</span></p>
<p><span class="math display">\[\begin{align}
Z_1 &amp;= \frac {1}{Y_{11}}\\
Z_2 &amp;= \frac {1}{Y_{22}}
\end{align}\]</span></p>
<p>Then single-ended cap and Q <span
class="math display">\[\begin{align}
C_1 &amp;= -\frac{1/Im(Z_1)}{2\pi f} \\
Q_1 &amp;= -\frac{Im(Z_1)}{Re(Z_1)} \\
C_2 &amp;=  -\frac{1/Im(Z_2)}{2\pi f} \\
Q_2 &amp;= -\frac{Im(Z_2)}{Re(Z_2)} \\
C_{12} &amp;= -\frac{Im(Y_{12})}{2\pi f}\\
Q_{12} &amp;= \frac{Im(Y_{12})}{Re(Y_{12})}
\end{align}\]</span></p>
<ul>
<li><strong>Series equivalent</strong> model is used in <span
class="math inline">\(C_1\)</span>, <span
class="math inline">\(Q_1\)</span>, <span
class="math inline">\(C_2\)</span> and <span
class="math inline">\(Q_2\)</span>
<ul>
<li><span class="math inline">\(Z_1 = R + \frac{1}{sC_1}\)</span> and
<span class="math inline">\(Z_2 = R + \frac{1}{sC_2}\)</span></li>
</ul></li>
<li>Parallel model is used in <span
class="math inline">\(C_{12}\)</span> and <span
class="math inline">\(Q_{12}\)</span>
<ul>
<li><span class="math inline">\(Y_{12} = \frac{1}{R} +
sC_{12}\)</span></li>
</ul></li>
</ul>
<blockquote>
<p>EMX plot <span class="math inline">\(C_{se}\)</span>, <span
class="math inline">\(Q_{se}\)</span> and <span
class="math inline">\(C_{12}\)</span>, i.e. <span
class="math inline">\(C_1\)</span>, <span
class="math inline">\(Q_1\)</span> and <span
class="math inline">\(C_{12}\)</span></p>
</blockquote>
<p><img src="/2022/03/15/emx-peakview/image-20220331020334023.png"
alt="image-20220331020334023" /></p>
<h3 id="differential-cap">Differential cap</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (EMX_plot_diff_cap bgui wid what)</span><br><span class="line">  (EMX_plot_aux bgui wid what 2</span><br><span class="line">		&#x27;(&quot;Differential capacitance&quot; &quot;Differential Q&quot;)</span><br><span class="line">		&#x27;(&quot;Farad&quot; &quot;&quot;)</span><br><span class="line">		(lambda (ys)</span><br><span class="line">		  (letseq ((z (apply EMX_differential ys))</span><br><span class="line">			   (f (xval z))</span><br><span class="line">			   (C (-1.0/(imag z))/(2*3.14159265358979*f))</span><br><span class="line">			   (Q -(imag z)/(real z)))</span><br><span class="line">		    `((,C) (,Q))))</span><br><span class="line">		&#x27;((&quot;C&quot;) (&quot;Q&quot;))))</span><br></pre></td></tr></table></figure>
<p>First obtain differential impedance, <span
class="math inline">\(Z_{diff}\)</span> then apply series equivalent
model <span class="math display">\[\begin{align}
C_{diff} &amp;= -\frac{1/Im(Z_{diff})}{2\pi f} \\
Q_{diff} &amp;= -\frac{Im(Z_{diff})}{Re(Z_{diff})}
\end{align}\]</span></p>
<p><img src="/2022/03/15/emx-peakview/image-20220331022224865.png"
alt="image-20220331022224865" /></p>
<h3 id="tline">Tline</h3>
<p>Open circuit impedance <span class="math inline">\(Z_o\)</span>,
short circuit impedance <span class="math inline">\(Z_s\)</span> and
characteristic impedance <span class="math inline">\(Z_0\)</span></p>
<p><span class="math display">\[\begin{align}
Z_o &amp;= Z_{11}\\
Z_s &amp;= \frac{1}{Y_{11}}\\
Z_0  &amp;= \sqrt{Z_o*Z_s}
\end{align}\]</span></p>
<p>propagation constant is given as <span
class="math display">\[\begin{align}
\gamma &amp;= \frac{1}{2}\log\left( \frac{Z_0+Z_s}{Z_0-Z_s} \right) \\
&amp;= \alpha + j\beta
\end{align}\]</span> where <span class="math inline">\(\alpha\)</span>
is <strong>attenuation constant</strong> and <span
class="math inline">\(\beta\)</span> is <strong>phase
constant</strong></p>
<p>The relationship between these parameter and geometry of the
transmission line <span class="math display">\[\begin{align}
Z_0 &amp;= \sqrt{\frac{R+j\omega L}{G+j\omega C}} \\
\gamma &amp;= \sqrt{(G+j\omega C)(R+j\omega L)}
\end{align}\]</span> EMX plot the real and imaginary part of <span
class="math inline">\(Z_0\)</span>, <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span> of <span
class="math inline">\(\gamma\)</span></p>
<blockquote>
<p><del>Note EMX plot the absolute value of <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span></del></p>
</blockquote>
<p><img src="/2022/03/15/emx-peakview/image-20220630215343377.png"
alt="image-20220630215343377" /><img
src="/2022/03/15/emx-peakview/image-20220630215418372.png"
alt="image-20220630215418372" /></p>
<p><img src="/2022/03/15/emx-peakview/image-20220630215630849.png"
alt="image-20220630215630849" /></p>
<h3 id="transformer">Transformer</h3>
<p><img src="/2022/03/15/emx-peakview/image-20231015002344332.png"
alt="image-20231015002344332" /></p>
<p><img src="/2022/03/15/emx-peakview/image-20231015002403566.png"
alt="image-20231015002403566" /></p>
<blockquote>
<p>[<a
href="https://icprophet-web.oss-cn-hangzhou.aliyuncs.com/helpdoc/helpdoc-cadenceonly-cn_V230905_3.pdf">IC
Prophet GDSII 文件使用和仿真测试说明</a>]</p>
</blockquote>
<h2 id="emx-autoplot">EMX autoplot</h2>
<blockquote>
<p>using AC simulation, and inductor's parallel model or series
model</p>
<p>That is to say: both <code>sp</code> (network parameter) and
<code>ac</code> (impedance) can be used to plot inductance, Q value.</p>
<p>usually EMX choose <code>ac</code> method</p>
</blockquote>
<p><img src="/2022/03/15/emx-peakview/image-20220501173856442.png"
alt="image-20220501173856442" /></p>
<p><img src="/2022/03/15/emx-peakview/image-20220501173930035.png"
alt="image-20220501173930035" /></p>
<blockquote>
<p>left 2 figures are used for AC simulation, <span
class="math inline">\(Y_{nn}\)</span> can be obtained conveniently</p>
</blockquote>
<h2 id="foundary-model">Foundary model</h2>
<p><img src="/2022/03/15/emx-peakview/image-20221217141519947.png"
alt="image-20221217141519947" /></p>
<p>for single-end capicator <span class="math display">\[\begin{align}
Q_1 &amp;= -\frac{Im(Z_1)}{Re(Z_1)} \\
&amp;= -\frac{Im(1/Y_{11})}{Re(1/Y_{11})} \\
&amp;= -\frac{Im(Y_{11}^*)/|Y_{11}|^2}{Re(Y_{11}^*)/|Y_{11}|^2} \\
&amp;= \frac{Im(Y_{11})}{Re(Y_{11})}
\end{align}\]</span></p>
<p>So, the EMX model and foundary model is consistent.</p>
<h2 id="tips">Tips</h2>
<p>Process file encryption mostly for advanced nodes, like TSMC 16nm
Finfet, whose process file is encrypted.</p>
<ul>
<li>Use <code>--key=EMXkey</code> in the EMX <em>Advanced
options</em></li>
</ul>
<p>GDSviewer has two options</p>
<ul>
<li>EMX: shows the final gds sent to EMX for simulation after it has
been processed by EMX</li>
<li>Raw: shows the raw gds</li>
</ul>
<blockquote>
<p>If there are port name with the <code>#</code> sign, it means EMX
sees a port but it is not in the signal list.</p>
</blockquote>
<p>EMX Accuracy</p>
<ul>
<li><p>Edge mesh: controls layout discretization in the X-Y plane</p>
<ul>
<li>For MoM capacitors, use the edge mesh to be the same as the width of
the finger (for example, 0.1um).</li>
</ul></li>
<li><p>Thickness: controls layout discretization in the Z
dimension</p></li>
<li><p>3D metals: skips all 2D assumptions about conductors and their
currents and charges</p>
<ul>
<li>If you set <code>3D metals</code> to <code>*</code> then all metals
are treated as <strong>3D</strong>
<ul>
<li>For Inductor type structures, only thick metal needs 3D.</li>
<li>For MoM, all layers are needed.</li>
</ul></li>
</ul></li>
</ul>
<p>Ports entered in <code>Grounds</code> will cause these nets to be
grounded; these ports will not show up in the S-parameter result.</p>
<p>Setup Temperature</p>
<ul>
<li>EMX: <code>--temperature=100</code></li>
</ul>
<p>ParaView</p>
<ul>
<li>If check ParaView related options when ParaView is not setup
properly, EMX simulation stop at <em>Creating mesh...</em> without
waring or errors (version 6.2).</li>
</ul>
<h2 id="reference">reference</h2>
<p>Tips on Specifying Ports in EMX [<a
href="Article%20(20493671)%20Title:%20Tips%20on%20Specifying%20Ports%20in%20EMX%20URL:%20https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w00000AD4uEEAT">link</a>]</p>
<p>Using 'Cadence pins' as ports with access direction in EMX
simulations [[link](Article (20496398) Title: Using 'Cadence pins' as
ports with access direction in EMX simulations URL:
https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w00000AH2OfEAL)]</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>Effective Noise BandWidth and Noise Floor</title>
    <url>/2023/05/29/enbw-nl/</url>
    <content><![CDATA[<h2 id="ps-and-psd">PS and PSD</h2>
<p>The spectral density format is appropriate for random or noise
signals but inappropriate for discrete frequency components because the
latter theoretically have zero bandwidth</p>
<h2 id="amplitude-correction">Amplitude Correction</h2>
<ol type="1">
<li><p>A finite-duration window <span
class="math inline">\(w[n]\)</span></p>
<p>DTFT is <span class="math inline">\(W[e^{j\omega}]\)</span> and the
maximum magnitude is is at DC frequency, which <span
class="math inline">\(\sum_n w_n\)</span></p></li>
<li><p>Sinusoidal signal <span class="math inline">\(x[n]\)</span></p>
<p>DFS is <span class="math inline">\(X_k\)</span>, and DTFT shall be
<span
class="math inline">\(\frac{2\pi}{N}X_k(e^{j\omega})\)</span></p></li>
<li><p>the windowed sequence <span class="math inline">\(v[n] =
x[n]w[n]\)</span></p>
<p>with multiplication property, DTFT of <span
class="math inline">\(v[n]\)</span> shall be <span
class="math inline">\(\frac{X_k(e^{j\omega})}{N}\sum_n w_n\)</span></p>
<p>As we know, DFT of <span class="math inline">\(v[n]\)</span> is
samples of its DTFT, that is <span class="math display">\[
\frac{X_k(e^{j\omega})}{N}\sum_n w_n = X_v[k]
\]</span> Therefore, <span class="math display">\[
\frac{X_k(e^{j\omega})}{N} = \frac{X_v[k]}{\sum_n w_n}
\]</span></p></li>
</ol>
<h2 id="effective-noise-bandwidth-enbw">Effective Noise BandWidth
(ENBW)</h2>
<h3 id="general-derivation">General derivation</h3>
<p>The relationship between a <em>power spectrum</em> (<span
class="math inline">\(PS, V^2\)</span>) and a <em>power spectral
density</em> (<span class="math inline">\(PSD, V^2/Hz\)</span>) is given
by the <strong>effective noise bandwidth</strong> (<em>ENBW</em>), which
can easily be determined at the time when the DFT is computed.</p>
<p>ENBW should always be recorded when a spectrum or spectral density is
computed, such that the result can be converted to the other form at a
later stage, when the information about the frequency resolution <span
class="math inline">\(f_{res}\)</span> and the window that was used is
normally not easily available any more.</p>
<p>The <strong>normalized equivalent noise bandwidth</strong> (NENBW) of
the window is given by</p>
<p><span class="math display">\[
\text{NENBW} = \frac{NS_2}{S_1^2}
\]</span> where <span class="math inline">\(S_1 = \sum
_{k=0}^{N-1}w_k\)</span> and <span class="math inline">\(S_2 = \sum
_{k=0}^{N-1}w_k^2\)</span></p>
<p>The <em>ENBW</em> is given by</p>
<p><span class="math display">\[
\text{ENBW} = \text{NENBW}\cdot f_{res} = \text{NENBW}\cdot
\frac{f_s}{N} = f_s\frac{S_2}{S_1^2}
\]</span></p>
<blockquote>
<p>Equivalent noise bandwidth (ENBW) compares a <em>window</em> to an
<em>ideal, rectangular time-window</em>. It is the <em>bandwidth of the
rectangular window's frequency-domain shape</em> that passes the same
amount of <strong>white noise</strong> energy as the frequency-domain
shape defined by the other window.</p>
</blockquote>
<p><img src="/2023/05/29/enbw-nl/enbw.png" alt="enbw" /></p>
<p>Therefore, the equivalent noise bandwidth <span
class="math inline">\(B_{enbw}\)</span> is given by</p>
<p><span class="math display">\[
B_{enbw} = \frac{\int_{-f}^{f} |W(f)|^2 df}{|W(f_0)|^2}
\]</span></p>
<p>Translating to discrete domain, the equivalent noise bandwidth can be
computed using DFT samples as</p>
<p><span class="math display">\[
B_{enbw} =\frac{\sum_{k=0}^{N-1}|W[k]|^2}{|W[k_0]|^2}
\]</span></p>
<p>where <span class="math inline">\(k_0\)</span> is the index at which
the magnitude of FFT output is maximum and <span
class="math inline">\(N\)</span> is the window length, i.e. <span
class="math inline">\(k_0=0\)</span>.</p>
<p>Applying <em>Parseval's theorem</em> and <span
class="math inline">\(W[0]=\sum_{n}w[n]\)</span>, <span
class="math inline">\(B_{enbw}\)</span> can also be computed using time
domain samples as</p>
<p><span class="math display">\[
B_{enbw} = N \frac{\sum_{n}|w[n]|^2}{ \left| \sum_{n} w[n] \right|^2}
\]</span></p>
<blockquote>
<p>scale <span class="math inline">\(w[n]\)</span>
<strong>don't</strong> change <span
class="math inline">\(B_{enbw}\)</span></p>
<p>Noise power inside window: <span class="math inline">\(\int_{-f}^{f}
|W(f)|^2 df \to N\cdot\sum_{n}|w[n]|^2\)</span></p>
<p>peak amplitude: <span class="math inline">\(|W(f_0)|^2 \to \left|
\sum_{n} w[n] \right|^2\)</span></p>
</blockquote>
<h3 id="an-alternative-derivation">An alternative derivation</h3>
<p><img src="/2023/05/29/enbw-nl/coherence-incoherence.drawio.svg"
alt="coherence-incoherence.drawio.svg" /></p>
<p>Assuming the windowed sequence <span class="math inline">\(v[n] =
x[n]w[n]\)</span></p>
<ul>
<li><p><span class="math inline">\(W[k]\)</span>: Fourier Transform of
finite sequence window</p></li>
<li><p><span class="math inline">\(X_{sig}\)</span>: Fourier Transform
of signal</p></li>
<li><p><span class="math inline">\(X_{n}\)</span>: Fourier Transform of
noise</p></li>
<li><p><span class="math inline">\(X_{v,sig}\)</span>: Fourier Transform
of windowed signal</p></li>
<li><p><span class="math inline">\(X_{v,n}\)</span>: Fourier Transform
of windowed noise</p></li>
</ul>
<blockquote>
<p>From Fig. 6,, we observe that the amplitude of the harmonic estimate
at a given frequency is biased by the accumulated broad-band noise
included in the bandwidth of the window.</p>
<p><img src="/2023/05/29/enbw-nl/image-20240517195407690.png"
alt="image-20240517195407690" /></p>
<p>In this sense, the window behaves as a filter, gathering
contributions for its estimate over its bandwidth</p>
</blockquote>
<p>The Fourier Transform of windowed signal can be expressed as</p>
<p><span class="math display">\[\begin{align}
X_{v,sig} &amp;= W_{max}\cdot X_{sig} \\
&amp;= W[0]\cdot X_{sig}
\end{align}\]</span></p>
<blockquote>
<p>For a typical window, <span class="math inline">\(W_{max}\)</span>
occurs at <span class="math inline">\(\omega = 0\)</span></p>
</blockquote>
<p>And the Fourier Transform of windowed noise can be expressed as</p>
<p><span class="math display">\[
X_{v,n}^2 = \sum_k (W[k])^2 \cdot X_n^2
\]</span></p>
<p>divided by <span class="math inline">\((W[0])^2\)</span> on both
sides of the above equation</p>
<p><span class="math display">\[
\frac{X_{v,n}^2}{(W[0])^2} = \frac{\sum_k (W[k])^2}{(W[0])^2} \cdot
X_n^2
\]</span></p>
<p>By Parseval's theorem</p>
<p><span class="math display">\[
\frac{X_{v,n}^2}{\left(\sum_n w[n]\right)^2} = \frac{N\sum_n
w^2[n]}{\left(\sum_n w[n]\right)^2} \cdot X_n^2
\]</span></p>
<p>where <span class="math inline">\(X^2_n\)</span> is what is deserved
and</p>
<p><span class="math display">\[
X_n^2 = \frac{PS_{n}}{B_{enbw}}
\]</span></p>
<p>where <span class="math inline">\(B_{enbw} = N
\frac{\sum_{n}|w[n]|^2}{ \left| \sum_{n} w[n] \right|^2}\)</span> and
<span class="math inline">\(PS_{n}=\left| \frac{X_{v,n}}{\sum_n
w[n]}\right|^2\)</span></p>
<h3 id="code-example">code example</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">lw = <span class="number">128</span>;</span><br><span class="line">win = hann(lw);</span><br><span class="line">lt = <span class="number">2048</span>;</span><br><span class="line">windft = fftshift(fft(win,lt));</span><br><span class="line"></span><br><span class="line">ad = <span class="built_in">abs</span>(windft).^<span class="number">2</span>;</span><br><span class="line">mg = <span class="built_in">max</span>(ad);</span><br><span class="line"></span><br><span class="line">fs = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">bw = enbw(win,fs);</span><br><span class="line"></span><br><span class="line">bdef = sum((win).^<span class="number">2</span>)/sum(win)^<span class="number">2</span>*fs;</span><br><span class="line">fprintf(<span class="string">&quot;bw: %.3f\n&quot;</span>, bw);</span><br><span class="line">fprintf(<span class="string">&quot;bdef: %.3f\n&quot;</span>, bdef);</span><br><span class="line"></span><br><span class="line">freq = -fs/<span class="number">2</span>:fs/lt:fs/<span class="number">2</span>-fs/lt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(freq,ad, bw/<span class="number">2</span>*[<span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">1</span>],mg*[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>],<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">xlim(bw*[<span class="number">-1</span> <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">Adiff = trapz(freq,ad)-bw*mg;</span><br><span class="line">fprintf(<span class="string">&quot;Adiff: %.3e\n&quot;</span>, Adiff);</span><br></pre></td></tr></table></figure>
<p>Verify that the area of the rectangle contains the same total power
as the window. <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Adiff = trapz(freq,ad)-bw*mg</span><br></pre></td></tr></table></figure> output: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bw: 11.811</span><br><span class="line">bdef: 11.811</span><br><span class="line">Adiff: 7.276e-12</span><br></pre></td></tr></table></figure></p>
<p><img src="/2023/05/29/enbw-nl/image-20230530230434715.png"
alt="image-20230530230434715" /></p>
<h2 id="noise-floor">Noise Floor</h2>
<h3 id="general-formula">General Formula</h3>
<p>signal tone power <span class="math display">\[
P_{\text{sig}} = 2 \frac{X_{w,sig}^2}{S_1^2}
\]</span></p>
<p>noise power <span class="math display">\[
P_n = \frac{X_{w,n}^2}{S_2}
\]</span></p>
<p>Then, displayed <strong>SNR</strong> is obtained <span
class="math display">\[\begin{align}
\mathrm{SNR} &amp;= 10\log10\left(\frac{X_{w,sig}^2}{X_{w,n}^2}\right)
\\
&amp;= 10\log_{10}\left(\frac{P_{\text{sig}}}{P_n}\right) +
10\log_{10}\left(\frac{S_1^2}{2S_2}\right) \\
&amp;= \mathrm{SNR}&#39;-10\log_{10}\left(\frac{2S_2}{S_1^2}\right) \\
\end{align}\]</span></p>
<blockquote>
<p><em>DFT's output</em> <span
class="math inline">\(\mathrm{SNR}\)</span></p>
</blockquote>
<h3 id="rect-window">Rect Window</h3>
<p>DFT bin's output <em>noise</em> standard deviation (<em>rms</em>)
value is proportional to <span class="math inline">\(\sqrt{N}\)</span>,
and the DFT's output magnitude for the bin containing the <em>signal
tone</em> is proportional to <span class="math inline">\(N\)</span></p>
<p>signal tone power <span class="math display">\[
P_{\text{sig}} = 2 \frac{X_{w,sig}^2}{N^2}
\]</span></p>
<blockquote>
<p>+/- frequency spectrum and apply Parseval's theorem</p>
</blockquote>
<p>noise power <span class="math display">\[\begin{align}
P_n &amp;= \sum_{k=0}^{N-1}{\frac{(X_{w,n}(k))^2}{N^2}}  \\
&amp;= \frac{X_{w,n}^2}{N^2}\cdot N \\
&amp;= \frac{X_{w,n}^2}{N}
\end{align}\]</span></p>
<blockquote>
<p>note white noise, that is <span class="math inline">\(X_n(i) =
X_n(j)\)</span> for any <span class="math inline">\(i \neq
j\)</span></p>
</blockquote>
<p>displayed <strong>SNR</strong> <span
class="math display">\[\begin{align}
\mathrm{SNR} &amp;= 10\log10\left(\frac{X_{w,sig}^2}{X_{w,n}^2}\right)
\\
&amp;= 10\log_{10}\left(\frac{P_{\text{sig}}N^2}{P_n2N}\right) \\
&amp;= 10\log_{10}\left(\frac{P_{\text{sig}}}{P_n}\right) +
10\log_{10}\left(\frac{N}{2}\right) \\
&amp;= \mathrm{SNR}&#39; - 10\log_{10}(2/N)
\end{align}\]</span></p>
<p>If we increase a DFT's size from <span
class="math inline">\(N\)</span> to <span
class="math inline">\(2N\)</span>, the DFT's output SNR increased by
3dB. So we say that a DFT's <strong>processing gain</strong> increases
by 3dB whenever <span class="math inline">\(N\)</span> is doubled.</p>
<blockquote>
<p>[<a
href="http://individual.utoronto.ca/schreier/lectures/2015/1.pdf">http://individual.utoronto.ca/schreier/lectures/2015/1.pdf</a>]</p>
</blockquote>
<h2 id="no.-of-nonzero-fft-bins">No. of nonzero FFT bins</h2>
<p>The problem with sine-wave scaling is that the noise power is, on
average, <em>evenly distributed over all FFT bins</em>, whereas the
sine-wave power is concentrated in <em>only a few bins</em>. With
sine-wave scaling, the power of individual sine-wave components can be
read directly from the spectral plot, but in order to determine the
noise power, the powers of all the noise bins must be added
together.</p>
<p><img src="/2023/05/29/enbw-nl/snr_final.drawio.svg"
alt="snr_final.drawio" /></p>
<p><span class="math display">\[\begin{align}
\mathrm{SNR} &amp;= \frac{X_\text{sig}^2}{X_\text{n}^2N} \\
&amp;= \frac{X_\text{sig}^2\cdot \sum_k W_k^2}{X_\text{n}^2N\cdot \sum_k
W_k^2} \\
&amp;= \frac{\sum_\text{nb} X_\text{w,sig}^2}{N X_\text{w,n}^2}
\end{align}\]</span></p>
<blockquote>
<p>The number of nonzero signal bins for the Hann window is <span
class="math inline">\(\mathrm{nb} = 3\)</span></p>
<p><img src="/2023/05/29/enbw-nl/image-20240522213736493.png"
alt="image-20240522213736493" /></p>
<p>where <span class="math inline">\(\mathrm{NBW} =
\frac{\sum_{n}|w[n]|^2}{ \left| \sum_{n} w[n] \right|^2}\)</span></p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% excerpt of A.4 An Example in Pavan, Schreier and Temes, &quot;Understanding Delta-Sigma Data Converters, Second Edition&quot; ISBN 978-1-119-25827-8</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Compute modulator output and actual NTF</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">OSR = <span class="number">32</span>;</span><br><span class="line">ntf0 = synthesizeNTF(<span class="number">5</span>,OSR,<span class="number">1</span>);</span><br><span class="line">N = <span class="number">64</span>*OSR;</span><br><span class="line">fbin = <span class="number">11</span>;</span><br><span class="line">u = <span class="number">1</span>/<span class="number">2</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fbin/N*[<span class="number">0</span>:N<span class="number">-1</span>]);</span><br><span class="line">[v tmp1 tmp2 y] = simulateDSM(u,ntf0);</span><br><span class="line">k = <span class="built_in">mean</span>(<span class="built_in">abs</span>(y)/<span class="built_in">mean</span>(y.^<span class="number">2</span>))</span><br><span class="line">ntf = ntf0 / (k + (<span class="number">1</span>-k)*ntf0);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Compute windowed FFT and NBW</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">w = hann(N); <span class="comment">% or ones(1,N) or hann(N).^2</span></span><br><span class="line">nb = <span class="number">3</span>; <span class="comment">% 1 for Rect; 5 for Hann^2</span></span><br><span class="line">w1 = norm(w,<span class="number">1</span>);</span><br><span class="line">w2 = norm(w,<span class="number">2</span>);</span><br><span class="line">NBW = (w2/w1)^<span class="number">2</span></span><br><span class="line">V = fft(w.*v)/(w1/<span class="number">2</span>);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Compute SNR</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">signal_bins = fbin + [-(nb<span class="number">-1</span>)/<span class="number">2</span>:(nb<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">inband_bins = <span class="number">0</span>:N/(<span class="number">2</span>*OSR);</span><br><span class="line">noise_bins = setdiff(inband_bins,signal_bins);</span><br><span class="line">snr = dbp(sum(<span class="built_in">abs</span>(V(signal_bins+<span class="number">1</span>)).^<span class="number">2</span>)/sum(<span class="built_in">abs</span>(V(noise_bins+<span class="number">1</span>)).^<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h2 id="demo">demo</h2>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%https://aaronscher.com/Course_materials/Communication_Systems/documents/PSD_Autocorrelation_Noise.pdf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Clear variables. clear command window, close all figures:</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"><span class="comment">%%%Setup and define variables</span></span><br><span class="line">f0=<span class="number">10</span>; <span class="comment">%frequency of sinusoidal signal (Hz)</span></span><br><span class="line">fs=<span class="number">100</span>; <span class="comment">%sampling frequency (Hz)</span></span><br><span class="line">Ts=<span class="number">1</span>/fs; <span class="comment">%sampling period (seconds)</span></span><br><span class="line">N0=<span class="number">3000</span>; <span class="comment">%number of samples</span></span><br><span class="line">t=[<span class="number">0</span>:Ts:Ts*(N0<span class="number">-1</span>)]; <span class="comment">%Sample times</span></span><br><span class="line">noise_PSD=<span class="number">.5</span>; <span class="comment">%This is the desired noise power spectral density in W/Hz.</span></span><br><span class="line">variance=noise_PSD*fs;<span class="comment">% Variance = sigma^2</span></span><br><span class="line">sigma=<span class="built_in">sqrt</span>(variance);</span><br><span class="line">noise=transpose(sigma*<span class="built_in">randn</span>(N0,<span class="number">1</span>));<span class="comment">%create sampled white Gaussian noise.</span></span><br><span class="line">xsignal=<span class="number">20</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t); <span class="comment">%create sampled sinusoidal signal</span></span><br><span class="line">x=xsignal+noise; <span class="comment">%Add signal to noise</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">histogram(noise,<span class="number">30</span>) <span class="comment">%plot histogram</span></span><br><span class="line">set(gca,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>) <span class="comment">%set font size of axis tick labels to 18</span></span><br><span class="line">xlabel(<span class="string">&#x27;Noise amplitude&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Frequency of occurance&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">title(<span class="string">&#x27;Simulated histogram of white Gaussian noise&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">SNR_try1=snr(xsignal,noise); <span class="comment">%calculate SNR using built in &quot;snr&quot; function.</span></span><br><span class="line">SNR_try2=<span class="number">10</span>*<span class="built_in">log10</span>(sum(xsignal.^<span class="number">2</span>)/sum(noise.^<span class="number">2</span>)); <span class="comment">%manually calculate SNR.</span></span><br><span class="line"><span class="comment">%If everything is correct, the two SNR calculations above should agree.</span></span><br><span class="line"><span class="comment">%Plot noise in time-domain</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,x)</span><br><span class="line">set(gca,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>) <span class="comment">%set font size of axis tick labels to 18</span></span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">title(<span class="string">&#x27;Noisey sinusoid&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">grid on</span><br><span class="line"><span class="comment">%Plot power spectral density (PSD) of noise using three different methods:</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%Method 1. Calcululate PSD from amplitude spectrum</span></span><br><span class="line">N=<span class="number">2</span>^<span class="number">16</span>; <span class="comment">%Number of discrete points in the FFT</span></span><br><span class="line">y=fft(x,N)/fs; <span class="comment">%fft of noise</span></span><br><span class="line">z=fftshift(y);<span class="comment">%center noise spectrum</span></span><br><span class="line">f_vec=[<span class="number">0</span>:<span class="number">1</span>:N<span class="number">-1</span>]*fs/N-fs/<span class="number">2</span>; <span class="comment">%designate sample frequencies</span></span><br><span class="line">amplitude_spectrum=<span class="built_in">abs</span>(z); <span class="comment">%compute two-sided amplitude spectrum</span></span><br><span class="line">ESD1=amplitude_spectrum.^<span class="number">2</span>; <span class="comment">%ESD = |F(w)|^2;</span></span><br><span class="line">PSD1=ESD1/((N0<span class="number">-1</span>)*Ts);<span class="comment">% PSD=ESD/T where T = total time of sample</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(f_vec,<span class="number">10</span>*<span class="built_in">log10</span>(PSD1));</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;dB/Hz&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectral density - method 1&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">grid on</span><br><span class="line">set(gcf,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;w&#x27;</span>); <span class="comment">%set background color from grey (default) to white</span></span><br><span class="line">axis tight</span><br><span class="line"><span class="comment">%calculate average power using PSD calclated from method 1:</span></span><br><span class="line">Average_power_method_1=sum(PSD1)*fs/N; <span class="comment">% Pav=sum(PSD)*delta_f where delta_f=fs/N;</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%Method 2 - Calculate PSD from autocorrelation</span></span><br><span class="line">time_lag=((-<span class="built_in">length</span>(x)+<span class="number">1</span>):<span class="number">1</span>:(<span class="built_in">length</span>(x)<span class="number">-1</span>))*Ts;</span><br><span class="line">auto_cor=xcorr(x,x)/fs; <span class="comment">%Use xcorr function to find PSD</span></span><br><span class="line">y=<span class="number">1</span>/fs*fft(auto_cor,N); <span class="comment">%fft of auto correlation function</span></span><br><span class="line">PSD2=<span class="built_in">abs</span>(<span class="number">1</span>/(N0<span class="number">-1</span>)*fftshift(fft(auto_cor,N)));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(f_vec,<span class="number">10</span>*<span class="built_in">log10</span>(PSD2));<span class="comment">%use convolution</span></span><br><span class="line">xlabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;dB/Hz&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectral density - method 2&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">grid on</span><br><span class="line">set(gcf,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;w&#x27;</span>); <span class="comment">%set background color from grey (default) to white</span></span><br><span class="line">axis tight</span><br><span class="line"><span class="comment">%calculate average power using PSD calclated from method 1:</span></span><br><span class="line">Average_power_method_2=sum(PSD2)*fs/N; <span class="comment">%Pav=sum(PSD)*delta_f where delta_f=fs/N;</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%Method 3 - Calculate PSD using built in pwelch function</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>)</span><br><span class="line">PSD3=periodogram(x,[],N,fs,<span class="string">&#x27;centered&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">10</span>*<span class="built_in">log10</span>(PSD3))</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;dB/Hz&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectral density - method 3&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">grid on</span><br><span class="line">set(gcf,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;w&#x27;</span>); <span class="comment">%set background color from grey (default) to white</span></span><br><span class="line">axis tight</span><br><span class="line">Average_power_method_3=sum(PSD3)*fs/N; <span class="comment">%Pav=sum(PSD)*delta_f where delta_f=fs/N;</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%Calculate mean and average PSD of noise:</span></span><br><span class="line">PSD_noise=periodogram(noise,[],N,fs,<span class="string">&#x27;centered&#x27;</span>);</span><br><span class="line">Average_noise_PSD=<span class="built_in">mean</span>(PSD_noise);</span><br><span class="line">Mean_noise=<span class="built_in">mean</span>(noise);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/29/enbw-nl/image-20230531004822838.png"
alt="image-20230531004822838" /></p>
<p><img src="/2023/05/29/enbw-nl/image-20230531005008418.png"
alt="image-20230531005008418" /></p>
<blockquote>
<p>The power spectral density plots for methods 2 and 3 exactly match
that for method 1 (shown above).</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Schmid, H. (2012). How to use the FFT and Matlab's pwelch function
for signal and noise simulations and measurements. URL:<a
href="http://www.schmid-werren.ch/hanspeter/publications/2012fftnoise.pdf">http://www.schmid-werren.ch/hanspeter/publications/2012fftnoise.pdf</a></p>
<p>Bonnie C.Baker. Reading and Using Fast Fourier Transforms (FFT)
URL:<a
href="http://ww1.microchip.com/downloads/en/appnotes/00681a.pdf">http://ww1.microchip.com/downloads/en/appnotes/00681a.pdf</a></p>
<p>FFT analysis: SNR and Noise level vary with FFT Window size URL:<a
href="https://www.virtins.com/forum/viewtopic.php?f=7&amp;t=1382">https://www.virtins.com/forum/viewtopic.php?f=7&amp;t=1382</a></p>
<p>Lyons, R. G. (2011). Understanding digital signal processing (3rd
ed.). Prentice Hall</p>
<p>Stefan Scholl, "Exact Signal Measurements using FFT
Analysis",Microelectronic Systems Design Research Group, TU
Kaiserslautern, Germany. [<a
href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/4293/file/exact_fft_measurements.pdf">pdf</a>]</p>
<p>enbw Matlab URL:<a
href="https://www.mathworks.com/help/signal/ref/enbw.html">https://www.mathworks.com/help/signal/ref/enbw.html</a></p>
<p>Aaron Scher. PSD, Autocorrelation, and Noise in MATLAB [<a
href="https://aaronscher.com/Course_materials/Communication_Systems/documents/PSD_Autocorrelation_Noise.pdf">pdf</a>]</p>
<p>Aaron Scher. FFT, total energy, and energy spectral density
computations in MATLAB [<a
href="https://aaronscher.com/Course_materials/Communication_Systems/documents/Energy_signals_matlab_tutorial.pdf">pdf</a>]</p>
<p>Amplitude Estimation and Zero Padding URL:<a
href="https://www.mathworks.com/help/signal/ug/amplitude-estimation-and-zero-padding.html">https://www.mathworks.com/help/signal/ug/amplitude-estimation-and-zero-padding.html</a></p>
<p>Harris, F. (1978). On the use of windows for harmonic analysis with
the discrete Fourier transform. Proceedings of the IEEE, 66, 51-83. [<a
href="https://www.fceia.unr.edu.ar/prodivoz/Harris_1978.pdf">pdf</a>]</p>
<p>Harris, F. J. . (1976). Windows, harmonic analysis and the discrete
fourier transform. [<a
href="https://apps.dtic.mil/sti/pdfs/ADA034956.pdf">pdf</a>]</p>
<p>Wang Hongwei. Virtins. Evaluation of Various Window Functions using
Multi-Instrument [<a
href="https://www.virtins.com/doc/D1003/Evaluation_of_Various_Window_Functions_using_Multi-Instrument_D1003.pdf">pdf</a>]</p>
<p>Properties of FFT Windows Used in Stable32 [<a
href="http://www.wriley.com/Properties%20of%20FFT%20Windows%20Used%20in%20Stable32.pdf">pdf</a>]</p>
<p>Solomon, Jr, O M. PSD computations using Welch's method. [Power
Spectral Density (PSD)]. United States. https://doi.org/10.2172/5688766
[<a href="https://www.osti.gov/servlets/purl/5688766">pdf</a>]</p>
<p>Measure Power of Deterministic Periodic Signals [<a
href="https://www.mathworks.com/help/signal/ug/measuring-the-power-of-deterministic-periodic-signals.html">https://www.mathworks.com/help/signal/ug/measuring-the-power-of-deterministic-periodic-signals.html</a>]</p>
<p>Mathuranathan. Equivalent noise bandwidth (ENBW) of window functions.
[<a
href="https://www.gaussianwaves.com/2020/09/equivalent-noise-bandwidth-enbw-of-window-functions/">https://www.gaussianwaves.com/2020/09/equivalent-noise-bandwidth-enbw-of-window-functions/</a>]</p>
<p>recordingblogs, Equivalent noise bandwidth [<a
href="https://www.recordingblogs.com/wiki/equivalent-noise-bandwidth">https://www.recordingblogs.com/wiki/equivalent-noise-bandwidth</a>]</p>
<p>unpingco, Python for Signal Processing [<a
href="https://github.com/unpingco/Python-for-Signal-Processing/blob/master/Windowing_Part2.ipynb">https://github.com/unpingco/Python-for-Signal-Processing/blob/master/Windowing_Part2.ipynb</a>]</p>
<p>Pavan, Schreier and Temes, "Understanding Delta-Sigma Data
Converters, Second Edition" ISBN 978-1-119-25827-8</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Add endcap and tapcell in Innovus</title>
    <url>/2022/02/15/endcap_tapcell_floorplan/</url>
    <content><![CDATA[<p>First place place hard macro and add placement halo, then execute the
following code to add endcap and tapcell.</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">deleteFill -prefix ENDCAP</span><br><span class="line">deleteFill -prefix WELL</span><br><span class="line"></span><br><span class="line">setEndCapMode \</span><br><span class="line">    -leftEdge BOUNDARY_RIGHTBWP16P90CPD \</span><br><span class="line">    -rightEdge BOUNDARY_LEFTBWP16P90CPD \</span><br><span class="line">    -leftBottomCorner BOUNDARY_NCORNERBWP16P90CPD \</span><br><span class="line">    -leftTopCorner BOUNDARY_PCORNERBWP16P90CPD \</span><br><span class="line">    -rightTopEdge FILL3BWP16P90CPD \</span><br><span class="line">    -rightBottomEdge FILL3BWP16P90CPD \</span><br><span class="line">    -topEdge <span class="string">&quot;BOUNDARY_PROW2BWP16P90CPD BOUNDARY_PROW3BWP16P90CPD&quot;</span></span><br><span class="line">    -bottomEdge <span class="string">&quot;BOUNDARY_NROW2BWP16P90CPD BOUNDARY_NROW3BWP16P90CPD&quot;</span> \</span><br><span class="line">    -boundary_tap true</span><br><span class="line"></span><br><span class="line">set_well_tap_mode \</span><br><span class="line">    -rule <span class="number">33</span></span><br><span class="line">    -bottom_tap_cell BOUNDARY_NTAPBWP16P90CPD \</span><br><span class="line">    -top_tap_cell BOUNDARY_PTAPBWP16P90CPD \</span><br><span class="line">    -cell TAPCELLBWP16P90CPD</span><br><span class="line"></span><br><span class="line">addEndCap</span><br><span class="line">addWellTap -checkerBoard -cell TAPCELLBWP16P90CPD -cellInterval <span class="number">160</span></span><br></pre></td></tr></table></figure>
<p><img
src="/2022/02/15/endcap_tapcell_floorplan/endcap_tapcell_floorplan.drawio.svg"
alt="endcap_tapcell_floorplan.drawio" /></p>
<p><strong>REF:</strong> <a
href="https://github.com/StanfordAHA/PowerDomainDesign/blob/c280a35f01ad0617ff054b925c1d5c2652a0f4e1/scripts/layout_pe_tile_new.power.tcl#L94-L113">StanfordAHA/PowerDomainDesign</a></p>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Dual Diode and ggNMOS</title>
    <url>/2022/06/23/esd-dual-diodes-ggnmos/</url>
    <content><![CDATA[<h2 id="hia-diode">HIA diode</h2>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20230517233753530.png"
alt="image-20230517233753530" /></p>
<blockquote>
<p><em>HIA</em> = High Amp</p>
<p>lateral diode: <strong>perimeter</strong> is key DRC rule for ESD
diode</p>
<p>HIA diode process is same with regular junction diode</p>
</blockquote>
<h2 id="strap">STRAP</h2>
<p>A "strap" refers to a low-impedance connection</p>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20230518001007350.png"
alt="image-20230518001007350" /></p>
<p>NWDMY = NWDMY1, NWDMY2</p>
<p>STRAP = NWSTRAP or PWSTRAP</p>
<p>NWSTRAP = {NP &amp; OD} &amp; {NW not {NW INTERACT NWDMY}}</p>
<p>PWSTRAP = {PP &amp; OD} not NW</p>
<table>
<thead>
<tr class="header">
<th>cell  pin</th>
<th>PLUS</th>
<th>MINUS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>N diode</strong></td>
<td>PWSTRAP</td>
<td>\</td>
</tr>
<tr class="even">
<td><strong>P diode</strong></td>
<td>\</td>
<td>NWSTRAP</td>
</tr>
</tbody>
</table>
<h3 id="calibre-rulenot">Calibre Rule::NOT</h3>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20230518005758993.png"
alt="image-20230518005758993" /></p>
<h3 id="calibre-ruleinteract">Calibre Rule::INTERACT</h3>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20230518010124496.png"
alt="image-20230518010124496" /></p>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20230518010758342.png"
alt="image-20230518010758342" /></p>
<h2 id="dual-stacked-diodes">Dual Stacked Diodes</h2>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20230518012456390.png"
alt="image-20230518012456390" /></p>
<blockquote>
<p>PS: I/O to GND positively</p>
<p>NS: I/O to GND negatively</p>
<p>PD: I/O to VDD positively</p>
<p>ND: I/O to VDD negatively</p>
</blockquote>
<p>Dual diode should be used with <strong>power clamp</strong> for
<strong>PS</strong> and <strong>ND</strong> path</p>
<h3 id="pmos-power-clamp">PMOS power clamp</h3>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/power_clamp_pmos.drawio.svg"
alt="power_clamp_pmos.drawio" /></p>
<h2 id="ggnmos-grounded-gate-nmos">ggNMOS (grounded-gate NMOS)</h2>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20220623231619052.png"
alt="image-20220623231619052" /></p>
<blockquote>
<p>The drain (D) is connected to an I/O pad and the gate (G) is
grounded.</p>
<p>To ensure “zero” leakage of the ESD protection structure under normal
operations.</p>
<p>To to protect gate of core device, tie-high and tie-low shall be used
when used as secondary ESD protecton.</p>
</blockquote>
<h3 id="positive-esd-transient-at-io-pad">Positive ESD transient at I/O
pad</h3>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20220623233019912.png"
alt="image-20220623233019912" /></p>
<ol type="1">
<li><strong>DB</strong> junction is reverse-biased all the way to its
breakdown.</li>
<li>Avalance multiplication takes place and generates electron-hole
pairs</li>
<li>Hole current flows into the ground via the *B-region** and build up
a potential, VR, across the lateral parasitic resistance R</li>
<li>As VR increases, the <strong>BS</strong> junction turns on,
eventually triggers the parasitic lateral NPN transistor Q
(<strong>DBS</strong>)</li>
</ol>
<h3 id="negative-esd-transient-at-io-pad">Negative ESD transient at I/O
pad</h3>
<p><img
src="/2022/06/23/esd-dual-diodes-ggnmos/image-20220623233634452.png"
alt="image-20220623233634452" /></p>
<p>The forward-biased parasitic diode, <strong>BD</strong>, will shunt
the transient</p>
<blockquote>
<p>ggNMOS is commonly used in the GPIO provided by foundry, which
alleviate the ESD design burden of customer.</p>
<p>These GPIO is self-protective thanks to the ggNMOS.</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Wang, Albert Z. H. 2002. On-chip ESD protection for integrated
circuits: an IC design perspective. Boston, Mass: Kluwer Academic
Publishers.</p>
<p>Wang, Anq i &amp; Feng, H.G &amp; Gong, K &amp; Zhan, Ruqing &amp;
Stine, J. (2001). On-chip ESD protection design for integrated circuits:
An overview for IC designers. Microelectronics Journal. 32. 733-747.
10.1016/S0026-2692(01)00060-X.</p>
<p>Feng, Haigang, Ke Gong, Rouying Zhan and Albert Z. Wang. “On-Chip ESD
Protection Design for Ics.” (2001).</p>
<p>Introduction: ESD protection concepts for I/Os. URL: <a
href="https://monthly-pulse.com/2022/03/29/introduction-esd-protection-concepts-for-i-os/">https://monthly-pulse.com/2022/03/29/introduction-esd-protection-concepts-for-i-os/</a></p>
<p>Answer: What does "strap" mean in this context? <a
href="https://electronics.stackexchange.com/a/591759?stw=2">https://electronics.stackexchange.com/a/591759?stw=2</a></p>
<p>Hammer VLSI Flow URL: <a
href="https://fires.im/micro22-slides-pdf/04_hammer_vlsi.pdf">https://fires.im/micro22-slides-pdf/04_hammer_vlsi.pdf</a></p>
<p>Calibre Rule Writing 2009</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>ESD and Protection</title>
    <url>/2022/06/09/esd-protection/</url>
    <content><![CDATA[<p>The <strong>ESD design window</strong> is defined as the difference
between the breakdown voltage of the functional circuit (red line) and
the maximum signal voltage (blue line) <img
src="/2022/06/09/esd-protection/esddesignwindow-evolution.jpg"
alt="esddesignwindow-evolution" /></p>
<h2 id="tlp">TLP</h2>
<p>What makes <strong>TLP</strong> different than <strong>ESD</strong>
?</p>
<ul>
<li><strong>ESD</strong> tests simulate real world events (HBM, MM,
CDM)</li>
<li><strong>TLP</strong> does not simulate any real-world event</li>
<li><strong>ESD</strong> tests record failure level
(<em>Qualification</em>)</li>
<li><strong>TLP</strong> tests record failure level and device behavior
(<em>Characterization</em>)</li>
</ul>
<blockquote>
<p>TLP is not a qualification test, but a characterization method, which
describes the resistance of a device for a given stimulus, aka.
<em>Device Characterization</em></p>
<p>Unlike ESD waveforms, TLP does not mimic any real world event</p>
</blockquote>
<p><img src="/2022/06/09/esd-protection/image-20220609234548431.png"
alt="image-20220609234548431" /></p>
<h3 id="tlp-and-curve-tracing">TLP and Curve Tracing</h3>
<ul>
<li>Curve Tracing is DC; TLP is a short pulse
<ul>
<li>Shorter pulse - Reduced duty cycle, less heating, which means higher
voltage before failure</li>
<li>Controlled Impedance - Allows device behavior to be observed</li>
</ul></li>
<li>Both measure resistance of device with increasing voltage</li>
</ul>
<p><img src="/2022/06/09/esd-protection/image-20220609235252444.png"
alt="image-20220609235252444" /></p>
<h3 id="device-characterization-with-tlp">Device Characterization with
TLP</h3>
<ul>
<li>Turn-on time</li>
<li>Snapback voltage</li>
<li>Performance changes with rise time</li>
</ul>
<p><img src="/2022/06/09/esd-protection/image-20220609235427204.png"
alt="image-20220609235427204" /></p>
<h3 id="vf-tlp-and-cdm-differences">VF-TLP and CDM differences</h3>
<p>Question:</p>
<p>How well will VF-TLP results predict CDM testing performance?</p>
<p>Answer:</p>
<p>VF-TLP can be a guide to CDM failure levels, and provide a lot of
understanding of a circuit's operation during CDM stressing, but simple
correlations between VF-TLP failure current level and CDM withstand
voltage levels are difficult to establish.</p>
<h2 id="snapback-device">snapback device</h2>
<p>Unfortunately, this protection concept is not effective anymore in
advanced FinFET technology. Our analysis showed that both core and IO
transistors are damaged at the onset of snapback in several FinFET
processes. <img src="/2022/06/09/esd-protection/snapback.PNG"
alt="snapback" /></p>
<h2 id="power-clamp">power clamp</h2>
<p>Thanks to the device scaling the area is actually reasonable.
However, the leakage becomes the main bottleneck. <img
src="/2022/06/09/esd-protection/bigfet-concept.jpg"
alt="bigfet-concept" /></p>
<h2 id="esd-diode">ESD diode</h2>
<p><img src="/2022/06/09/esd-protection/image-20220618123654830.png"
alt="image-20220618123654830" /></p>
<p><img src="/2022/06/09/esd-protection/image-20220618123821117.png"
alt="image-20220618123821117" /></p>
<p><img src="/2022/06/09/esd-protection/image-20220618124644879.png"
alt="image-20220618124644879" /></p>
<blockquote>
<p>both diode are reverse-biased in normal operation, the PN Junction
capacitance is proportional to forward-bias voltage</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>Device</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ndio_mac</td>
<td>N+/P-well Diode</td>
</tr>
<tr class="even">
<td>pdio_mac</td>
<td>P+/N-well Diode</td>
</tr>
<tr class="odd">
<td>ndio_18_mac</td>
<td>1.8V N+/P-well Diode</td>
</tr>
<tr class="even">
<td>pdio_18_mac</td>
<td>1.8V P+/N-well Diode</td>
</tr>
<tr class="odd">
<td>ndio_hia18_mac</td>
<td>N-HIA Diode</td>
</tr>
<tr class="even">
<td>pdio_hia18_mac</td>
<td>P-HIA Diode</td>
</tr>
<tr class="odd">
<td>ndio_gated18_mac</td>
<td>Thick Oxide N-Gated Diode</td>
</tr>
<tr class="even">
<td>pdio_gated18_mac</td>
<td>Thick Oxide P-Gated Diode</td>
</tr>
</tbody>
</table>
<blockquote>
<p>HIA_DIO can be used for logic or high speed circuits ESD
protection</p>
<p>HIA: high current application purpose (High Amp)</p>
<p>There is no process difference between HIA_DIO and regular diode</p>
</blockquote>
<p><img src="/2022/06/09/esd-protection/image-20220618191312489.png"
alt="image-20220618191312489" /></p>
<p><img src="/2022/06/09/esd-protection/image-20220618183241535.png"
alt="image-20220618183241535" /></p>
<p><img src="/2022/06/09/esd-protection/image-20220618191405428.png"
alt="image-20220618191405428" /></p>
<table>
<thead>
<tr class="header">
<th>width (W)</th>
<th>2.020E-07</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Length (L)</strong></td>
<td>1.922E-06</td>
</tr>
<tr class="even">
<td><strong>ArrayY (Ny)</strong></td>
<td>2</td>
</tr>
<tr class="odd">
<td><strong>Perimeter (Ny*2*(W+L))</strong></td>
<td>8.496E-06</td>
</tr>
<tr class="even">
<td><strong>Area (Ny*W*L)</strong></td>
<td>7.76488E-13</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><p>diode is drain/source originated, which is different from MOS
(Gate originated)</p></li>
<li><p>The perimeter of diode in DRC is different from that in PERC
deck, where PERC excludes the the left and right edge of OD</p></li>
</ul>
</blockquote>
<h3 id="mos">MOS</h3>
<p><img src="/2022/06/09/esd-protection/image-20220618191906210.png"
alt="image-20220618191906210" /></p>
<p><img src="/2022/06/09/esd-protection/image-20220618192253726.png"
alt="image-20220618192253726" /></p>
<p><img src="/2022/06/09/esd-protection/image-20220618192325486.png"
alt="image-20220618192325486" /></p>
<blockquote>
<p><code>l</code> in netlist has different definition for MOS and
diode.</p>
<p>MOS: length of channel</p>
<p>diode: Gate space</p>
</blockquote>
<h2 id="reference">Reference</h2>
<p>Introduction to Transmission Line Pulse (TLP), URL: <a
href="https://tools.thermofisher.com/content/sfs/brochures/TLP%20Presentation%20May%202009.pdf">https://tools.thermofisher.com/content/sfs/brochures/TLP%20Presentation%20May%202009.pdf</a></p>
<p>VF-TLP and CDM differences, URL: <a
href="https://www.grundtech.com/app-note-vf-tlp-cdm-differences">https://www.grundtech.com/app-note-vf-tlp-cdm-differences</a></p>
<p>ESD-Testing: HBM to very fast TLP URL: <a
href="https://www.thierry-lequeu.fr/data/ESREF/2004/Tut5.pdf">https://www.thierry-lequeu.fr/data/ESREF/2004/Tut5.pdf</a></p>
<p>S. Kim et al., "Technology Scaling of ESD Devices in State of the Art
FinFET Technologies," 2020 IEEE Custom Integrated Circuits Conference
(CICC), 2020, pp. 1-6, doi: 10.1109/CICC48029.2020.9075899.</p>
<p>Barth, Jon. "TLP and VFTLP Testing of Integrated Circuit ESD
Protection." (2015). ESD protection for FinFET processes URL: <a
href="https://monthly-pulse.com/2021/01/19/esd-protection-for-finfet-processes/">https://monthly-pulse.com/2021/01/19/esd-protection-for-finfet-processes/</a></p>
<p>Yuanzhong Zhou, D. Connerney, R. Carroll and T. Luk, "Modeling MOS
snapback for circuit-level ESD simulation using BSIM3 and VBIC models,"
Sixth international symposium on quality electronic design (isqed'05),
2005, pp. 476-481, doi: 10.1109/ISQED.2005.81.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Fourier Analysis 101</title>
    <url>/2023/05/15/fourier101/</url>
    <content><![CDATA[<h2 id="the-dirac-comb-function">The Dirac Comb function</h2>
<h3 id="impulse-train">impulse train</h3>
<p><img src="/2023/05/15/fourier101/image-20231026001721884.png"
alt="image-20231026001721884" /></p>
<p><img src="/2023/05/15/fourier101/image-20231026001952947.png"
alt="image-20231026001952947" /></p>
<blockquote>
<p>The Fourier transform of a periodic impulse train in the time domain
with period <span class="math inline">\(T\)</span> is a periodic impulse
train in the frequency domain with period <span
class="math inline">\(2\pi/T\)</span></p>
</blockquote>
<p><img src="/2023/05/15/fourier101/image-20231026002244212.png"
alt="image-20231026002244212" /></p>
<h3 id="the-discrete-time-counterpart">The discrete-time
counterpart</h3>
<p><img src="/2023/05/15/fourier101/image-20231026002344519.png"
alt="image-20231026002344519" /></p>
<p><img src="/2023/05/15/fourier101/image-20231026002420723.png"
alt="image-20231026002420723" /></p>
<h2 id="the-unit-impulse-function">The Unit Impulse Function</h2>
<h3 id="scaled-deltat">scaled <span
class="math inline">\(\delta(t)\)</span></h3>
<p><span class="math display">\[
x(t)\delta(t-\tau) = x(\tau)\delta(t-\tau)
\]</span></p>
<blockquote>
<p>the impulse is zero everywhere except when <span
class="math inline">\(t=\tau\)</span></p>
<p><a
href="https://lpsa.swarthmore.edu/BackGround/ImpulseFunc/ImpFunc.html">[https://lpsa.swarthmore.edu/BackGround/ImpulseFunc/ImpFunc.html]</a></p>
</blockquote>
<h3 id="time-scaled">time-scaled</h3>
<p><span class="math display">\[
\delta(at)=\frac{1}{|a|}\delta(t)
\]</span></p>
<p>An example</p>
<p><span class="math display">\[
\delta(2t-1)=\frac12\delta\left(t-\frac12\right)
\]</span></p>
<blockquote>
<p><a
href="https://dsp.stackexchange.com/a/67699">[https://dsp.stackexchange.com/a/67699]</a></p>
</blockquote>
<h3 id="sifting-property">sifting property</h3>
<blockquote>
<p>The mathematical representation of a signal as the superposition of
scaled and shifted unit impulse functions</p>
</blockquote>
<p><img src="/2023/05/15/fourier101/image-20240501134030537.png"
alt="image-20240501134030537" /></p>
<p><span class="math display">\[
\int\limits_a^b {\delta (t - \lambda ) \cdot f(t)dt}  = \left\{
{\begin{array}{*{20}{c}}
{f(\lambda ),\quad a &lt; \lambda  &lt; b}\\
{0,\quad otherwise}
\end{array}} \right
\]</span></p>
<blockquote>
<p>This is called the "sifting" property because the impulse function
<span class="math inline">\(\delta(t-\lambda)\)</span> sifts through the
function <span class="math inline">\(f(t)\)</span> and pulls out the
value <span class="math inline">\(f(\lambda)\)</span></p>
</blockquote>
<h2 id="periodic-signal">Periodic Signal</h2>
<h3 id="dfs-for-periodic-sequences">DFS for periodic sequences</h3>
<p>AKA <strong>discrete-time Fourier series (DTFS)</strong></p>
<blockquote>
<p>Any <em>periodic sequence</em> can be represented as <em>a sum of
complex exponential sequences</em>.</p>
</blockquote>
<p>⭐Analysis equation <span class="math display">\[
\tilde{X}[k] = \sum_{n=0}^{N-1}\tilde{x}[n]W_N^{kn}
\]</span> where <span class="math inline">\(W_N =
e^{-j(2\pi/N)}\)</span></p>
<p>⭐Synthesis equation <span class="math display">\[
\tilde{x}[n] = \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}[k]W_N^{-kn}
\]</span></p>
<blockquote>
<p>The multiplicative constant <span class="math inline">\(1/N\)</span>
is included in above equation for convenience. It could also be absorbed
into the definition of <span
class="math inline">\(\tilde{X}[k]\)</span></p>
</blockquote>
<p>In general <span class="math display">\[
W_N^{n+lN} = e^{-j(2\pi/N)(n+lN)} =e^{-j(2\pi/N)n}=W_N^n
\]</span> The Fourier series coefficients <span
class="math inline">\(\tilde{X}[k]\)</span> can be interpreted to be</p>
<ul>
<li>a sequence of finite length, for <span
class="math inline">\(k=0,...,(N-1)\)</span>, and zero otherwise</li>
<li>a periodic sequence defined for all <span
class="math inline">\(k\)</span>, with period <span
class="math inline">\(N\)</span></li>
</ul>
<p>Clearly, both of these interpretations are acceptable, since in
<em>Synthesis equation</em> we use only the values of</p>
<p><span class="math inline">\(\tilde{X}[k]\)</span> for <span
class="math inline">\(0 \leq k \leq (N-1)\)</span>.</p>
<p>An advantage to interpreting the Fourier series coefficients <span
class="math inline">\(\tilde{X}[k]\)</span> as a periodic sequence is
that there is then a <em>duality</em> between the time and frequency
domains for the Fourier series representation of periodic sequences.</p>
<h4 id="duality">Duality</h4>
<p>An exact duality exists between the time and frequency domains in the
DFS representation that does not exist in the DTFT and z-transform
representation of sequences</p>
<p>This duality property is summarized as follows:</p>
<p>If <span class="math display">\[
\tilde{x}[n] \overset{DFS}\longleftrightarrow \tilde{X}[k]
\]</span> then <span class="math display">\[
\tilde{X}[n] \overset{DFS}\longleftrightarrow N\tilde{x}[-k]
\]</span></p>
<h3 id="the-fourier-transform-of-periodic-signals">The Fourier Transform
of Periodic Signals</h3>
<blockquote>
<p>use the DFS representation to obtain a DTFT representation of
periodic signal:</p>
</blockquote>
<ol type="1">
<li><p><em>uniform convergence</em> of the Fourier transform of a
sequence (<em>DTFT</em>) requires that the sequence be <em>absolutely
summable</em>, and <em>mean-square convergence</em> requires that the
sequence be <em>square summable</em>. Periodic sequences <strong>satisfy
neither condition</strong> .</p>
<p><strong>Absolute summability is a sufficient condition</strong> for
the existence of a Fourier transform representation (<em>DTFT</em>)</p>
<p><span class="math display">\[\begin{align}
|X(e^{j\omega})| &amp;= \left| \sum_{n=-\infty}^{\infty}x[n]e^{-j\omega
n} \right| \\
&amp;\leq \sum_{n=-\infty}^{\infty}|x[n]||e^{-j\omega n}| \\
&amp;\leq \sum_{n=-\infty}^{\infty}|x[n]| \lt \infty
\end{align}\]</span></p></li>
<li><p>sequences that can be expressed as a sum of complex exponentials
can be considered to have a Fourier transform representation as a train
of impulses</p></li>
</ol>
<p>⭐If <span class="math inline">\(\tilde{x}[n]\)</span> is periodic
with period <span class="math inline">\(N\)</span> and the corresponding
<em>DFS coefficients</em> are <span
class="math inline">\(\tilde{X}[k]\)</span>, then the Fourier transform
of <span class="math inline">\(\tilde{x}[n]\)</span> is defined to be
the <strong>impulse train</strong> <span class="math display">\[
\tilde{X}(e^{j\omega}) =
\sum_{k=-\infty}^{\infty}\frac{2\pi}{N}\tilde{X}[k]\delta\left(\omega -
\frac{2\pi k}{N}\right)
\]</span> Note that <span
class="math inline">\(\tilde{X}(e^{j\omega})\)</span> has the necessary
periodicity with period <span class="math inline">\(2\pi\)</span> since
<span class="math inline">\(\tilde{X}[k]\)</span> is periodic with
period <span class="math inline">\(N\)</span>, and the impulses are
spaced at integer multiples of <span
class="math inline">\(2\pi/N\)</span>, where <span
class="math inline">\(N\)</span> is an integer.</p>
<p>The follow inverse Fourier transform shows <span
class="math inline">\(\tilde{X}(e^{j\omega})\)</span> is a Fourier
transform representation of the periodic sequence <span
class="math inline">\(\tilde{x}[n]\)</span></p>
<p><img src="/2023/05/15/fourier101/image-20230528100004194.png"
alt="image-20230528100004194" /></p>
<blockquote>
<p>Although the Fourier transform of a periodic sequence does not
converge in the normal sense, the <strong>introduction of
impulses</strong> (<span class="math inline">\(\delta\left(\omega -
\frac{2\pi k}{N}\right)\)</span>) permits us to include <em>periodic
sequences formally within the framework of Fourier transform
analysis</em></p>
</blockquote>
<h2 id="convolution">Convolution</h2>
<h3 id="discrete-time">discrete-time</h3>
<p><span class="math display">\[
y[n] = \sum_{k=-\infty}^{+\infty}x[k]h[n-k]
\]</span></p>
<p>The operation on the right-hand side is known as the
<strong>convolution</strong> of the sequences <em>x[n]</em> and
<em>h[n]</em>. The operation of convolution can be represented
symbolically as <span class="math display">\[
y[n] = x[n]*h[n]
\]</span></p>
<blockquote>
<p>The response of an LTI system to an arbitrary input is expressed in
terms of the system's response to the <em>unit impulse</em>.</p>
<p>From this, we see that an LTI system is completely characterized by
its response to a single signal, namely, its response to the <em>unit
impulse</em>.</p>
</blockquote>
<h3 id="continuous-time">continuous-time</h3>
<p><span class="math display">\[
y(t) = \int_{-\infty}^{+\infty}x(\tau)h(t-\tau)d\tau
\]</span></p>
<p><span class="math display">\[
y(t)=x(t)*h(t)
\]</span></p>
<p>As in discrete time, we see that a continuous-time LTI system is
completely characterized by its impulse response - i.e., by its response
to a single elementary signal, the unit impulse <span
class="math inline">\(\delta(t)\)</span></p>
<h2 id="eigenfunction">Eigenfunction</h2>
<p><em>A signal</em> for which the <em>system output</em> is <em>a
(possibly complex) constant</em> times the <em>input</em> is referred to
as an <strong>eigenfunction</strong> of the system, and the amplitude
factor is referred to as the system's <strong>eigenvalue</strong>.</p>
<p><strong>Complex exponentials</strong> are eigenfunctions of LTI
systems, that is,</p>
<p>continuous time: <span class="math display">\[
e^{st}\to H(s)e^{st}
\]</span> discrete time: <span class="math display">\[
z^n \to H(z)z^n
\]</span></p>
<h3 id="continuous-time-1">continuous-time</h3>
<p>Let's prove them. For an input <span
class="math inline">\(x(t)\)</span>, we can determine the output through
the use of the convolution integral, so that with <span
class="math inline">\(x(t)=e^{st}\)</span></p>
<p><span class="math display">\[\begin{align}
y(t) &amp;= \int_{-\infty}^{+\infty}h(\tau)x(t-\tau)d\tau \\
&amp;=\int_{-\infty}^{+\infty}h(\tau)e^{s(t-\tau)}d\tau \\
&amp;= e^{st}\int_{-\infty}^{+\infty}h(\tau)e^{-s\tau}d\tau
\end{align}\]</span></p>
<p>Assuming that the integral on the right-hand side converges, the
response to <span class="math inline">\(e^{st}\)</span> is of the form
<span class="math display">\[
y(t)=H(s)e^{st}
\]</span> where <span class="math inline">\(H(s)\)</span> is a complex
constant whose value depends on <span class="math inline">\(s\)</span>
and which is related to the system impulse response by <span
class="math display">\[
H(s)=\int_{-\infty}^{+\infty}h(\tau)e^{-s\tau}d\tau
\]</span></p>
<h3 id="discrete-time-1">discrete-time</h3>
<p>Suppose that an LTI system with impulse response <span
class="math inline">\(h[n]\)</span> has as its input the sequence <span
class="math display">\[
x[n] = z^n
\]</span> Then the output of the system can be determined from the
convolution sum as <span class="math display">\[\begin{align}
y[n]&amp;=\sum_{k=-\infty}^{+\infty}h[k]x[n-k] \\
&amp;=\sum_{k=-\infty}^{+\infty}h[k]z^{n-k} \\
&amp;= z^n\sum_{k=-\infty}^{+\infty}h[k]z^{-k}
\end{align}\]</span></p>
<p>Assuming that the summation on the right-hand side converges, the
output is the same compex exponential multiplied by a constant that
depends on the value of <span class="math inline">\(z\)</span>. That is,
<span class="math display">\[
y[n] = H(z)z^n
\]</span> where <span class="math display">\[
H(z) =\sum_{k=-\infty}^{+\infty}h[k]z^{-k}
\]</span></p>
<h3 id="linear-combination">linear combination</h3>
<blockquote>
<p>For both continuous time and discrete time, if the input to an LTI
system is represented as <em>a linear combination of complex
exponentials</em>, then the output can also be represented as <em>a
linear combination of the same complex exponential signals</em>.</p>
</blockquote>
<p>If the input to a continuous-time LTI system is represented as a
linear combination of complex exponentials, that is, if <span
class="math display">\[
x(t)=\sum_k a_ke^{s_k t}
\]</span> then the output will be <span class="math display">\[
y(t)=\sum_k a_kH(s_k)e^{s_k t}
\]</span> In an exactly analogous manner, if the input to a
discrete-time LTI system is represented as a linear combination of
complex exponentials, that is, if <span class="math display">\[
x[n]=\sum_k a_k z_k^n
\]</span> then the output will be <span class="math display">\[
y[n]=\sum_k a_kH(z_k)z_k^n
\]</span></p>
<h2 id="fourier-series">Fourier series</h2>
<h3 id="continuous-time-2">continuous-time</h3>
<p>The Fourier series of a periodic continuous-time signal: <span
class="math display">\[
x(t)=\sum_{k=-\infty}^{+\infty}a_ke^{jk\omega _0
t}=\sum_{k=-\infty}^{+\infty}a_ke^{jk(2\pi/T) t}
\]</span></p>
<p><span class="math display">\[
a_k = \frac{1}{T}\int_T x(t)e^{-jk\omega _0 t}dt=\frac{1}{T}\int _T
x(t)e^{-jk(2\pi/T)t}dt
\]</span></p>
<p>Here, we have written equivalent expressions for the Fourier series
in terms of the <strong>fundamental frequency</strong> <span
class="math inline">\(\omega _0\)</span> and the <strong>fundamental
period</strong> <span class="math inline">\(T\)</span></p>
<h4 id="conjugate-symmetry">Conjugate Symmetry</h4>
<p>If <span class="math inline">\(x(t)\)</span>
<strong>real</strong>-that is, when <span class="math inline">\(x(t) =
x^*(t)\)</span>, the Fourier series coefficients will be <em>conjugate
symmetric</em>, i.e <span class="math display">\[
a_{-k} = a_k^*
\]</span></p>
<h4 id="parsevals-relation">Parseval's Relation</h4>
<p>Parseval's relation states is that the <strong>total average
power</strong> in a periodic signal equals the <strong>sum of the
average powers in all of its harmonic components</strong> <span
class="math display">\[
\frac{1}{T}\int _T|x(t)|^2dt = \sum_{k=-\infty}^{+\infty}|a_k|^2
\]</span></p>
<h3 id="discrete-time-2">discrete-time</h3>
<h4 id="parsevals-relation-1">Parseval's Relation</h4>
<p><span class="math display">\[
\frac{1}{N}\sum_{n=&lt;N&gt;}|x[n]|^2=\sum_{k=&lt;N&gt;}|a_k|^2
\]</span></p>
<h3 id="system-functions">system functions</h3>
<p>When <span class="math inline">\(s\)</span> or <span
class="math inline">\(z\)</span> are general complex numbers, <span
class="math inline">\(H(s)\)</span> and <span
class="math inline">\(H(z)\)</span> are referred to as the
<strong>system functions</strong> of the corresponding systems.</p>
<p>For continuous-time signals and systems, we focus on the specific
case in which <span class="math inline">\(\Re \{s\}= 0\)</span>, so that
<span class="math inline">\(s = j\omega\)</span>, and consequently,
<span class="math inline">\(e^{st}\)</span> is of the form <span
class="math inline">\(e^{j\omega t}\)</span>. <span
class="math inline">\(H(j\omega)\)</span> viewed as a function of <span
class="math inline">\(\omega\)</span> - is referred to as the
<strong>frequency response</strong> of the system and is given by <span
class="math display">\[
H(j\omega) = \int_{-\infty}^{+\infty}h(t)e^{-j\omega t}dt
\]</span></p>
<p>Similarly, for discrete-time signals and systems, we focus on values
of <span class="math inline">\(z\)</span> for which <span
class="math inline">\(|z|=1\)</span>, so that <span
class="math inline">\(z=e^{j\omega}\)</span> and <span
class="math inline">\(z^n\)</span> is of the form <span
class="math inline">\(e^{j\omega n}\)</span>. Then, the frequency
response of the system is given by <span class="math display">\[
H(e^{j\omega}) = \sum_{n=-\infty}^{+\infty}h[n]e^{-j\omega n}
\]</span></p>
<blockquote>
<p>The response of an LTI system to a <em>complex exponential</em>
signal of the form <span class="math inline">\(e^{j\omega t}\)</span>
(in continuous time) or <span class="math inline">\(e^{j\omega
n}\)</span> (in discrete time) is particularly simple to express in
terms of the <em>frequency response of the system</em></p>
</blockquote>
<h2 id="continuous-time-fourier-transform">Continuous-Time Fourier
transform</h2>
<p><span class="math display">\[
X(j\omega) =\int_{-\infty}^{+\infty}x(t)e^{-j\omega t}dt
\]</span></p>
<p><span class="math display">\[
x(t) = \frac{1}{2\pi}\int_{-\infty}^{+\infty}X(j\omega)e^{j\omega
t}d\omega
\]</span></p>
<blockquote>
<p>Note system function is <span class="math display">\[
H(j\omega) = \int_{-\infty}^{+\infty}h(t)e^{-j\omega t}dt
\]</span></p>
</blockquote>
<h3 id="dirichlet-conditions">Dirichlet conditions</h3>
<p><img src="/2023/05/15/fourier101/image-20230516020142197.png"
alt="image-20230516020142197" /></p>
<h3 id="fourier-transform-representations-for-periodic-signals">Fourier
transform representations for periodic signals</h3>
<p><img src="/2023/05/15/fourier101/image-20230516021105696.png"
alt="image-20230516021105696" /></p>
<h3 id="differentiation-and-integration">Differentiation and
Integration</h3>
<p><span class="math display">\[
\frac{dx(t)}{dt}\longleftrightarrow j\omega X(j\omega)
\]</span></p>
<p><span class="math display">\[
\int_{-\infty}^t x(\tau)d\tau \longleftrightarrow
\frac{1}{j\omega}X(j\omega)+\pi X(0)\delta(\omega)
\]</span></p>
<h3 id="parsevals-relation-2">Parseval's Relation</h3>
<p><img src="/2023/05/15/fourier101/image-20230516021627107.png"
alt="image-20230516021627107" /></p>
<h3 id="convolution-property">Convolution Property</h3>
<p><img src="/2023/05/15/fourier101/image-20230516022054782.png"
alt="image-20230516022054782" /></p>
<h3 id="multiplication-property">Multiplication Property</h3>
<p><img src="/2023/05/15/fourier101/image-20231025231659449.png"
alt="image-20231025231659449" /></p>
<h2 id="discrete-time-fourier-transform">Discrete-Time Fourier
Transform</h2>
<p><span class="math display">\[
X(e^{j\omega})=\sum_{n=-\infty}^{+\infty}x[n]e^{-j\omega n}
\]</span></p>
<p><span class="math display">\[
x[n] = \frac{1}{2\pi}\int_{2\pi}X(e^{j\omega})e^{j\omega n}d\omega
\]</span></p>
<blockquote>
<p>Note system function is <span class="math display">\[
H(e^{j\omega}) = \sum_{n=-\infty}^{+\infty}h[n]e^{-j\omega n}
\]</span></p>
</blockquote>
<h3 id="parsevals-relation-3">Parseval's Relation</h3>
<p><img src="/2023/05/15/fourier101/image-20230516022936168.png"
alt="image-20230516022936168" /></p>
<h3 id="convolution-property-1">Convolution Property</h3>
<p><img src="/2023/05/15/fourier101/image-20230516023124056.png"
alt="image-20230516023124056" /></p>
<p>we see that the <em>frequency response</em> <span
class="math inline">\(H(e^{j\omega})\)</span> captures the change in
complex amplitude of the Fourier transform of the input at each
frequency <span class="math inline">\(\omega\)</span></p>
<h2 id="laplace-transform">Laplace transform</h2>
<p>The Laplace transform allowed us, for example, to perform transform
analysis of unstable systems and to develop additional insights and
tools for LTI system analysis</p>
<p><img src="/2023/05/15/fourier101/image-20230516023759163.png"
alt="image-20230516023759163" /></p>
<h2 id="discrete-fourier-transform">Discrete Fourier Transform</h2>
<p><img src="/2023/05/15/fourier101/image-20230516030532747.png"
alt="image-20230516030532747" /></p>
<p>where <span class="math inline">\(W_N=e^{-j(2\pi/N)}\)</span></p>
<h2 id="reference">reference</h2>
<p>The Dirac Comb and its Fourier Transform [<a
href="https://dspillustrations.com/pages/posts/misc/the-dirac-comb-and-its-fourier-transform.html">https://dspillustrations.com/pages/posts/misc/the-dirac-comb-and-its-fourier-transform.html</a>]</p>
<p>ECE 3793 Signals and Systems Spring 2017, Chapter 7 [<a
href="https://coecs.ou.edu/Joseph.P.Havlicek/ece3793/notes/ECE3793NotesCh07.pdf">https://coecs.ou.edu/Joseph.P.Havlicek/ece3793/notes/ECE3793NotesCh07.pdf</a>]</p>
<p>Oppenheim, A.V., Willsky, A.S., &amp; Nawab, S.H. (1996). Signals
&amp; systems (2nd ed.).</p>
<p>Alan V Oppenheim, Ronald W. Schafer. Discrete-Time Signal Processing,
3rd edition</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Functional Coverage Modeling</title>
    <url>/2022/04/03/functional-coverage/</url>
    <content><![CDATA[<h2 id="coverage-options">Coverage Options</h2>
<ul>
<li>Explicit (user defined)
<ul>
<li>Fully and clearly expressed within sources
<ul>
<li>Sequence and temporal coverage using assertions</li>
<li>Data-oriented coverage using <code>covergroup</code></li>
</ul></li>
<li>Planned and defined by the verification team</li>
</ul></li>
<li>Implicit
<ul>
<li>Derived or computed from source
<ul>
<li>Code coverage measured by the simulator</li>
</ul></li>
<li>May be defined outside the verification team</li>
<li>May be implied by the verification interface
<ul>
<li>e.g., an industry standard protocol</li>
</ul></li>
</ul></li>
</ul>
<h2 id="explicit-coverage-in-systemverilog">Explicit Coverage in
Systemverilog</h2>
<h3 id="assertions-for-control-oriented-coverage">Assertions for
control-oriented coverage</h3>
<ul>
<li>Defined as procedural statements</li>
<li><strong>CANNOT</strong> be defined in a class</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">property</span> req_gnt (cyc);</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    	<span class="built_in">$rose</span>(req) ##<span class="number">0</span> (req &amp;&amp; !gnt)[cyc] ##<span class="number">1</span> gnt;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cover</span> <span class="keyword">property</span> (req_gnt(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">cover</span> <span class="keyword">property</span> (req_gnt(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">cover</span> <span class="keyword">property</span> (req_gnt(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Control-oriented coverage uses SystemVerilog Assertion (SVA) syntax
and the cover directive. It is used to cover sequences of signal values
over time. Assertions cannot be declared or "covered" in a class
declaration, so their use in an UVM verification environment is
restricted to <strong>interface only</strong></p>
</blockquote>
<h3 id="covergroup-for-data-oriented-coverage">Covergroup for
data-oriented coverage</h3>
<ul>
<li>CAN be declared as a class member and created in class
constructor</li>
<li>Used in <strong>interface</strong> and module UVCs</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    len: <span class="keyword">coverpoint</span> pkt<span class="variable">.lenght</span> &#123;</span><br><span class="line">        <span class="keyword">illegal_bins</span> zero = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">bins</span> sml = &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    addrxlen : <span class="keyword">cross</span> pkt<span class="variable">.addr</span>, len;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">cg cg1 = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Data-oriented coverage uses the <code>covergroup</code> construct.
Covergroups can be declared and created in classes, therefore they are
essential for explicit coverage in a UVM verification environment.</p>
</blockquote>
<h4 id="interface-monitor-coverage">Interface Monitor Coverage</h4>
<p><code>covergroup new</code> constructor is called
<strong>directly</strong> off the declaration of the covergroup, it does
not have a separate instance name</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">collected_pkts_cq = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>
<p>The <code>covergroup</code> instance must be created in the class
constructor, not a UVM <code>build_phase</code> or other phase
method</p>
<p><img
src="/2022/04/03/functional-coverage/image-20220403210225837.png"
alt="image-20220403210225837" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_tx_monitor <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">covergroup</span> collected_pkts_cg;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">    </span><br><span class="line">    yapp_packet packet_collected;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">        collect_packet();</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> collect_packet();</span><br><span class="line">        <span class="comment">// read RTL signals via interface</span></span><br><span class="line">        <span class="comment">// reconstruct packet</span></span><br><span class="line">        collected_pkts_cg<span class="variable">.sample</span>();</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h4 id="module-uvc-coverage">Module UVC Coverage</h4>
<p>Typical module UVC coverage:</p>
<ul>
<li>Routing - packets flow from input ports to all legal outputs</li>
<li>latency - all packets received within speicied delay</li>
</ul>
<blockquote>
<p>The module UVC monitor receives data from the interface monitors via
analysis ports, so the implementation of the analysis write function is
a convenient place to put coverage code</p>
</blockquote>
<p><img
src="/2022/04/03/functional-coverage/image-20220403212529981.png"
alt="image-20220403212529981" /></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Demystifying Gate Resistance</title>
    <url>/2023/07/09/gate-resistance/</url>
    <content><![CDATA[<p><img src="/2023/07/09/gate-resistance/image-20230709102848934.png"
alt="image-20230709102848934" /></p>
<h2 id="transit-frequency-f_t">Transit frequency <span
class="math inline">\(f_T\)</span></h2>
<blockquote>
<p>aka <strong>cut-off frequency</strong></p>
</blockquote>
<h2 id="gate-thermal-noise">Gate (thermal) noise</h2>
<p><img src="/2023/07/09/gate-resistance/image-20230709210517475.png"
alt="image-20230709210517475" /></p>
<p><img src="/2023/07/09/gate-resistance/image-20230709211309265.png"
alt="image-20230709211309265" /></p>
<p><img src="/2023/07/09/gate-resistance/image-20230709202930102.png"
alt="image-20230709202930102" /></p>
<h3 id="two-side-poly-contact-folding">Two-Side Poly Contact &amp;
folding</h3>
<p><img src="/2023/07/09/gate-resistance/image-20230709212015293.png"
alt="image-20230709212015293" /></p>
<p>Both scheme yield a total distributed resistance of <span
class="math inline">\(R_G/4\)</span> for gate noise calculation</p>
<h4 id="folding">folding</h4>
<p>finger 0 <span class="math display">\[\begin{align}
\overline{i_{tot,0}^2} &amp;= \left(\frac{g_m}{2}
\right)^2(4kT\frac{R_G/2}{3}) \\
&amp;= g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{2^2\cdot 2}
\end{align}\]</span></p>
<p>similarly finger 1 <span class="math display">\[
\overline{i_{tot,1}^2} =
g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{2^2\cdot 2}
\]</span> Assuming uncorrelated <span class="math display">\[
\overline{i_{tot}^2} = \sum_{N=0}^1\overline{i_{tot,N}^2}
=g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{2^2\cdot 2} \cdot 2 =
g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{2^2}
\]</span> Generally <span class="math display">\[
\overline{i_{tot}^2} = g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{N^2}
\]</span> where the gate is decomposed into <span
class="math inline">\(N\)</span> parallel fingers</p>
<h4 id="two-side-poly-contact">two-side poly contact</h4>
<p><img src="/2023/07/09/gate-resistance/1678671319799.png"
alt="No alt text provided for this image" /></p>
<p><strong>We fracture Gate poly at the center point, then we obtain 2
segments, both have same <span
class="math inline">\(\frac{g_m}{2}\)</span> and <span
class="math inline">\(R_G/2\)</span>.</strong></p>
<p>The derivation procedure is same with folding structure, i.e. plug
<span class="math inline">\(N=2\)</span> into <span
class="math inline">\(\overline{i_{tot}^2} =
g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{N^2}\)</span></p>
<p>That is <span class="math display">\[
\overline{i_{tot}^2} = g_m^2\left(4kT\frac{R_G}{12}\right)
\]</span> The input referred noise of gate resistance <span
class="math display">\[
\overline{V_{nRG}^2} = 4kT\frac{R_G}{12}
\]</span></p>
<h3 id="four-equal-gate-fingers">four equal gate fingers</h3>
<p><img src="/2023/07/09/gate-resistance/image-20230709212818351.png"
alt="image-20230709212818351" /></p>
<p><span class="math display">\[
\overline{i_{tot}^2} = g_m^2\left(4kT\frac{R_G}{3}\right)\frac{1}{4^2}
\]</span> Then <span class="math display">\[
\overline{V_{nRG}^2} = \frac{\overline{i_{tot}^2}}{g_m^2}
=4kT\frac{R_G}{48}
\]</span></p>
<h2 id="gate-resistance-handling-by-parasitic-extraction-tools">Gate
resistance handling by parasitic extraction tools</h2>
<p>They fracture the poly line at the intersection with the active
(diffusion) layer, breaking it into <strong>"gate poly"(poly over
active)</strong> and <strong>"field poly" (poly outside
active)</strong></p>
<blockquote>
<p>gploy, fpoly</p>
</blockquote>
<p><img src="/2023/07/09/gate-resistance/1678670859052.png"
alt="No alt text provided for this image" /></p>
<p>Gate poly is also fractured at the center point. Gate instance pin of
the MOSFET (SPICE model) is connected to the center point of the gate
poly. <strong>Gate poly is described by two parasitic resistors,
connecting the fracture points</strong>.</p>
<p><img src="/2023/07/09/gate-resistance/image-20230709222642979.png"
alt="image-20230709222642979" /></p>
<p>MOSFET extrinsic parasitic capacitance between gate poly and source /
drain diffusion and contacts is calculated by parasitic extraction
tools, and assigned to the nodes of the resistive networks.</p>
<p>Different extraction tools do this differently - some tools connect
these parasitic capacitances to the center point of the gate poly, while
some other tools connect them to the end points of the gate poly
resistors.</p>
<h2 id="delta-gate-model"><span class="math inline">\(\Delta\)</span>
gate model</h2>
<blockquote>
<p>This distributed network has a different AC and transient response
than a simple lumped one-R and one-C circuit.</p>
<p>It was shown [B. Razavi] that such RC network behaves approximately
the same as a network with one R and one C element, where <em>C is the
total capacitance</em>, and R=1/3 * W/L <em>rsh for single-side
connected poly, and R=1/12 </em> W/L * rsh for double-sided connected
poly.</p>
<p>These coefficients - 1/3 and 1/12 - effectively enable an accurate
reduced order model for the gate, reducing a large number of R and C
elements to two (or three) resistors and one capacitor.</p>
</blockquote>
<p><strong>Gate Delta Model</strong>: where a gate is described by two
positive and one negative resistors</p>
<p><img src="/2023/07/09/gate-resistance/image-20230709214200878.png"
alt="image-20230709214200878" /></p>
<blockquote>
<p>only applicable to contacts on gate overhangs</p>
<p>invalid for self-aligned gate contacts, where gate contact land
directly on top of gate, not gate overhang</p>
</blockquote>
<p><img src="/2023/07/09/gate-resistance/1678672522997.png"
alt="No alt text provided for this image" /></p>
<ol type="1">
<li><p>1-side gate contact <span class="math display">\[
R_{eq,1side} =R_1 \parallel (R_2+R_1)= \frac{R_G}{6}\parallel
(-\frac{R_G}{2}+\frac{R_G}{6})=\frac{R_G}{3}
\]</span></p></li>
<li><p>2-side contact <span class="math display">\[
R_{eq,2side}= R_1 \parallel R_1 = \frac{R_G}{6}\parallel \frac{R_G}{6} =
\frac{R_G}{12}
\]</span></p></li>
</ol>
<blockquote>
<p>Some SPICE simulators have problems handling <em>negative
resistors</em>, that's possibly why this model did not get a wide
adoption. Some foundries and PDKs support delta gate model, while some
others don't.</p>
</blockquote>
<h2 id="vertical-component-of-gate-resistance">Vertical component of
gate resistance</h2>
<p>In "old" technologies (pre-16nm), gate resistance was dominated by
lateral resistance. However, in advanced technologies, multiple
interfaces between gate material layers lead to a large vertical gate
resistance.</p>
<p><img src="/2023/07/09/gate-resistance/1678686425859.png"
alt="No alt text provided for this image" /></p>
<blockquote>
<p>It's very easy to check this in DSPF file - if gate instance pin is
connected directly to the center of the gate poly - vertical resistance
is not accounted for. If it is connected by a positive resistor to the
center of the gate poly - that resistors represents the vertical gate
resistance.</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>⭐ B. Razavi, Y. Ran, and K. F. Lee, “Impact of Distributed Gate
Resistance on the Performance of MOS Devices,” IEEE Trans. Circuits and
Systems, Part I, pp. 750–754, Nov. 1994.</p>
<p>⭐ Maxim Ershov, Diakopto. "Gate Resistance in IC design flow", [<a
href="https://www.linkedin.com/pulse/gate-resistance-ic-design-flow-maxim-ershov">link</a>,
<a
href="https://diakopto.com/wp-content/uploads/Gate-Resistance-in-IC-design-flow.pdf">pdf</a>]</p>
<p>Saha, Samar K.. “FinFET Devices for VLSI Circuits and Systems.”
(2020).</p>
<p>Harpe, Pieter J. A., Andrea Baschirotto and Kofi A. A. Makinwa.
“Hybrid ADCs, Smart sensors for the IoT, and Sub-1V and Advanced node
analog circuit design: Advances in Analog Circuit Design 2017.”
(2018).</p>
<p>Chauhan, Yogesh Singh. FinFET Modeling for IC Simulation and Design:
Using the BSIM-CMG Standard. London, UK: Academic Press, 2015.</p>
<p>A.J.Sholten et al., "FinFET compact modelling for analogue and RF
applications", IEDM'2010, p.190.</p>
<p>W. Wu and M. Chan, “Gate resistance modeling of multifin MOS
devices,” IEEE Electron Device Letters, vol. 27, no. 1, pp. 68-70, Jan.
2006.</p>
<p>A. L. S. Loke, C. K. Lee and B. M. Leary, "Nanoscale CMOS
Implications on Analog/Mixed-Signal Design," 2019 IEEE Custom Integrated
Circuits Conference (CICC), Austin, TX, USA, 2019, pp. 1-57, doi:
10.1109/CICC.2019.8780267.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub Pages Build and deployment</title>
    <url>/2023/07/01/github-pages-deploy/</url>
    <content><![CDATA[<p>The repository visibility shall be <code>public</code></p>
<p><img
src="/2023/07/01/github-pages-deploy/image-20230701142405404.png"
alt="image-20230701142405404" /></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Glitches and Hazards</title>
    <url>/2022/05/08/glitch-hazard/</url>
    <content><![CDATA[<ul>
<li>A <strong>glitch</strong> is an unwanted pulse at the output of a
combinational logic network – <strong>a momentary change</strong> in an
output that should not have changed</li>
<li>A circuit with <em>the potential for a glitch</em> is said to have a
<strong>hazard</strong></li>
<li>In other words a hazard is something intrinsic about a circuit; a
circuit with hazard may or may not have a glitch depending on input
patterns and the electric characteristics of the circuit.</li>
</ul>
<h4 id="when-do-circuits-have-hazards">When do circuits have hazards
?</h4>
<p>Hazards are potential unwanted transients that occur in the output
when different paths from input to output have different propagation
delays</p>
<h4 id="types-of-hazards-on-an-output">Types of Hazards (on an
output)</h4>
<p>static 1-hazard, static 0-hazard, dynamic hazard</p>
<p><img src="/2022/05/08/glitch-hazard/image-20220508183800744.png"
alt="image-20220508183800744" /></p>
<h4 id="hazards-concern">Hazard's Concern</h4>
<ul>
<li>Hazards do not hurt synchronous circuits</li>
<li>Hazards Kill Asynchronous Circuits</li>
<li>Glitches Increase Power Consumption</li>
</ul>
<h4 id="referece">referece</h4>
<p>CPE166/EEE 270 Advanced Logic Design-Digital Design: Time Behavior of
Combinational Networks: <a
href="https://www.csus.edu/indiv/p/pangj/166/f/sram/Handout_Hazard.pdf">https://www.csus.edu/indiv/p/pangj/166/f/sram/Handout_Hazard.pdf</a></p>
<p>John Knight, ELEC3500 Glitches and Hazards in Digital Circuits <a
href="http://www.doe.carleton.ca/~shams/ELEC3500/hazards.pdf">http://www.doe.carleton.ca/~shams/ELEC3500/hazards.pdf</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>h0 Estimator</title>
    <url>/2022/05/29/h0-estimator/</url>
    <content><![CDATA[<p>summer output <span class="math display">\[
r_k =
a_kh_0+\left(\sum_{n=-\infty,n\neq0}^{+\infty}a_{k-n}h_n-\sum_{n=1}^{\text{ntap}}\hat{a}_{k-n}\hat{h}_n\right)
\]</span> error slicer analog output <span class="math display">\[
e_k=r_k-\hat{a}_k \hat{h}_0
\]</span> error slicer digital output <span class="math display">\[
\hat{e}_k=|e_k|
\]</span> It's NOT possible to implement <span
class="math inline">\(e_k\)</span>, which need to determine <span
class="math inline">\(\hat{a}_k=|r_k|\)</span> in no time. One method to
approach this problem is calculate <span
class="math inline">\(e_k^{a_k=1}=r_k-\hat{a}_k \hat{h}_0\)</span> and
<span class="math inline">\(e_k^{a_k=-1}=r_k+\hat{a}_k
\hat{h}_0\)</span>, then select the right one based on <span
class="math inline">\(\hat{a}_k\)</span>.</p>
<p>The update equation based on Sign-Sign-Least Mean square (SS-LMS) and
loss function <span
class="math inline">\(L(\hat{h}_{\text{0~ntap}})=E(e_k^2)\)</span> <span
class="math display">\[
\hat{h}_n(k+1) = \hat{h}_n(k)+\mu \cdot |e_k|\cdot \hat{a}_{k-n}
\]</span> Where <span class="math inline">\(n \in
[0,...,\text{ntap}]\)</span>. This way, we can obtain <span
class="math inline">\(\hat{h}_0\)</span>, <span
class="math inline">\(\hat{h}_1\)</span>, <span
class="math inline">\(\hat{h}_2\)</span>, ...</p>
<blockquote>
<p><span class="math inline">\(\hat{h}_0\)</span> is used in AFE
adaptation</p>
</blockquote>
<p>We may encounter difficulty if the first tap of DFE is unrolled, its
<span class="math inline">\(e_k\)</span> is modified as follow <span
class="math display">\[
r_k =
a_kh_0+\left(\sum_{n=-\infty,n\neq0}^{+\infty}a_{k-n}h_n-\sum_{n=2}^{\text{ntap}}\hat{a}_{k-n}\hat{h}_n\right)
\]</span> Where there is NO <span
class="math inline">\(\hat{h}_1\)</span></p>
<p>To find <span class="math inline">\(\hat{h}_1\)</span>, we shall use
different pattern for even and odd error slicer</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>time format in Verilog</title>
    <url>/2023/06/05/hdltime/</url>
    <content><![CDATA[<h2 id="realtime-vs-time">realtime vs time</h2>
<ul>
<li><p><code>$realtime</code> round the current time to
<code>timeprecision</code></p></li>
<li><p><code>$time</code> round the current time to integer</p></li>
<li><p><code>%t</code> will scale the rounded value to represent
<code>timeprecision</code>,</p>
<p>i.e. <span class="math inline">\([\$\text{realtime},
\$\text{time}]\cdot \$\text{timeunit} /
\$\text{timeprecision}\)</span></p></li>
</ul>
<p><a
href="https://verificationacademy.com/forums/systemverilog/time-vs-realtime#answer-94062">https://verificationacademy.com/forums/systemverilog/time-vs-realtime#answer-94062</a>
<a
href="https://verificationacademy.com/forums/systemverilog/time-vs-realtime#answer-94096">https://verificationacademy.com/forums/systemverilog/time-vs-realtime#answer-94096</a></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">timeunit</span> <span class="number">10</span>ns;</span><br><span class="line">  <span class="keyword">timeprecision</span> <span class="number">1</span>ps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;$realtime = %g&quot;</span>, <span class="built_in">$realtime</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;$time = %g&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="comment">// $realtime round to timeprecision</span></span><br><span class="line">    <span class="comment">// $time round to integer</span></span><br><span class="line">    #<span class="number">1</span><span class="variable">.10016</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;$realtime = %g&quot;</span>, <span class="built_in">$realtime</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;$time = %g&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// %t format will scale the rounded value to represent timeprecision</span></span><br><span class="line">    <span class="comment">// 1.1002*10e-9/1e-12 = 11002</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;$realtime %%t = %t&quot;</span>, <span class="built_in">$realtime</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;$time %%t = %t&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>output <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$realtime = 0</span><br><span class="line">$time = 0</span><br><span class="line">$realtime = 1.1002</span><br><span class="line">$time = 1</span><br><span class="line">$realtime %t =                11002</span><br><span class="line">$time %t =                10000</span><br></pre></td></tr></table></figure></p>
<h2 id="timeunit-timeprecision">timeunit, timeprecision</h2>
<p>The time unit and time precision can be specified in the following
two ways: - Using the compiler directive <code>`timescale</code> - Using
the keywords <code>timeunit</code> and <code>timeprecision</code>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> D (...);</span><br><span class="line">  <span class="keyword">timeunit</span> <span class="number">100</span>ps;</span><br><span class="line">  <span class="keyword">timeprecision</span> <span class="number">10</span>fs;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> E (...);</span><br><span class="line">  <span class="keyword">timeunit</span> <span class="number">100</span>ps / <span class="number">10</span>fs; <span class="comment">// timeunit with optional second argument</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>The minimum of <code>timeprecision</code> determine <code>%t</code>
output, the nearest <code>timeunit</code> and <code>timeprecision</code>
determine the round of <code>$realtime</code> and <code>$time</code>. Of
course, the simulator follow the time tick shown by
<code>$realtime</code>.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Due to minimum of timeprecision is 10ps</span></span><br><span class="line"><span class="keyword">module</span> rawplant;</span><br><span class="line">  <span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line">  <span class="keyword">timeprecision</span> <span class="number">100</span>ps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">task</span> print;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1ns: 1</span></span><br><span class="line"><span class="comment">    100ps:  6</span></span><br><span class="line"><span class="comment">    10ps: 6</span></span><br><span class="line"><span class="comment">    1ps: 6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    #<span class="number">1</span><span class="variable">.666</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;raw: $realtime = %g&quot;</span>, <span class="built_in">$realtime</span>);     <span class="comment">// 1.7</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;raw: $time = %g&quot;</span>, <span class="built_in">$time</span>);             <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;raw: $realtime %%t = %t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">// 1.7*1ns/10ps=170</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;raw: $time %%t = %t&quot;</span>, <span class="built_in">$time</span>);         <span class="comment">// 2*1ns/10ps = 200</span></span><br><span class="line">  <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fineplant;</span><br><span class="line">  <span class="keyword">timeunit</span> <span class="number">100</span>ps;</span><br><span class="line">  <span class="keyword">timeprecision</span> <span class="number">10</span>ps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">task</span> print;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    100ps: 2</span></span><br><span class="line"><span class="comment">    10ps: 6</span></span><br><span class="line"><span class="comment">    1ps: 6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    #<span class="number">2</span><span class="variable">.66</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fine: $realtime = %g&quot;</span>, <span class="built_in">$realtime</span>);     <span class="comment">// 2.7</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fine: $time = %g&quot;</span>, <span class="built_in">$time</span>);             <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fine: $realtime %%t = %t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">// 2.7*100ps/10ps = 27</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fine: $time %%t = %t&quot;</span>, <span class="built_in">$time</span>);         <span class="comment">// 3*100ps/10ps = 30</span></span><br><span class="line">  <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  rawplant rawblock();</span><br><span class="line">  fineplant fineblock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">    rawblock<span class="variable">.print</span>();</span><br><span class="line">    fineblock<span class="variable">.print</span>();</span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>output <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fine: $realtime = 2.7</span><br><span class="line">fine: $time = 3</span><br><span class="line">fine: $realtime %t =                   27</span><br><span class="line">fine: $time %t =                   30</span><br><span class="line">raw: $realtime = 1.7</span><br><span class="line">raw: $time = 2</span><br><span class="line">raw: $realtime %t =                  170</span><br><span class="line">raw: $time %t =                  200</span><br></pre></td></tr></table></figure></p>
<h2 id="questasim-cmd">questasim cmd</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vlib work</span><br><span class="line">vlog tb.v</span><br><span class="line">vsim -c -<span class="keyword">do</span> <span class="string">&quot;run -all;exit&quot;</span> work.tb</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Hierarchical Connections and Exports UVM</title>
    <url>/2022/04/02/hier-conn-export-uvm/</url>
    <content><![CDATA[<p><code>imp</code> and <code>port</code> connectors are sufficient for
modeling most connections, but there is third connector,
<code>export</code>, which is used exclusively in hierarchical
connections.</p>
<p>Normally hierarchical routing is not required. A <code>port</code> on
an UVC monitor can be connected directly to an <code>imp</code> in a
scoreboard by specifying full hierarchical pathname (e.g.,
env.agent.monitor.analysis_port). The structure of an UVC is fixed and
so the user knows to look in the monitor component for the analysis
ports.</p>
<p>However the internal hierarchy of a module UVC is more arbitrary, and
it may be convenient to route all the module UVC connectors to the top
level to allow use without knowledge of the internal structure.</p>
<p>On the initiator side</p>
<ul>
<li>ports are routed up the hierarchy via other port instances</li>
</ul>
<p>On the target side</p>
<ul>
<li>only the component which defines the communication method is allowed
to have an <code>imp</code> instance. So we need a third object to route
connections up the target side hierarchy - <code>export</code></li>
</ul>
<p>The hierarchical route must be connected at each level in the
direction of control flow:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">initiator<span class="variable">.connect</span>(target)</span><br></pre></td></tr></table></figure>
<p>Connection rules are as follows:</p>
<ul>
<li><code>port</code> initiators can be connected to <code>port</code>,
<code>export</code> or <code>imp</code> targets</li>
<li><code>export</code> initiators can be connected to
<code>export</code> or <code>imp</code> targets</li>
<li><code>imp</code> cannot be connection initiator. <code>imp</code> is
target only and is always the last connection object on a route</li>
</ul>
<p><strong>uvm_analysis_port</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_analysis_port # (</span><br><span class="line">   	<span class="keyword">type</span> 	T	 = 	<span class="keyword">int</span></span><br><span class="line">) <span class="keyword">extends</span> uvm_port_base # (uvm_tlm_if_base <span class="variable">#(T,T))</span></span><br></pre></td></tr></table></figure>
<p><strong>uvm_analysis_port</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_analysis_port # (</span><br><span class="line">   	<span class="keyword">type</span> 	T	 = 	<span class="keyword">int</span></span><br><span class="line">) <span class="keyword">extends</span> uvm_port_base # (uvm_tlm_if_base <span class="variable">#(T,T))</span></span><br></pre></td></tr></table></figure>
<p><strong>uvm_analysis_imp</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_analysis_imp #(</span><br><span class="line">   	<span class="keyword">type</span> 	T	 = 	<span class="keyword">int</span>,</span><br><span class="line">   	<span class="keyword">type</span> 	IMP	 = 	<span class="keyword">int</span></span><br><span class="line">) <span class="keyword">extends</span> uvm_port_base <span class="variable">#(uvm_tlm_if_base #(T,T))</span></span><br></pre></td></tr></table></figure>
<p><strong>QA</strong></p>
<ol type="1">
<li><p>What are the three distinct functions of a scoreboard?</p>
<p>Reference model, expected data storage and comparison</p></li>
<li><p>To how many consumer components can an analysis port be
connected?</p>
<p>Any number, including zero</p></li>
<li><p>What are the names of the two declarations made available by the
following macro:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">`uvm_analysis_imp_decl(_possible)</span><br></pre></td></tr></table></figure>
<p>Subclass <code>uvm_analysis_imp_possible</code></p>
<p>Method <code>write_possible</code></p></li>
<li><p>Why should a scoreboard clone the data received by a
<code>write</code> method?</p>
<p>The <code>write</code> method only sends a reference, therefore if
the sending component uses the same reference for every data item,
overwriting of data in the storage function of the scoreboard is
possible without cloning.</p></li>
</ol>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>In-design Sign-off Metal Fill Flow in Innovus</title>
    <url>/2022/03/05/in-design-signoff-metalfill-innovus/</url>
    <content><![CDATA[<p>Before inserting sign-off metal fill, stream out a GDSII stream file
of the current database. Specify the mapping file and units that match
with the rule deck you specify while inserting metal fill. If necessary,
include the detailed-cell (<code>-merge</code> option) Graphic Database
System (GDS).</p>
<p><strong>PVS:</strong></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">streamOut -merge <span class="variable">$GDSFile</span> -mode ALL -units <span class="variable">$GDSUNITS</span> -mapFile <span class="variable">$GDSMAP</span> -outputMacros pvs.fill.gds</span><br><span class="line">run_pvs_metal_fill -ruleFile <span class="variable">$DUMMYRULE</span> -defMapFile <span class="variable">$DEFMAP</span> -gdsFile pvs.fill.gds -cell [dbgDesignName]</span><br></pre></td></tr></table></figure>
<p><strong>Pegasus:</strong> <figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">streamOut -merge <span class="variable">$GDSFile</span> -mode ALL -units <span class="variable">$GDSUNITS</span> -mapFile <span class="variable">$GDSMAP</span> -outputMacros pegasus.fill.gds</span><br><span class="line">run_pegasus_metal_fill -ruleFile <span class="variable">$DUMMYRULE</span> -defMapFile <span class="variable">$DEFMAP</span> -gdsFile pegasus.fill.gds -cell [dbgDesignName]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Just replace <code>run_pvs_metal_fill</code> with
<code>run_pegasus_metal_fill</code></p>
</blockquote>
<p><strong>Note</strong>: Innovus metal fill (e.g.
<code>addMetalFill</code>, <code>addViaFill</code>, etc.) does not
support 20nm and below node design rules. We strongly recommend the
Pegasus/PVS metal fill solution for 20nm and below. If you have sign-off
metal fill rule deck for 28nm and above available, we recommend you to
move to Pegasus/PVS solution too.</p>
<blockquote>
<ol type="1">
<li><p><code>trimMetalFillNearNet</code> does not check DRC rules. It
only removes the metal fill with specified spacing</p></li>
<li><p><strong>Do not</strong> perform ECO operations after dump in
sign-off metal fill (by <code>run_pvs_metal_fill</code> or
<code>run_pegasus_metal_fill</code>), especially, at 20nm and below
nodes.</p></li>
<li><p>If you perform an ECO action, the tool cannot get DRC clean
because <code>trimMetalFill</code> does not support 20nm and below node
design rules.</p></li>
<li><p>The sign-off metal fill typically does not cause DRC issues with
regular wires.</p></li>
</ol>
</blockquote>
<p>The <code>run_pvs_metal_fill</code> command does the following:</p>
<ul>
<li>Runs PVS with the fill rules to create a GDSII output file.</li>
<li>Converts the GDSII to a DEF format file based on the GDSII to DEF
layermap provided.</li>
<li><strong>Loads the resulting DEF file into Innovus</strong>.</li>
</ul>
<p>Pegasus is similar to PVS, shown as below,</p>
<p>The <code>run_pegasus_metal_fill</code> command does the
following:</p>
<ul>
<li>Runs Pegasus with the fill rules to create a GDSII output file.</li>
<li>Converts the GDSII to a DEF format file based on the GDSII to DEF
layermap provided.</li>
<li>Loads the resulting DEF file into Innovus.</li>
</ul>
<p><strong>Reference:</strong></p>
<p>Innovus User Guide, Product Version 21.12, Last Updated in November
2021</p>
]]></content>
      <categories>
        <category>innovus</category>
      </categories>
  </entry>
  <entry>
    <title>Inertial &amp; transport delays</title>
    <url>/2022/03/16/inertial-and-transport-delay/</url>
    <content><![CDATA[<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20230414232256309.png"
alt="image-20230414232256309" /></p>
<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20230414232439556.png"
alt="image-20230414232439556" /></p>
<h2 id="inertial-delay">Inertial delay</h2>
<p>Inertial delay models are simulation delay models that filter pulses
that are shorted than the propagation delay of <strong>Verilog gate
primitives</strong> or <strong>continuous assignments</strong>
(<code>assign #5 y = ~a;</code>)</p>
<p>​ <strong>COMBINATIONAL LOGIC ONLY !!!</strong></p>
<blockquote>
<ul>
<li>Inertial delays swallow glitches</li>
<li><strong>sequential logic</strong> implemented with <strong>procedure
assignments</strong> DON'T follow the rule</li>
</ul>
</blockquote>
<h3 id="continuous-assignments">continuous assignments</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> in;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="keyword">wire</span> out;</span><br><span class="line">	<span class="keyword">assign</span> #<span class="number">2</span><span class="variable">.5</span> out = in;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">16</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">10</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">4</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		#<span class="number">50</span>;</span><br><span class="line">		<span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20220317000509716.png"
alt="image-20220317000509716" /></p>
<h3 id="procedure-assignment---combinational-logic">procedure assignment
- combinational logic</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> in;</span><br><span class="line">	<span class="keyword">reg</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////// combination logic ////////////////////////</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		#<span class="number">2</span><span class="variable">.5</span> out = in;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/* the above code is same with following code</span></span><br><span class="line"><span class="comment">    	always @(*) begin</span></span><br><span class="line"><span class="comment">			#2.5;</span></span><br><span class="line"><span class="comment">			out = in;</span></span><br><span class="line"><span class="comment">		end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">16</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">10</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">4</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		#<span class="number">50</span>;</span><br><span class="line">		<span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20220316235257361.png"
alt="image-20220316235257361" /></p>
<h3 id="procedure-assignment---sequential-logic">procedure assignment -
sequential logic</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> in;</span><br><span class="line">	<span class="keyword">reg</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">		clk = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			clk = ~clk;</span><br><span class="line">			#<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">//////////// sequential logic //////////////////</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">		#<span class="number">2</span><span class="variable">.5</span> out &lt;= in;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">16</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">10</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		#<span class="number">50</span>;</span><br><span class="line">		<span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20220316235620168.png"
alt="image-20220316235620168" /></p>
<blockquote>
<p>As shown above, sequential logic DON'T follow inertial delay</p>
</blockquote>
<h2 id="transport-delay">Transport delay</h2>
<p>Transport delay models are simulation delay models that pass all
pulses, including pulses that are shorter than the propagation delay of
corresponding <strong>Verilog procedural assignments</strong></p>
<blockquote>
<ul>
<li>Transport delays pass glitches, delayed in time</li>
<li>Verilog can model RTL transport delays by adding <strong>explicit
delays to the right-hand-side (RHS) of a nonblocking
assignment</strong></li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">    y &lt;= #<span class="number">5</span> ~a;</span><br></pre></td></tr></table></figure>
<h3 id="nonblocking-assignment">nonblocking assignment</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> in;</span><br><span class="line">	<span class="keyword">reg</span> out;</span><br><span class="line"><span class="comment">/////////////// nonblocking assignment ///</span></span><br><span class="line">	<span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">		out &lt;= #<span class="number">2</span><span class="variable">.5</span> in;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">16</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">10</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">4</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		#<span class="number">50</span>;</span><br><span class="line">		<span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20220317003146825.png"
alt="image-20220317003146825" /></p>
<h3 id="blocking-assignment">blocking assignment</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> in;</span><br><span class="line">	<span class="keyword">reg</span> out;</span><br><span class="line"><span class="comment">/////////////// blocking assignment ///</span></span><br><span class="line">	<span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">		out = #<span class="number">2</span><span class="variable">.5</span> in;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">16</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">2</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">10</span>;</span><br><span class="line">		in = <span class="number">1</span>;</span><br><span class="line">		#<span class="number">4</span>;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		#<span class="number">50</span>;</span><br><span class="line">		<span class="built_in">$finish</span>();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/16/inertial-and-transport-delay/image-20220317003819457.png"
alt="image-20220317003819457" /></p>
<blockquote>
<p>It seems that new event is <strong>discarded</strong> before previous
event is realized.</p>
</blockquote>
<h2 id="reference">reference</h2>
<p><a
href="http://www.sunburst-design.com/papers/CummingsSNUG2002Boston_NBAwithDelays.pdf">Verilog
Nonblocking Assignments With Delays, Myths &amp; Mysteries</a></p>
<p><a
href="http://www.sunburst-design.com/papers/CummingsHDLCON1999_BehavioralDelays_Rev1_1.pdf">Correct
Methods For Adding Delays To Verilog Behavioral Models</a></p>
<p>Article (20488135) Title: Selecting Different Delay Modes in GLS
(RAK) URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009bdLyEAI">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009bdLyEAI</a></p>
<p>Article (20447759) Title: Gate Level Simulation (GLS): A Quick Guide
for Beginners URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000005xEorEAE">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000005xEorEAE</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>interconnect, transmission line and inductance</title>
    <url>/2023/07/26/inductance/</url>
    <content><![CDATA[<h2 id="loop-inductance">loop inductance</h2>
<p>Determine the <em>complete current loop path</em> in order to
calculate loop inductance of that current loop</p>
<blockquote>
<p>The complete path for the current depends on the frequency of the
current. For one frequency, the return current will take a particular
path, but for a higher frequency the path of the return current may be
entirely different!</p>
</blockquote>
<h2 id="partial-inductance">partial inductance</h2>
<blockquote>
<p>The first problem with using <em>loop inductance</em> to model the
conductors of a loop is that at different frequencies, the return
path</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Yuriy Shlepnev. How Interconnects Work: Characteristic Impedance and
Reflections [<a
href="https://www.linkedin.com/pulse/how-interconnects-work-characteristic-impedance-yuriy-shlepnev/">https://www.linkedin.com/pulse/how-interconnects-work-characteristic-impedance-yuriy-shlepnev/</a>]</p>
<p>-. How Interconnects Work: Bandwidth for Modeling and Measurements
[<a
href="https://www.linkedin.com/pulse/how-interconnects-work-bandwidth-modeling-yuriy-shlepnev/?trackingId=874kpm3XuNyV9D0eP6IioA%3D%3D">https://www.linkedin.com/pulse/how-interconnects-work-bandwidth-modeling-yuriy-shlepnev/?trackingId=874kpm3XuNyV9D0eP6IioA%3D%3D</a>]</p>
<p>Eric Bogatin. Pop Quiz: When is an Interconnect Not a Transmission
Line? [<a
href="https://www.signalintegrityjournal.com/blogs/4-eric-bogatin-signal-integrity-journal-technical-editor/post/265-pop-quiz-when-is-an-interconnect-not-a-transmission-line">https://www.signalintegrityjournal.com/blogs/4-eric-bogatin-signal-integrity-journal-technical-editor/post/265-pop-quiz-when-is-an-interconnect-not-a-transmission-line</a>]</p>
<p>TeledyneLeCroy/SignalIntegrity Python tools for signal integrity
applications [<a
href="https://github.com/TeledyneLeCroy/SignalIntegrity">SignalIntegrityApp</a>]</p>
<p>Paul, Clayton R. <em>Inductance: Loop and Partial</em>. Hoboken, N.J.
: [Piscataway, N.J.]: Wiley ; IEEE, 2010.</p>
<p>A Look at Transmission-Line Losses [<a
href="http://blog.teledynelecroy.com/2018/06/a-look-at-transmission-line-losses.html">http://blog.teledynelecroy.com/2018/06/a-look-at-transmission-line-losses.html</a>]</p>
<p>How Much Transmission-Line Loss is Too Much? [<a
href="http://blog.teledynelecroy.com/2018/06/how-much-transmission-line-loss-is-too.html">http://blog.teledynelecroy.com/2018/06/how-much-transmission-line-loss-is-too.html</a>]</p>
<p>Y. Massoud and Y. Ismail, "Gasping the impact of on-chip inductance,"
in IEEE Circuits and Devices Magazine, vol. 17, no. 4, pp. 14-21, July
2001, doi: 10.1109/101.950046.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>innovus create and assign bump - part one</title>
    <url>/2022/02/14/innovus-bump-part1/</url>
    <content><![CDATA[<h4 id="powerground-bump">power/ground bump</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_bump –cell PAD90UBMBOP –loc_type cell_center –loc <span class="variable">$x0</span> <span class="variable">$y</span>  </span><br><span class="line">create_bump –cell PAD90UBMBOP –loc_type cell_center –loc <span class="variable">$x1</span> <span class="variable">$y</span> </span><br><span class="line">...</span><br><span class="line">create_bump –cell PAD90UBMBOP –loc_type cell_center –loc <span class="variable">$xn</span> <span class="variable">$y</span> </span><br><span class="line">deselectAll </span><br><span class="line">select_bump –bum_cell PAD90UBMBOP </span><br><span class="line">assignPGBumps –nets &#123;vss vdd_dig&#125; -selected –checkboard</span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/14/innovus-bump-part1/pma_dig_bumps.drawio.svg"
alt="pma_dig_bumps.drawio" /></p>
<h4 id="signal-or-powerground-bump">signal or power/ground bump</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> bump_name [create_bump –cell PAD150PITCH –loc <span class="variable">$bump_x</span> <span class="variable">$bump_y</span> –loc_type cell_center –return_bumps_name] </span><br><span class="line"><span class="comment"># assign power/ground bump</span></span><br><span class="line">assignPGBumps –bumps <span class="variable">$bump_name</span> –nets <span class="variable">$pin_name</span> </span><br><span class="line"><span class="comment"># or assign to signal bump</span></span><br><span class="line">assignSigToBump –bumps <span class="variable">$bump_name</span> –net <span class="variable">$pin_name</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Circuit insight</title>
    <url>/2023/01/01/insight/</url>
    <content><![CDATA[<h2 id="effect-of-feedback-on-noise">Effect of Feedback on Noise</h2>
<blockquote>
<p>Feedback does <strong>not improve</strong> the noise performance of
circuits.</p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20240508205903213.png"
alt="image-20240508205903213" /></p>
<blockquote>
<p>The input-referred noise voltage and current remain the same if the
feedback network introduces no noise.</p>
</blockquote>
<h2 id="burn-in-high-temperature-operating-life-htol">Burn-in &amp;
High-temperature operating life (HTOL)</h2>
<p><em>TODO</em> 📅</p>
<h2 id="rc-charge-and-discharge">RC charge and discharge</h2>
<ul>
<li><p>charge: <span class="math display">\[
V_o(t) = V_{X}(1-e^{-\frac{t}{\tau}}) + V_{o,0}\cdot
e^{-\frac{-t}{\tau}}
\]</span></p></li>
<li><p>discharge: <span class="math display">\[
V_o(t) = V_{o,0}\cdot e^{-\frac{t}{\tau}} +
V_{o,\infty}\cdot(1-e^{-\frac{t}{\tau}})
\]</span></p></li>
</ul>
<blockquote>
<ol type="1">
<li><span class="math inline">\(e^{-\frac{t}{\tau}}\)</span> item
determine the <strong>initial state </strong></li>
<li><span class="math inline">\((1-e^{-\frac{t}{\tau}})\)</span> item
determine the <strong>final state</strong></li>
</ol>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231104231640290.png"
alt="image-20231104231640290" /></p>
<p><img src="/2023/01/01/insight/image-20231104232000036.png"
alt="image-20231104232000036" /></p>
<h3 id="ac-coupling">AC coupling</h3>
<p><img src="/2023/01/01/insight/image-20231121224940814.png"
alt="image-20231121224940814" /></p>
<p><img src="/2023/01/01/insight/image-20231121225358509.png"
alt="image-20231121225358509" /></p>
<hr />
<p><span class="math display">\[
\tau = 200 \text{nF} \times (50+50)\text{ohm} = 20 \mu s
\]</span></p>
<p>high level envelope:</p>
<p><img src="/2023/01/01/insight/image-20231121230155083.png"
alt="image-20231121230155083" /></p>
<p><img src="/2023/01/01/insight/image-20231121230225895.png"
alt="image-20231121230225895" /></p>
<h2 id="switched-capacitor-resistor">switched-capacitor resistor</h2>
<p><img src="/2023/01/01/insight/image-20231104212333555.png"
alt="image-20231104212333555" /></p>
<p><img src="/2023/01/01/insight/image-20231104212343670.png"
alt="image-20231104212343670" /></p>
<blockquote>
<p>Switching the capacitor moves a charge proportional to the voltage
difference. The resistor achieves the same function only in a continuous
manner.</p>
<p>Using a water analogy, we can imagine a couple of scenarios:</p>
<ol type="1">
<li>a steady water flow,</li>
<li>or 2) the same water delivered rapidly in buckets. Both create the
same flow of water - <strong>on average!</strong></li>
</ol>
</blockquote>
<h2 id="current-mirror-with-source-degeneration">Current mirror with
source degeneration</h2>
<p><img src="/2023/01/01/insight/image-20231103213308081.png"
alt="image-20231103213308081" /></p>
<p><img src="/2023/01/01/insight/image-20231103213327501.png"
alt="image-20231103213327501" /></p>
<p><img
src="/2023/01/01/insight/current_mirror_with_res_degeneration.jpg"
alt="degeneration" /></p>
<blockquote>
<p>Razavi 2nd, problem 14.15</p>
</blockquote>
<h2 id="monitored-analog-critical-parameters">Monitored Analog Critical
Parameters</h2>
<p><img src="/2023/01/01/insight/monitor_parameters.drawio.svg"
alt="monitor_parameters.drawio" /></p>
<p>Parameter Definition:</p>
<p><span class="math display">\[\begin{align}
I_{\text{D,lin}} &amp;= I_D \mid _{V_G=V_{DD},V_D=0.05V} \\
I_{\text{D,sat}} &amp;= I_D \mid _{V_G=V_D=V_{DD}} \\
V_{\text{t,lin}} &amp;= V_G \mid _{I_D=I_{\text{thx}}\cdot
\frac{W}{L}@\{V_D=0.05V\}}
\end{align}\]</span></p>
<blockquote>
<p><span class="math inline">\(I_{\text{thx}}\)</span> could be
different for technologies. (For N16, <span
class="math inline">\(I_{\text{thx}}=10\)</span>nA)</p>
</blockquote>
<h2 id="demystifying-stb-and-pstb-in-spectre">Demystifying stb and pstb
in Spectre</h2>
<p>All credits to my colleague, Zhang Wenpian.</p>
<h3 id="spectres-stb-analysis">Spectre's stb analysis</h3>
<p>Spectre <strong>stb</strong>'s "loopgain" is negative of "T" in
paper<sup>[1]</sup> <span class="math display">\[
T = \frac{2(AD-BC) - A + D}{2(AD-BC)-A+D-1}
\]</span></p>
<p>AC simulation testbench, shown as below,</p>
<p><img src="/2023/01/01/insight/stb_pstb.drawio.svg"
alt="stb_pstb.drawio" /></p>
<ol type="1">
<li><p><span class="math inline">\(I_{inj}\)</span> = 0, <span
class="math inline">\(V_{inj}\)</span> = 1</p>
<p>B = if, D = ve</p></li>
<li><p><span class="math inline">\(I_{inj}\)</span> = 1, <span
class="math inline">\(V_{inj}\)</span> = 0</p>
<p>A = if, C = ve</p></li>
</ol>
<h3 id="spectres-pstb-analysis">Spectre's pstb analysis</h3>
<p>Spectre <strong>pstb</strong> is similar to stb, just set
<strong>pac</strong> as <strong>1</strong> instead of
<strong>ac</strong> in current source and voltage source.</p>
<p>This analysis just use <strong>harmonic 0</strong> transfer function
in pac analysis, which has limitation.</p>
<h2 id="thevenin-and-norton-equivalent-circuits">Thevenin and Norton
Equivalent Circuits</h2>
<h3 id="戴维南定理">戴维南定理</h3>
<p><img src="/2023/01/01/insight/image-20231021084850078.png"
alt="image-20231021084850078" /></p>
<h3 id="等效电阻的计算方法">等效电阻的计算方法</h3>
<p><img src="/2023/01/01/insight/image-20231021085151943.png"
alt="image-20231021085151943" /></p>
<blockquote>
<p>使用<strong>外加电源法</strong>时， 全部独立电源需要置零</p>
</blockquote>
<h3 id="诺顿定理">诺顿定理</h3>
<p><img src="/2023/01/01/insight/image-20231021090448282.png"
alt="image-20231021090448282" /></p>
<h4 id="lemma-of-razavi">Lemma of Razavi</h4>
<p><span class="math display">\[
A_V = -G_m R_{out}
\]</span></p>
<p><img src="/2023/01/01/insight/image-20231021092407849.png"
alt="image-20231021092407849" /></p>
<blockquote>
<p><em>Design of Analog CMOS Integrated Circuits, Second Edition -
Behzad Razavi</em></p>
</blockquote>
<h2 id="millers-approximation-right-half-plane-zero">Miller's
Approximation: right-half-plane zero</h2>
<p><img src="/2023/01/01/insight/image-20231021101204165.png"
alt="image-20231021101204165" /></p>
<p>A quick inspection of this circuit reveals that a
<strong>zero</strong> lies at a frequency where the current through
<span class="math inline">\(C_{12}\)</span> becomes equal to <span
class="math inline">\(g_2V_1\)</span>.</p>
<p>When this occurs, the current through the parallel combination of
<span class="math inline">\(C_2\)</span> and <span
class="math inline">\(R_2\)</span> becomes zero, creating a zero in the
transfer function.</p>
<p>In other words, we can write</p>
<p><span class="math display">\[\begin{align}
g_2V_1 &amp;= V_1sC_{12} \\
s &amp;= \frac{g_2}{C_{12}}
\end{align}\]</span></p>
<h2 id="how-to-mitigate-impact-of-zero">How to Mitigate Impact of
Zero</h2>
<h3 id="lectures">Lectures</h3>
<p>EE 240B: Advanced Analog Circuit Design, Prof. Bernhard E. Boser [<a
href="https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M07%20OTA%20II.pdf">OTA
II, Multi-Stage</a>]</p>
<h3 id="papers">Papers</h3>
<p>B. K. Ahuja, "An improved frequency compensation technique for CMOS
operational amplifiers," in IEEE Journal of Solid-State Circuits, vol.
18, no. 6, pp. 629-633, Dec. 1983, doi: 10.1109/JSSC.1983.1052012.</p>
<p>D. B. Ribner and M. A. Copeland, "Design techniques for cascoded CMOS
op amps with improved PSRR and common-mode input range," in IEEE Journal
of Solid-State Circuits, vol. 19, no. 6, pp. 919-925, Dec. 1984, doi:
10.1109/JSSC.1984.1052246.</p>
<p>Abo, Andrew &amp; Gray, Paul. (1999). A 1.5V, 10-bit, 14MS/s CMOS
Pipeline Analog-to-Digital Converter.</p>
<h3 id="books-chapters">Book's chapters</h3>
<p>Design of analog CMOS integrated circuits, Behzad Razavi</p>
<ul>
<li>10.5 Compensation of Two-Stage Op Amps</li>
<li>10.7 Other Compensation Techniques</li>
</ul>
<p>Analog Design Essentials, Willy M.C. Sansen</p>
<ul>
<li>chapter #5 Stability of operational amplifiers - Compensation of
positive zero</li>
</ul>
<p>Analysis and Design of Analog Integrated Circuits 5th Edition, Paul
R. Gray, Paul J. Hurst, Stephen H. Lewis, Robert G. Meyer</p>
<ul>
<li>9.4.3 Two-Stage MOS Amplifier Compensation</li>
</ul>
<p>CMOS Analog Circuit Design 3rd Edition, Phillip E. Allen, Douglas R.
Holberg</p>
<ul>
<li>6.2.2 Miller Compensation of the Two-Stage Op Amp</li>
</ul>
<h3 id="example---cascode-compensation">Example - cascode
compensation</h3>
<p><img src="/2023/01/01/insight/cascode_compensation.PNG"
alt="cascode_compensation" /> <span class="math display">\[\begin{align}
\omega_{p1} &amp;= \frac {1} {R_{eq}g_{m9}R_{L}C_{c}} \\
\omega_{p2} &amp;= \frac {g_{m4}R_{eq}g_{m9}} {C_L} \\
\omega_z &amp;= (g_{m4}R_{eq})(\frac {g_{m9}} {C_c})
\end{align}\]</span></p>
<blockquote>
<p>Figure 10.46 in Razavi's book</p>
</blockquote>
<h2 id="non-overlapping-clock">Non Overlapping Clock</h2>
<div class="pdf-container" data-target="/pdfs/nonoverlapping_clocks.pdf" data-height="500px"></div>
<h2 id="single-ended-amplifier-offset-voltage">Single ended Amplifier
Offset Voltage</h2>
<h3 id="unity-gain-buffer">unity gain buffer</h3>
<p><img src="/2023/01/01/insight/image-20220917115231508.png"
alt="image-20220917115231508" /></p>
<p><span class="math display">\[\begin{align}
V_o &amp;= V_{o,dc}+A(V_p-V_m) \\
V_o&#39; &amp;= V_{o,dc}+A(V_p+V_{os}-V_m&#39;)
\end{align}\]</span></p>
<p>Then, we get <span class="math display">\[
V_{os}=\frac{V_o&#39;-V_o}{A}+(V_m&#39;-V_m)
\]</span> Due to <span class="math inline">\(V_o=V_m\)</span> and <span
class="math inline">\(V_o&#39;=V_m&#39;\)</span> <span
class="math display">\[
V_{os}=(1/A+1)\Delta{V_m}
\]</span> or <span class="math display">\[
V_{os}=(1/A+1)\Delta{V_o}
\]</span> if <span class="math inline">\(A \gg 1\)</span> <span
class="math display">\[
V_{os}=\Delta{V_o}
\]</span></p>
<h3 id="non-inverting-amplifier">non-inverting amplifier</h3>
<p><img src="/2023/01/01/insight/image-20220917115308699.png"
alt="image-20220917115308699" /> <span
class="math display">\[\begin{align}
V_o &amp;= V_{o,dc}+A(V_p-V_m) \\
V_o&#39; &amp;= V_{o,dc}+A(V_p+V_{os}-V_m&#39;) \\
V_m &amp;= \beta V_o \\
V_m&#39; &amp;= \beta V_o&#39;
\end{align}\]</span></p>
<p>we get <span class="math display">\[
V_{os}=\frac{V_o&#39;-V_o}{A}+(V_m&#39;-V_m)
\]</span> or <span class="math display">\[
V_{os}=\frac{\Delta V_o}{A}+\beta \Delta V_o
\]</span> if <span class="math inline">\(A \gg 1\)</span> <span
class="math display">\[
V_{os}=\beta \Delta V_o
\]</span> or <span class="math display">\[
V_{os}=\Delta V_m
\]</span></p>
<hr />
<p><strong>Lecture 22 Variability and Mismatch of Dr. Hesham A. Omran's
Analog IC Design</strong></p>
<p><img src="/2023/01/01/insight/image-20221022010448797.png"
alt="image-20221022010448797" /></p>
<blockquote>
<p>URL: <a
href="https://www.master-micro.com/professional-courses/analog-ic-design/course-resources">https://www.master-micro.com/professional-courses/analog-ic-design/course-resources</a></p>
</blockquote>
<h2 id="gotcha-mos-ron">Gotcha MOS ron</h2>
<p>There is discrepancy between model operating point and <span
class="math inline">\(V_{ds}/I_{ds}\)</span></p>
<p>I believe that the equation <span
class="math inline">\(V_{ds}/I_{ds}\)</span> is more appropriate where
mos is used as switch, though <span
class="math inline">\(V_{ds}=0\)</span> is an outlier.</p>
<p><img src="/2023/01/01/insight/image-20230104230757729.png"
alt="image-20230104230757729" /></p>
<p><img src="/2023/01/01/insight/image-20230104230837829.png"
alt="image-20230104230837829" /></p>
<p><img src="/2023/01/01/insight/image-20230104230851475.png"
alt="image-20230104230851475" /></p>
<h2 id="channel-length-modulation">Channel-length modulation</h2>
<blockquote>
<p>short-channel effects</p>
</blockquote>
<p><span class="math display">\[\begin{align}
I_D
&amp;=\frac{1}{2}\mu_nC_{ox}\frac{W}{L}(V_{GS}-V_{TH})^2(1+\frac{\Delta
L}{L}) \\
I_D &amp;=\frac{1}{2}\mu_nC_{ox}\frac{W}{L}(V_{GS}-V_{TH})^2(1+\lambda
V_{DS}) \\
I_D
&amp;=\frac{1}{2}\mu_nC_{ox}\frac{W}{L}(V_{GS}-V_{TH})^2(1+\frac{V_{DS}}{V_A})
\end{align}\]</span></p>
<p>where <span class="math inline">\(\frac{\Delta L}{L}=\lambda
V_{DS}\)</span> and <span
class="math inline">\(V_A=\frac{1}{\lambda}\)</span></p>
<p><span class="math inline">\(\lambda\)</span> is channel length
modulation parameter</p>
<p><span class="math inline">\(V_A\)</span>, i.e. Early voltage is equal
to inverse of channel length modulation parameter</p>
<p>The output resistance <span class="math inline">\(r_o\)</span></p>
<p><span class="math display">\[\begin{align}
r_o &amp;= \frac{\partial V_{DS}}{\partial I_D} \\
&amp;= \frac{1}{\partial I_D/\partial V_{DS}} \\
&amp;= \frac{1}{\lambda I_D} \\
&amp;= \frac{V_A}{I_D}
\end{align}\]</span></p>
<p>Due to <span class="math inline">\(\lambda \propto 1/L\)</span>, i.e.
<span class="math inline">\(V_A \propto L\)</span> <span
class="math display">\[
r_o \propto \frac{L}{I_D}
\]</span> <img src="/2023/01/01/insight/image-20220930001909262.png"
alt="image-20220930001909262" /></p>
<p><img src="/2023/01/01/insight/image-20220930002003924.png"
alt="image-20220930002003924" /></p>
<p><img src="/2023/01/01/insight/image-20220930002157365.png"
alt="image-20220930002157365" /></p>
<p>The output resistance is almost doubled using Stacked FET in
<em>saturation region</em></p>
<blockquote>
<p><span class="math inline">\(V_t\)</span> and mobility <span
class="math inline">\(\mu_{n,p}\)</span> are sensitive to
temperature</p>
<ul>
<li><span class="math inline">\(V_t\)</span> decreases by 2-mV for every
1<span class="math inline">\(^oC\)</span> rise in temperature</li>
<li>mobility <span class="math inline">\(\mu_{n,p}\)</span> decreases
with temperature</li>
</ul>
<p>Overall, increase in temperature results in lower drain currents</p>
</blockquote>
<h2
id="biasing-current-source-and-global-variation-monte-carlo-simulation">Biasing
current source and global variation Monte Carlo simulation</h2>
<p><img src="/2023/01/01/insight/image-20221020225334767.png"
alt="image-20221020225334767" /></p>
<p><img src="/2023/01/01/insight/image-20221020225502503.png"
alt="image-20221020225502503" /></p>
<p><strong>iwl</strong>: biased by mirror</p>
<p><strong>iwl_ideal</strong>: biased by <em>vdc</em> source, whose
value is <em>typical corner</em></p>
<hr />
<p>For <strong>local variation</strong>, constant voltage bias
(<em>vb_const</em> in schematic) help reduce variation from <span
class="math inline">\(\sqrt{2}\Delta V_{th}\)</span> to <span
class="math inline">\(\Delta V_{th}\)</span></p>
<p>For <strong>global variation</strong>, <em>all device have same
variation</em>, mirror help reduce variation by sharing same <span
class="math inline">\(V_{gs}\)</span></p>
<ol type="1">
<li>global variation + local variation (All MC)</li>
</ol>
<p><img src="/2023/01/01/insight/image-20221020225615633.png"
alt="image-20221020225615633" /></p>
<ol start="2" type="1">
<li>local variation (Mismatch MC)</li>
</ol>
<p><img src="/2023/01/01/insight/image-20221020225701218.png"
alt="image-20221020225701218" /></p>
<ol start="3" type="1">
<li>global variation (Process MC)</li>
</ol>
<p><img src="/2023/01/01/insight/image-20221020232515420.png"
alt="image-20221020232515420" /></p>
<blockquote>
<p>We had better bias mos gate with mirror rather than the <em>vdc</em>
source while simulating sub-block.</p>
<p>This is real situation due to current source are always biased by
mirror and <em>vdc</em> biasing don't give the right result in global
variation Monte Carlo simulation (<em>542.8n</em> is too pessimistic,
<em>13.07p</em> is right result)</p>
</blockquote>
<h2 id="schmitt-inverter">Schmitt Inverter</h2>
<p><img src="/2023/01/01/insight/image-20231021232912529.png"
alt="image-20231021232912529" /></p>
<h2 id="gmid-adt">gm/ID: ADT</h2>
<p><img src="/2023/01/01/insight/image-20230101175707586.png"
alt="image-20230101175707586" /></p>
<p><img src="/2023/01/01/insight/image-20230101191928423.png"
alt="image-20230101191928423" /></p>
<p><img src="/2023/01/01/insight/image-20230101212125344.png"
alt="image-20230101212125344" /></p>
<p><img src="/2023/01/01/insight/image-20230101234936702.png"
alt="image-20230101234936702" /></p>
<p><img src="/2023/01/01/insight/image-20230101235655601.png"
alt="image-20230101235655601" /></p>
<p><img src="/2023/01/01/insight/image-20230102000059723.png"
alt="image-20230102000059723" /></p>
<p><img src="/2023/01/01/insight/image-20230103220933081.png"
alt="image-20230103220933081" /></p>
<blockquote>
<p>small gm/ID for High ro, or high Early voltage <span
class="math inline">\(V_A\)</span></p>
</blockquote>
<h2 id="transit-frequency-f_t">Transit Frequency <span
class="math inline">\(f_T\)</span></h2>
<p>Defined as the frequency at which the <strong>small-signal current
gain</strong> of a device is <strong>unity</strong></p>
<p><img src="/2023/01/01/insight/image-20231213234524075.png"
alt="image-20231213234524075" /></p>
<hr />
<p><img src="/2023/01/01/insight/image-20240116233951006.png"
alt="image-20240116233951006" /></p>
<h2 id="g_m-vs-v_textds"><span class="math inline">\(g_m\)</span> vs
<span class="math inline">\(V_{\text{DS}}\)</span></h2>
<p><img src="/2023/01/01/insight/image-20231125224714658.png"
alt="image-20231125224714658" /></p>
<h2 id="operating-points-small-gain-theorem">Operating points &amp;
Small gain theorem</h2>
<blockquote>
<p>Dr. Degang Chen, <strong>EE 501:</strong> <strong>CMOS Analog
Integrated Circuit Design</strong> [<a
href="https://class.ece.iastate.edu/djchen/ee501/2020/References.ppt">https://class.ece.iastate.edu/djchen/ee501/2020/References.ppt</a>]</p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231202102259692.png"
alt="image-20231202102259692" /></p>
<p>For any given constant values of <em>u</em> and <em>v</em>, the
constant values of variables that solve the the feed back relationship
are called the <strong>operating points</strong>, or <strong>equilibrium
points</strong>.</p>
<blockquote>
<p><em>Operating points</em> can be either <em>stable</em> or
<em>unstable</em>.</p>
<p>An operating point is unstable if any or some small perturbation near
it causes divergence away from that operating point.</p>
</blockquote>
<p>If the loop gain evaluated at an operating point is <strong>less than
one</strong>, that operating point is <strong>stable</strong>.</p>
<blockquote>
<p>This is a sufficient condition</p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231202105749888.png"
alt="image-20231202105749888" /></p>
<p><img src="/2023/01/01/insight/image-20231202105621385.png"
alt="image-20231202105621385" /></p>
<p>With <span class="math inline">\(m_{1\to 2} = 1\)</span> <span
class="math display">\[
\text{Loop Gain} \simeq \frac{V_{BN}-V_{T2}}{V_{BN}-V_{T2} + V_R}
\tag{LG\_0}
\]</span> Assuming all MOS in strong inv operation, <span
class="math inline">\(I\)</span>, <span
class="math inline">\(V_{BN}\)</span> and <span
class="math inline">\(V_R\)</span> is obtain <span
class="math display">\[\begin{align}
I &amp;= \frac{2\beta _1 + 2\beta _2 - 4\sqrt{\beta _1 \beta
_2}}{R^2\beta _1 \beta _2} \\
V_{BN} &amp;= V_{T2} + \frac{2}{R\beta _2}(1- \sqrt{\frac{\beta
_2}{\beta _1}}) \\
IR &amp;= \frac{2}{R}\left( \frac{1}{\sqrt{\beta_2}}
-  \frac{1}{\sqrt{\beta_1}} \right)
\end{align}\]</span></p>
<p>Substitute <span class="math inline">\(V_{BN}\)</span> and <span
class="math inline">\(V_R\)</span> of <span
class="math inline">\((LG\_0)\)</span> <span
class="math display">\[\begin{align}
\text{Loop Gain} &amp; \simeq
\frac{1-\sqrt{\frac{\beta_2}{\beta_1}}}{\frac{\beta_2}{\beta_1} -
3\sqrt{\frac{\beta_2}{\beta_1}}+2} \\
&amp;= \frac{1}{2-\sqrt{\frac{\beta_2}{\beta_1}}} \tag{LG\_1}
\end{align}\]</span></p>
<h3 id="alternative-approach-for-loop-gain">Alternative approach for
Loop Gain</h3>
<blockquote>
<p>using derivation of large signal</p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231202132310478.png"
alt="image-20231202132310478" /></p>
<p><img src="/2023/01/01/insight/image-20231202134138319.png"
alt="image-20231202134138319" /></p>
<hr />
<blockquote>
<p>❗❗❗ R should <strong>not</strong> be on the other side</p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231202104505264.png"
alt="image-20231202104505264" /></p>
<h2 id="bias-circuit">Bias Circuit</h2>
<h3 id="cascode-with-switch">cascode with switch</h3>
<p><img src="/2023/01/01/insight/image-20231212145336401.png"
alt="image-20231212145336401" /></p>
<h3 id="cascode-with-single-current-input">cascode with single current
input</h3>
<p><img src="/2023/01/01/insight/image-20231212153054247.png"
alt="image-20231212153054247" /></p>
<h3 id="supply-independent-biasing">Supply Independent Biasing</h3>
<h4 id="constant-gm">constant-gm</h4>
<blockquote>
<p>aka. <strong>Beta-multiplier reference</strong></p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231213235846243.png"
alt="image-20231213235846243" /></p>
<h2 id="mosfet-ztc-condition-analysis">MOSFET ZTC Condition
Analysis</h2>
<blockquote>
<p>zero temperature coefficient (ZTC)</p>
</blockquote>
<p><img src="/2023/01/01/insight/image-20231212195536754.png"
alt="image-20231212195536754" /></p>
<h2 id="mom-cap-of-wo_mx">MOM cap of wo_mx</h2>
<p>Monte Carlo model:</p>
<ul>
<li><span class="math inline">\(C_{pa}=C_{pa1}\)</span>, <span
class="math inline">\(C_{pb}=C_{pb1}\)</span> for each iteration during
<em>Process Variation</em></li>
<li>different variation is applied to <span
class="math inline">\(C_{ab}\)</span> and <span
class="math inline">\(C_{a1b1}\)</span> each iteration during
<em>Mismatch Variation</em>, though <span
class="math inline">\(C_{pa}\)</span>, <span
class="math inline">\(C_{pb}\)</span>, <span
class="math inline">\(C_{pa1}\)</span> and <span
class="math inline">\(C_{pb1}\)</span> remain constant</li>
</ul>
<p><img src="/2023/01/01/insight/image-20230220230434891.png"
alt="image-20230220230434891" /></p>
<p><img src="/2023/01/01/insight/image-20230220230331505.png"
alt="image-20230220230331505" /></p>
<h2 id="active-inductor">Active Inductor</h2>
<p><img src="/2023/01/01/insight/activeInd.svg" alt="activeInd" /></p>
<p><span class="math display">\[\begin{align}
A &amp;= \frac{g_mR_L}{1+(g_\text{m\_dio}+ g_\text{ds\_tot})R_L}\cdot
\frac{1+R_pC_Ps}{1+\frac{(1+g_\text{ds\_tot}R_L)R_PC_P+C_PR_L+R_LC_L}{1+(g_\text{m\_dio}+g_\text{ds\_tot})R_L}s
+ \frac{R_LC_LR_PC_P}{1+(g_\text{m\_dio}+g_\text{ds\_tot})R_L}s^2} \\
&amp;= \frac{g_mR_L}{1+(g_\text{m\_dio}+ g_\text{ds\_tot})R_L}\cdot
\frac{R_PC_P}{
\frac{R_LC_LR_PC_P}{1+(g_\text{m\_dio}+g_\text{ds\_tot})R_L}}\cdot
\frac{1/(R_PC_P)+s}{s^2 +
\frac{(1+g_\text{ds\_tot}R_L)R_PC_P+C_PR_L+R_LC_L}{R_PC_P}s +
\frac{1+(g_\text{m\_dio}+g_\text{ds\_tot})R_L}{R_LC_LR_PC_P}} \\
&amp;= A_0 \cdot A(s)
\end{align}\]</span></p>
<p>That is</p>
<p><span class="math display">\[\begin{align}
\omega_z &amp;= \frac{1}{R_PC_P} \tag{1} \\
\omega_n &amp;=
\sqrt{\frac{1+(g_\text{m\_dio}+g_\text{ds\_tot})R_L}{R_LC_LR_PC_P}} =
\sqrt{\omega_{p0}\omega_z} \\
\zeta &amp; = \frac{(1+g_\text{ds\_tot}R_L)R_PC_P+C_PR_L+R_LC_L}{R_PC_P}
\frac{1}{2 \omega_n}
\end{align}\]</span></p>
<p>Where <span class="math display">\[\begin{align}
\omega_{p0} &amp;=
\frac{1}{(R_L||\frac{1}{g_\text{m\_dio}}||\frac{1}{g_\text{ds\_tot}})C_L}  \tag{2}
\end{align}\]</span></p>
<p>Here, relate <span class="math inline">\(\omega_{p0}\)</span> and
<span class="math inline">\(\omega_z\)</span> by coefficient <span
class="math inline">\(\alpha\)</span> <span class="math display">\[
\omega_{p0} = \alpha \cdot  \omega_z \tag{3}
\]</span> This way <span class="math display">\[
\omega_n= \sqrt{\alpha}\cdot \omega_z
\]</span></p>
<p><span class="math display">\[
\zeta = \frac{1}{2}(K\sqrt{\alpha}+\frac{1+C_P/C_L}{\sqrt{\alpha}})
\tag{4}
\]</span> where <span class="math display">\[
K =
\frac{R_L||\frac{1}{g_\text{m\_dio}}||\frac{1}{g_\text{ds\_tot}}}{R_L||g_\text{ds\_tot}}
\]</span></p>
<p>And <span class="math inline">\(A(s)\)</span> can be expressed as
<span class="math display">\[
A(s) =
\frac{\frac{s}{\omega_z}+1}{\frac{s^2}{\omega_n^2}+2\frac{\zeta}{\omega_n}s+1}
\]</span> It magnitude in dB <span class="math display">\[
A_\text{dB} =
10\log\frac{1+(\omega/\omega_z)^2}{1+(\omega/\omega_n)^4+2\omega^2(2\zeta^2-1)/\omega_n^2}
\]</span> Substitute <span class="math inline">\(\omega_n\)</span> with
Eq (2), followed is obtained <span class="math display">\[
A_\text{dB} = 10\log{\frac{\alpha^2(\omega_z^4 +
\omega_z^2\omega^2)}{\alpha^2\omega_z^4+\omega^4+2\alpha\omega_z^2(2\zeta^2-1)\omega^2}}
\]</span> peaking frequency <span class="math display">\[
\omega_\text{peak} = \omega_z\cdot \sqrt{\sqrt{(\alpha+1)^2 - 4\alpha
\zeta^2}-1}
\]</span> If <span class="math inline">\(\zeta=1\)</span> <span
class="math display">\[\begin{align}
\omega_{A_\text{dB = 0dB} }&amp;= \sqrt{1-2/\alpha}\cdot \omega_{p0} \\
\omega_\text{peak} &amp;= \omega_z\sqrt{\alpha-2} \\
A_\text{dB,peak} &amp;= 10\log\frac{\alpha^2}{4(\alpha-1)}
\end{align}\]</span></p>
<h2 id="miller-multiplication-of-capacitor">Miller multiplication of
Capacitor</h2>
<h3 id="positive-cap">Positive Cap</h3>
<p><img src="/2023/01/01/insight/image-20231220225508580.png"
alt="image-20231220225508580" /></p>
<p><img src="/2023/01/01/insight/image-20231220225450481.png"
alt="image-20231220225450481" /></p>
<h3 id="negative-cap">Negative Cap</h3>
<p><img src="/2023/01/01/insight/image-20231220225910283.png"
alt="image-20231220225910283" /></p>
<p><img src="/2023/01/01/insight/image-20231220230015868.png"
alt="image-20231220230015868" /></p>
<h2 id="ds-small-signal-model">D/S small signal model</h2>
<p><img src="/2023/01/01/insight/image-20240106161059584.png"
alt="image-20240106161059584" /></p>
<blockquote>
<p>The <code>Drain</code> and <code>Source</code> of MOS are determined
in <em>DC operating point</em>, i.e. large signal.</p>
</blockquote>
<p>That is, top of <span class="math inline">\(M_2\)</span> is
<code>drain</code> and bottom is <code>source</code>, <span
class="math display">\[\begin{align}
R_\text{eq2} &amp;= \frac{r_\text{o2}+R_L}{1+g_\text{m2}r_\text{o2}} \\
&amp; \simeq  \frac{1}{g_\text{m2}}
\end{align}\]</span></p>
<h2 id="pmos-small-signal-model-polarity">PMOS small signal model
polarity</h2>
<blockquote>
<p>The small-signal models of NMOS and PMOS transistors are
<strong>identical</strong></p>
</blockquote>
<p>A negative <span class="math inline">\(\Delta V_\text{GS}\)</span>
leads to a negative <span class="math inline">\(\Delta I_D\)</span>.</p>
<blockquote>
<p>Recall that <span class="math inline">\(I_D\)</span>, in the
direction shown here, is negative because the actual current of holes
flows from the source to the drain.</p>
<p><img src="/2023/01/01/insight/image-20240106170315177.png"
alt="image-20240106170315177" /></p>
</blockquote>
<p>Conversely, a positive <span class="math inline">\(\Delta
V_\text{GS}\)</span> produces a positive <span
class="math inline">\(\Delta I_D\)</span>, as is the case for an NMOS
device.</p>
<p><img src="/2023/01/01/insight/image-20240106164923917.png"
alt="image-20240106164923917" /></p>
<h2 id="current-mirror-mismatch">current mirror mismatch</h2>
<p>The current mismatch consists of two components.</p>
<ul>
<li>The first depends on threshold voltage mismatch and increases as the
overdrive <span class="math inline">\((V_{GS} − V_t)\)</span> is
reduced.</li>
<li>The second is geometry dependent and contributes a fractional
current mismatch that is independent of bias point.</li>
</ul>
<p><span class="math display">\[
\Delta I_D = g_m\cdot \Delta V_{TH}+I_D\cdot \frac{\Delta(W/L)}{W/L}
\]</span></p>
<p>where mismatches in <span class="math inline">\(\mu_nC_{ox}\)</span>
are neglected</p>
<p><span class="math display">\[\begin{align}
\Delta V_{TH} &amp;= \frac{A_{VTH}}{\sqrt{WL}} \\
\frac{\Delta(W/L)}{W/L} &amp;= \frac{A_{WL}}{\sqrt{WL}}
\end{align}\]</span></p>
<h3 id="summary">summary</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 14%" />
<col style="width: 28%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th>Size</th>
<th><span class="math inline">\(g_m\)</span></th>
<th><span class="math inline">\(\Delta V_{TH}\)</span></th>
<th><span class="math inline">\(\frac{\Delta(W/L)}{W/L}\)</span></th>
<th>mismatch (%)</th>
<th>simu (%)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>W, L</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td><span
class="math inline">\(I_{\Delta_{V_{TH}}}+I_{\Delta_{WL}}\)</span></td>
<td>3.44</td>
</tr>
<tr class="even">
<td>W, 2L</td>
<td><span class="math inline">\(1/\sqrt{2}\)</span></td>
<td><span class="math inline">\(1/\sqrt{2}\)</span></td>
<td><span class="math inline">\(1/\sqrt{2}\)</span></td>
<td><span
class="math inline">\(I_{\Delta_{V_{TH}}}/2+I_{\Delta_{WL}}/\sqrt{2}\)</span></td>
<td>1.98</td>
</tr>
<tr class="odd">
<td>2W, L</td>
<td><span class="math inline">\(\sqrt{2}\)</span></td>
<td><span class="math inline">\(1/\sqrt{2}\)</span></td>
<td><span class="math inline">\(1/\sqrt{2}\)</span></td>
<td><span
class="math inline">\(I_{\Delta_{V_{TH}}}+I_{\Delta_{WL}}/\sqrt{2}\)</span></td>
<td>2.93</td>
</tr>
<tr class="even">
<td>We get <span class="math inline">\(I_{\Delta_{V_{TH}}}\simeq
1.71\%\)</span> and <span class="math inline">\(I_{\Delta_{WL}} \simeq
1.73\%\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="/2023/01/01/insight/image-20221003001056211.png"
alt="image-20221003001056211" /></p>
<p><img src="/2023/01/01/insight/image-20221002215942456.png"
alt="image-20221002215942456" /></p>
<h2 id="leakage-in-mos">Leakage in MOS</h2>
<p><img src="/2023/01/01/insight/image-20230812104737404.png"
alt="image-20230812104737404" /></p>
<h3 id="reference">reference</h3>
<p>W. M. Elgharbawy and M. A. Bayoumi, "Leakage sources and possible
solutions in nanometer CMOS technologies," in IEEE Circuits and Systems
Magazine, vol. 5, no. 4, pp. 6-17, Fourth Quarter 2005, doi:
10.1109/MCAS.2005.1550165.</p>
<p>X. Qi et al., "Efficient subthreshold leakage current optimization -
Leakage current optimization and layout migration for 90- and 65- nm
ASIC libraries," in IEEE Circuits and Devices Magazine, vol. 22, no. 5,
pp. 39-47, Sept.-Oct. 2006, doi: 10.1109/MCD.2006.272999.</p>
<p>P. Monsurró, S. Pennisi, G. Scotti and A. Trifiletti, "Exploiting the
Body of MOS Devices for High Performance Analog Design," in IEEE
Circuits and Systems Magazine, vol. 11, no. 4, pp. 8-23, Fourthquarter
2011, doi: 10.1109/MCAS.2011.942751.</p>
<h2 id="reference-1">reference</h2>
<p>M. Tian, V. Visvanathan, J. Hantgan and K. Kundert, "Striving for
small-signal stability," in IEEE Circuits and Devices Magazine, vol. 17,
no. 1, pp. 31-41, Jan. 2001, doi: 10.1109/101.900125.</p>
<p>Open loop gain analysis and "STB" method [<a
href="https://www.linkedin.com/pulse/open-loop-gain-analysis-stb-method-jean-francois-debroux">https://www.linkedin.com/pulse/open-loop-gain-analysis-stb-method-jean-francois-debroux</a>]</p>
<p>The Analog Designer's Toolbox (ADT) | Invited Talk by IEEE Santa
Clara Valley Section CAS Society, <a
href="https://youtu.be/FT6kKC5OdE0">https://youtu.be/FT6kKC5OdE0</a></p>
<p>ESSCIRC2023 Circuit Insights Ali Sheikholeslami [<a
href="https://youtu.be/2xFIZM5_FPw?si=XWwSzDgKWZGB0rX1">https://youtu.be/2xFIZM5_FPw?si=XWwSzDgKWZGB0rX1</a>]</p>
<p>Ali Sheikholeslami, Circuit Intuitions: Thevenin and Norton
Equivalent Circuits, Part 3 IEEE Solid-State Circuits Magazine, Vol. 10,
Issue 4, pp. 7-8, Fall 2018.</p>
<p>Ali Sheikholeslami, Circuit Intuitions: Thevenin and Norton
Equivalent Circuits, Part 2 IEEE Solid-State Circuits Magazine, Vol. 10,
Issue 3, pp. 7-8, Summer 2018.</p>
<p>Ali Sheikholeslami, Circuit Intuitions: Thevenin and Norton
Equivalent Circuits, Part 1 IEEE Solid-State Circuits Magazine, Vol. 10,
Issue 2, pp. 7-8, Spring 2018.</p>
<p>Ali Sheikholeslami, Circuit Intuitions: Miller's Approximation IEEE
Solid-State Circuits Magazine, Vol. 7, Issue 4, pp. 7-8, Fall 2015.</p>
<p>Ali Sheikholeslami, Circuit Intuitions: Miller's Theorem IEEE
Solid-State Circuits Magazine, Vol. 7, Issue 3, pp. 8-10, Summer
2015.</p>
<p>Shanthi Pavan, "Demystifying Linear Time Varying Circuits"</p>
<p>ecircuitcenter. Switched-Capacitor Resistor [<a
href="http://www.ecircuitcenter.com/Circuits/SWCap/SWCap.htm">http://www.ecircuitcenter.com/Circuits/SWCap/SWCap.htm</a>]</p>
<p>Jørgen Andreas Michaelsen. INF4420 Switched-Capacitor Circuits. [<a
href="https://www.uio.no/studier/emner/matnat/ifi/INF4420/v13/undervisningsmateriale/inf4420_v13_07_switchedcapacitor_print.pdf">https://www.uio.no/studier/emner/matnat/ifi/INF4420/v13/undervisningsmateriale/inf4420_v13_07_switchedcapacitor_print.pdf</a>]</p>
<p>chembiyan T. OC Lecture 10: A very basic introduction to switched
capacitor circuits [<a
href="https://youtu.be/SaYtemYp4rQ?si=q2qovTKJrLy65pnu">https://youtu.be/SaYtemYp4rQ?si=q2qovTKJrLy65pnu</a></p>
<p>Robert Bogdan Staszewski, Poras T. Balsara. "All‐Digital Frequency
Synthesizer in Deep‐Submicron CMOS"</p>
<p>Mayank Parasrampuria, Sandeep Jain, Burn-in 101 [<a
href="https://www.edn.com/burn-in-101/">link</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>integrator design</title>
    <url>/2022/11/05/integrator-design/</url>
    <content><![CDATA[<h3 id="application-in-sensor">application in sensor</h3>
<p><img src="/2022/11/05/integrator-design/image-20221106142157115.png"
alt="image-20221106142157115" /></p>
<h4 id="offset-errors">Offset Errors</h4>
<p>The offset of opamp <span class="math inline">\(A_3\)</span> is
<strong>much less critical</strong>:</p>
<ol type="1">
<li><p>It affects the integrated currents via the finite output
impedances <span class="math inline">\(R_{out1,2}\)</span> of the V-I
converters, and is therefore attenuated by a factor <span
class="math inline">\(R_{out1}/R_1\)</span> when referred back to the
input of the sinking V-I converter,</p></li>
<li><p>or by a factor <span class="math inline">\(R_{out2}/R_2\)</span>
when referred back to the input of the sourcing V-I converter.</p></li>
</ol>
<p>Therefore, no special offset cancellation is needed for opamp <span
class="math inline">\(A_3\)</span>.</p>
<p>The current change due to offset of <span
class="math inline">\(A_3\)</span>: <span
class="math display">\[\begin{align}
\frac{V_{BE,os}}{R_1} &amp;= \frac{V_{ota,os}}{R_{out1}} \\
\frac{\Delta V_{BE,os}}{R_2} &amp;= \frac{V_{ota,os}}{R_{out2}}
\end{align}\]</span> Then, the input referenced offset is: <span
class="math display">\[\begin{align}
V_{BE,os} &amp;=\frac{ V_{ota,os}}{R_{out1}/R_1} \\
\Delta V_{BE,os} &amp;= \frac{ V_{ota,os}}{R_{out2}/R_2}
\end{align}\]</span></p>
<h4 id="errors-due-to-finite-gain">Errors due to Finite Gain</h4>
<p>Finite gain of opamp <span class="math inline">\(A_3\)</span> results
in a non-zero overdrive voltage at its input, which modulates the
current Iint due to the finite output impedances of the V-I
converters.</p>
<p>Assuming the opamp is implemented as a <strong>transconductance
amplifier</strong>, there are two main causes of this non-zero overdrive
voltage</p>
<ol type="1">
<li>The finite transconductance <span
class="math inline">\(g_{m3}\)</span> of the opamp, , which implies that
an overdrive voltage is required to provide the <strong>feedback
current</strong></li>
</ol>
<p>​ The change in the integrated current</p>
<p>​ <span class="math display">\[\begin{align}
​   \Delta I_{int} &amp;= \frac{V_{i,ota}}{R_{out}}\\
​   &amp;= \frac{I_{int}}{g_{m3}}\cdot \frac{1}{R_{out}}
​   \end{align}\]</span></p>
<ol start="2" type="1">
<li>The finite DC gain <span class="math inline">\(A_{0,3}\)</span>,
which implies that an overdrive voltage is required to produce the
<strong>output voltage</strong> <span
class="math inline">\(V_{int}\)</span></li>
</ol>
<h3 id="reference">reference</h3>
<p>Micheal, A., P., Pertijs., Johan, H., Huijsing., Pertijs., Johan, H.,
Huijsing. (2006). Precision Temperature Sensors in CMOS Technology.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Impulse Sensitivity Function (ISF) of Periodic Sampler</title>
    <url>/2022/06/10/isf-sampler/</url>
    <content><![CDATA[<p>An efficient method to measure the ISFs of periodic circuits via
periodic AC (PAC) analysis, which is available from RF circuit
simulators such as SpectreRF and ADS</p>
<h2 id="isf">ISF</h2>
<h3 id="linear-time-varying-system-theory">Linear Time-varying System
Theory</h3>
<p>We define the ISF of the sampler as the sensitivity of its final
output voltage to the impulse arriving at its input at different times,
the ISF essentially describes the aperture of the sampler.</p>
<p>An ideal sampler would have the perfect aperture, i.e. sampling the
input voltage at exactly one point in time; thus, its ISF would be a
Dirac delta function, <span class="math inline">\(\delta(t-t_s)\)</span>
where <span class="math inline">\(t_s\)</span> is when sampling
occurs.</p>
<p>A realistic sampler would rather capture a weighted-average of the
input voltage over a certain time window. This weighting function is
called the sampling aperture and is equivalent to the ISF</p>
<p><img src="/2022/06/10/isf-sampler/image-20220610235211500.png"
alt="image-20220610235211500" /></p>
<p>A <strong>time-varying impulse response</strong> <span
class="math inline">\(h(t, \tau)\)</span> is defined as the circuit
response at time <span class="math inline">\(t\)</span> responding to an
impulse arriving at time <span class="math inline">\(\tau\)</span>.</p>
<p>In general, the ISF can be regarded as the <strong>time-varying
impulse response</strong> evaluated at <em>one particular observation
time</em> <span class="math inline">\(t=t_0\)</span>.</p>
<p>The system output <span class="math inline">\(y(t)\)</span> is
related to the input <span class="math inline">\(x(t)\)</span> as: <span
class="math display">\[
y(t) = \int_{-\infty}^{\infty}h(t, \tau)\cdot x(\tau)d\tau
\]</span> Note that in a linear time-invariant (LTI) system, <span
class="math inline">\(h(t,\tau)=h(t-\tau)\)</span> and the above
equation reduces to a convolution.</p>
<p>If <span class="math inline">\(X(j\omega)\)</span> is the Fourier
transform of the input signal <span class="math inline">\(x(t)\)</span>,
i.e. <span class="math display">\[
x(t) = \frac{1}{2\pi}\int_{-\infty}^{\infty}X(j\omega)\cdot e^{j\omega
t}d\omega
\]</span> Then <span class="math display">\[\begin{align}
y(t) &amp;=
\int_{-\infty}^{\infty}h(t,\tau)\left[\frac{1}{2\pi}\int_{-\infty}^{\infty}X(j\omega)\cdot
e^{j\omega\tau }d\omega \right]\cdot d\tau \\
&amp;=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(j\omega)\left[\int_{-\infty}^{\infty}h(t,\tau)\cdot
e^{j\omega\tau}d\tau\right]\cdot d\omega \\
&amp;=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(j\omega)\left[\int_{-\infty}^{\infty}h(t,\tau)\cdot
e^{-j\omega(t-\tau)}d\tau\right]\cdot e^{j\omega t}\cdot d\omega \\
&amp;=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(j\omega)\cdot
H(j\omega;t)\cdot e^{j\omega t}\cdot d\omega
\end{align}\]</span></p>
<p>where <span class="math inline">\(H(j\omega;t)\)</span> is
<strong>time-varying transfer function</strong>, defined as the Fourier
transform of the time-varying impulse response. <span
class="math display">\[
H(j\omega;t)=\int_{-\infty}^{\infty}h(t,\tau)\cdot
e^{-j\omega(t-\tau)}d\tau
\]</span> And it follows that: <span class="math display">\[
Y(j\omega)=H(j\omega;t)\cdot X(j\omega)
\]</span> And</p>
<p><span class="math display">\[\begin{align}
x(\tau) &amp; \overset{FT}{\longrightarrow} X(j\omega) \\
h(t,\tau) &amp; \overset{FT}{\longrightarrow} H(j\omega;t)
\end{align}\]</span></p>
<p>For linear, periodically time-varying (LPTV) systems, <span
class="math inline">\(h(t, \tau) = h(t+T, \tau+T)\)</span> and <span
class="math inline">\(H(j\omega; t) = H(j\omega; t+T)\)</span> where
<span class="math inline">\(T\)</span> is the period of the time-varying
dynamics of the system.</p>
<p>We prove <span class="math inline">\(H(j\omega; t) = H(j\omega;
t+T)\)</span>:</p>
<p><span class="math display">\[\begin{align}
\because H(j\omega;t)&amp;=\int_{-\infty}^{\infty}h(t,\tau)\cdot
e^{-j\omega(t-\tau)}d\tau \\
\therefore H(j\omega;t+T) &amp;= \int_{-\infty}^{\infty}h(t+T,\tau)\cdot
e^{-j\omega(t+T-\tau)}d\tau \\
&amp;= \int_{-\infty}^{\infty}h(t+T,\tau+T)\cdot
e^{-j\omega(t+T-(\tau+T))}d(\tau+T) \\
&amp;= \int_{-\infty}^{\infty}h(t+T,\tau+T)\cdot
e^{-j\omega(t-\tau)}d\tau \\
&amp;= \int_{-\infty}^{\infty}h(t,\tau)\cdot e^{-j\omega(t-\tau)}d\tau
\\
&amp;= H(j\omega;t)
\end{align}\]</span></p>
<h3 id="characterizing-isf-via-pac">Characterizing ISF via PAC</h3>
<p>Since <span class="math inline">\(H(j\omega;t)\)</span> is periodic
in <span class="math inline">\(T\)</span>, The time-varying transfer
function <span class="math inline">\(H(j\omega;t)\)</span> can be
expressed in a Fourier series: <span class="math display">\[
H(j\omega;t)=\sum_{m=-\infty}^{\infty}H_m(j\omega) \cdot e^{jm\omega_c
t}
\]</span> where <span class="math inline">\(\omega_c\)</span> is the
fundamental frequency of the periodic system. <span
class="math inline">\(H_m(j\omega)\)</span> represent the frequency
response of the system at the <em>(m-th)</em> harmonic output sideband
to a unit <span class="math inline">\(j\omega\)</span> sinusoid.</p>
<blockquote>
<p>The above equation link time-varying transfer function <span
class="math inline">\(H(j\omega;t)\)</span> with PAC simulation
output</p>
</blockquote>
<p>The response to a periodic impulse train, that is: <span
class="math display">\[
x(t)=\sum_{m=-\infty}^{\infty}\delta(t-\tau-nkT)
\]</span> The idea is that if the impulse response of the system settles
to zero long before the next impulse arrives, then the system response
to this impulse train would be approximately equal to the periodic
repetition of the true impulse response, i.e.: <span
class="math display">\[
y(t) \cong  \sum_{m=-\infty}^{\infty}h(t;\tau+nkT)
\]</span> and <span class="math inline">\(y(t)\)</span> would be
approximately equal to <span class="math inline">\(h(t;\tau)\)</span>
for <span class="math inline">\(\tau \leq t \le t+kT\)</span></p>
<p><img src="/2022/06/10/isf-sampler/yt.drawio.svg"
alt="yt.drawio" /></p>
<blockquote>
<p>Without loss of generality and for computation convenience, we set
<span class="math inline">\(k=1\)</span> thereafter.</p>
</blockquote>
<p>The Fourier transform <span class="math inline">\(X(j\omega)\)</span>
of the <strong>T-periodic</strong> impulse train is: <span
class="math display">\[
X(j\omega)=\omega_c\sum_{n=-\infty}^{\infty}\delta(\omega-n\omega_c)\cdot
e^{-j\omega\tau}
\]</span> Then the response <span class="math inline">\(y(t)\)</span>
is: <span class="math display">\[
y(t)=\frac{1}{T}\sum_{n=-\infty}^{\infty}H(jn\omega_c;t)\cdot
e^{jn\omega_c\cdot(t-\tau)}
\]</span> The expression for the approximate time-varying impulse
response: <span class="math display">\[
h(t,\tau) = \left\{ \begin{array}{cl}
\frac{1}{T}\sum_{n=-\infty}^{\infty}\sum_{m=-\infty}^{\infty}H_m(jn\omega_c)\cdot
e^{jm\omega_ct+jn\omega_c\cdot (t-\tau)} &amp; : \ \tau \leq \tau+T \\
0 &amp; : \ \text{elsewhere}
\end{array} \right.
\]</span> Finally, the ISF <span
class="math inline">\(\Gamma(\tau)\)</span> is equal to <span
class="math inline">\(h(t,\tau)\)</span> when <span
class="math inline">\(t=t_0\)</span> and <span class="math inline">\(t_0
\gt \tau\)</span> <span class="math display">\[
\Gamma(\tau)\cong
\frac{1}{T}\sum_{n=-\infty}^{\infty}\sum_{m=-\infty}^{\infty}H_m(jn\omega_c)\cdot
e^{jm\omega_ct_0+jn\omega_c\cdot (t_0-\tau)}
\]</span> In practice, the summations are carried out over finite ranges
of <strong>n</strong> and <strong>m</strong>, for example, -50~50.</p>
<p>For each combination of <strong>n</strong> and <strong>m</strong>,
the PAC analysis needs to be performed to compute <span
class="math inline">\(H_m(jn\omega_c)\)</span>, the m-th harmonic
response to the excitation at <span
class="math inline">\(n\omega_c\)</span></p>
<p>The detailed procedure for characterizing the ISF of this sampler is
outlined as follows:</p>
<ul>
<li><p>First, apply the proper input voltages that place the sampler in
a metastable state and perform the periodic steady-state (PSS)
analysis.</p></li>
<li><p>Second, perform the PAC analysis.</p></li>
<li><p>Third, based on the simulated PAC response, pick a time point
<span class="math inline">\(t_0\)</span> at which the ISF is to be
computed and derive the ISF</p></li>
</ul>
<p>One possible candidate for the ISF measurement point <span
class="math inline">\(t_0\)</span> is the time at which the output
voltage is amplified to the largest value. PAC response of the sampler
to a small signal DC input, that is, the time-varying transfer function
evaluated at <span class="math inline">\(\omega=0\)</span> <span
class="math display">\[
H(j\omega;t)=\sum_{m=-\infty}^{\infty}H_m(0) \cdot e^{jm\omega_c t}
\]</span> <img src="/2022/06/10/isf-sampler/image-20220614214446328.png"
alt="image-20220614214446328" /></p>
<blockquote>
<p>The total area under the ISF is the sampling gain, which is equal to
the time-varying gain measured at <span
class="math inline">\(t_0\)</span></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time-varying gain at t0 H(0;t0): 19.486305</span><br><span class="line">The total area under the ISF: 19.990230</span><br></pre></td></tr></table></figure>
<h3 id="align-pss_td.pss-with-isf">Align pss_td.pss with ISF</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">****************************************************</span><br><span class="line">Periodic Steady-State Analysis `pss&#x27;: fund = 500 MHz</span><br><span class="line">****************************************************</span><br><span class="line">Trying `homotopy = gmin&#x27; for initial conditions.</span><br><span class="line">DC simulation time: CPU = 4.237 ms, elapsed = 4.27389 ms.</span><br><span class="line"></span><br><span class="line">===============================</span><br><span class="line">`pss&#x27;: time = (0 s -&gt; 102.6 ns)</span><br><span class="line">===============================</span><br><span class="line"></span><br><span class="line">Opening the PSF file ../psf/pss.tran.pss ...</span><br><span class="line">...</span><br><span class="line">Important parameter values in tstab integration:</span><br><span class="line">    start = 0 s</span><br><span class="line">    outputstart = 0 s</span><br><span class="line">    stop = 102.6 ns</span><br><span class="line">    period = 2 ns</span><br><span class="line">    maxperiods = 20</span><br><span class="line">    step = 102.6 ps</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>tstab = 102.6 ns</strong> can be observed in pss simulation
log</p>
<p><img src="/2022/06/10/isf-sampler/image-20220614214537033.png"
alt="image-20220614214537033" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tstab = <span class="number">102.6e-9</span>;</span><br><span class="line">tshift = <span class="built_in">mod</span>(tstab, Tc);</span><br><span class="line">tt_shift = tt - tshift;</span><br><span class="line">tt_shift_start_indx = <span class="built_in">find</span>(tt_shift&gt;=<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">isf_shift = <span class="built_in">circshift</span>(isf_re, -tt_shift_start_indx);</span><br></pre></td></tr></table></figure>
<h3 id="align-pss_fd.pss-with-isf">Align pss_fd.pss with ISF</h3>
<p>Since both are frequency originated, time-shift is NOT needed</p>
<p><img src="/2022/06/10/isf-sampler/image-20220614214613574.png"
alt="image-20220614214613574" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wv</span> = <span class="title">wv_fd</span><span class="params">(fname,tt)</span></span></span><br><span class="line">fd = csvread(fname, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">DC = fd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">w = <span class="number">2</span>*<span class="built_in">pi</span>*fd(<span class="number">2</span>:<span class="keyword">end</span>, <span class="number">1</span>);</span><br><span class="line">coef = fd(<span class="number">2</span>:<span class="keyword">end</span>, <span class="number">2</span>) + <span class="number">1</span><span class="built_in">i</span>*fd(<span class="number">2</span>:<span class="keyword">end</span>, <span class="number">3</span>);</span><br><span class="line">exp_sup = <span class="number">1</span><span class="built_in">i</span>*w.*tt;</span><br><span class="line">wv = sum(<span class="built_in">real</span>(coef .* <span class="built_in">exp</span>(exp_sup)), <span class="number">1</span>) + DC;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="remarks">Remarks</h3>
<p><strong>pss pac setup</strong></p>
<ul>
<li>clock frequency should be low enough to assure system response
settle to zero.</li>
<li>Beat Frequency os PSS should be clock frequency</li>
<li>For PAC setup,
<ul>
<li>the <code>Sweeptype</code> is <code>absolute</code></li>
<li><code>Input Frequency Sweep Range(Hz)</code> should be large
enough.</li>
<li><code>Sweep Type</code> should be <code>Linear</code> and
<code>Step Size</code> should equal <strong>PSS Beat
Frequency(Hz)</strong></li>
<li><code>SideBands</code> should large enough, like 50 (i.e. 50*2 +1,
positive, negative and 0)</li>
<li><code>Specialized Analyses</code> should be <code>None</code></li>
</ul></li>
</ul>
<blockquote>
<p>one example: clock, i.e. beat frequency = 8G PAC: input frequency
sweep from -400G to 400G and step is 8G, which is beat frequency, here
K=1 Eq.(9) of paper</p>
</blockquote>
<blockquote>
<p><strong>freqaxis=out</strong>: <code>freqaxis</code> of PAC not only
affect "Direct Plot"'s output but also simuation data i.e. the phase
shift(imaginary part).</p>
</blockquote>
<p>matlab matrix <strong>nonconjugate transpose</strong>:</p>
<p><code>transpose</code>, <code>.'</code> cf.
https://www.mathworks.com/help/matlab/ref/transpose.html</p>
<h2 id="tstab-in-pss"><code>tstab</code> in PSS</h2>
<p>Using shooting PSS, the steady waveform starts from
<code>tstab+n*tperiod</code>.</p>
<ul>
<li><strong>pss_td.pss</strong> is one period waveform starting from
<code>tstab+n*tperiod</code></li>
<li><strong>pss_fd.pss</strong> is the <em>complex</em> fourier series
coefficient of expanded to left and right <strong>pss_td.pss</strong>
waveform (<code>tstab+n*tperiod : tstab+(n+1)*tperiod</code>)</li>
</ul>
<blockquote>
<p>We have to left-shift <code>mod(tstab, tperiod)</code>
<code>pss_fd.pss</code> in order to align it with of
<strong>pss_tb.pss</strong></p>
</blockquote>
<p><img src="/2022/06/10/isf-sampler/image-20220610222535614.png"
alt="image-20220610222535614" /></p>
<h3 id="simulation-log">simulation log</h3>
<p>The below <code>stop = 1.3 ns</code> is actual <strong>tstab</strong>
time, though <code>Stop Time(tstab)</code> field of pss form is filled
with <code>0.3n</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">Periodic Steady-State Analysis `pss&#x27;: fund = 1 GHz</span><br><span class="line">**************************************************</span><br><span class="line">DC simulation time: CPU = 208 us, elapsed = 211.954 us.</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">`pss&#x27;: time = (0 s -&gt; 1.3 ns)</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">Opening the PSF file ../psf/pss.tran.pss ...</span><br><span class="line"></span><br><span class="line">Output and IC/nodeset summary:</span><br><span class="line">                 save   1       (current)</span><br><span class="line">                 save   2       (voltage)</span><br><span class="line"></span><br><span class="line">Important parameter values in tstab integration:</span><br><span class="line">    start = 0 s</span><br><span class="line">    outputstart = 0 s</span><br><span class="line">    stop = 1.3 ns</span><br><span class="line">    period = 1 ns</span><br><span class="line">    maxperiods = 20</span><br><span class="line">    step = 1.3 ps</span><br><span class="line">    maxstep = 40 ps</span><br><span class="line">    ic = all</span><br><span class="line">    useprevic = no</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    pss: time = 64.01 ps    (4.92 %), step = 31.63 ps     (2.43 %)</span><br><span class="line">	...</span><br><span class="line">    pss: time = 1.224 ns    (94.2 %), step = 40 ps        (3.08 %)</span><br><span class="line">    pss: time = 1.3 ns       (100 %), step = 35.99 ps     (2.77 %)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="pss-simulation-result">PSS simulation result</h3>
<p><img src="/2022/06/10/isf-sampler/image-20220610224100135.png"
alt="image-20220610224100135" /></p>
<h3 id="align-pss_tb-and-pss_fd">Align pss_tb and pss_fd</h3>
<p><img src="/2022/06/10/isf-sampler/image-20220610225310243.png"
alt="image-20220610225310243" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">freq = <span class="number">1e9</span>;</span><br><span class="line">tstab = <span class="number">1.3e-9</span>;</span><br><span class="line">Tp  = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;pss_td.matlab&#x27;</span>)</span><br><span class="line">t = pss_td(:, <span class="number">1</span>);</span><br><span class="line">ytd = pss_td(:, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(t*<span class="number">1e9</span>, ytd, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% time domian from pss frequency domain information</span></span><br><span class="line">coff_real = <span class="number">-0.155222</span>;</span><br><span class="line">coff_imag = <span class="number">-0.0247045</span>;</span><br><span class="line">wc = <span class="number">2</span>*<span class="built_in">pi</span>*freq;</span><br><span class="line">tfd = (<span class="number">0</span>:<span class="number">1e-11</span>:<span class="number">2e-9</span>);</span><br><span class="line">yfd = coff_real*<span class="built_in">cos</span>(wc*tfd) - coff_imag*<span class="built_in">sin</span>(wc*tfd);</span><br><span class="line"><span class="built_in">plot</span>(tfd*<span class="number">1e9</span>, yfd, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% actual pss_td.pss one-period waveform</span></span><br><span class="line">tfd_td = (tstab:<span class="number">1e-11</span>:<span class="number">2e-9</span>);</span><br><span class="line">yfd_td = coff_real*<span class="built_in">cos</span>(wc*tfd_td) - coff_imag*<span class="built_in">sin</span>(wc*tfd_td);</span><br><span class="line"><span class="built_in">plot</span>(tfd_td*<span class="number">1e9</span>, yfd_td, <span class="string">&#x27;--b&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% align pss_fd with pss_tb by left shift mod(tstab, Tp) pss_fd</span></span><br><span class="line">tshift = <span class="built_in">mod</span>(tstab, Tp);</span><br><span class="line">tfd_shift = tfd - tshift;</span><br><span class="line">tfd_shift_start_indx = <span class="built_in">find</span>(tfd_shift&gt;=<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">tfd_shift = tfd_shift(<span class="number">1</span>, tfd_shift_start_indx:<span class="keyword">end</span>);</span><br><span class="line">yfd_shift = yfd(<span class="number">1</span>, tfd_shift_start_indx:<span class="keyword">end</span>);</span><br><span class="line"><span class="built_in">plot</span>(tfd_shift*<span class="number">1e9</span>, yfd_shift, <span class="string">&#x27;-magenta&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;t (ps)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;V(t)&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Using pss\_td&#x27;</span>, <span class="string">&#x27;Using pss\_fd&#x27;</span>, <span class="string">&#x27;pss\_tb one period clip&#x27;</span>, <span class="string">&#x27;Using pss\_fd with time shift&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;east&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>J. Kim, B. S. Leibowitz and M. Jeeradit, "Impulse sensitivity
function analysis of periodic circuits," 2008 IEEE/ACM International
Conference on Computer-Aided Design, 2008, pp. 386-391, doi:
10.1109/ICCAD.2008.4681602.</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Isolation cells</title>
    <url>/2022/05/27/isocells/</url>
    <content><![CDATA[<p>Isolation cells are additional cells inserted by the synthesis tools
for isolating the buses/wires crossing from <strong>power-gated
domain</strong> of a circuit to its always-on domain
(<strong>AON</strong>).</p>
<blockquote>
<p>To prevent corruption of always-on domain, we clamp the nets crossing
the power domains to a value depending upon the design.</p>
</blockquote>
<p><em>A simple circuit having a switchable (or gated) power
domain</em></p>
<p><img src="/2022/05/27/isocells/isolation-cells-1-1.webp"
alt="isolation-cells-1-1" /></p>
<p><em>The circuit shown in Figure 1, after isolation cells are
inserted</em></p>
<p><img src="/2022/05/27/isocells/isolation-cells-2.webp"
alt="isolation-cells-2" /></p>
<h3 id="always-on-buffer">Always-On Buffer</h3>
<p><img
src="https://img-blog.csdnimg.cn/img_convert/1c84b9b7423b064b12b09b1e72b641e5.png"
alt="640?wx_fmt=png" /></p>
<p><img src="/2022/05/27/isocells/image-20230211001607578.png"
alt="image-20230211001607578" /></p>
<p><img src="/2022/05/27/isocells/image-20230211001708189.png"
alt="image-20230211001708189" /></p>
<p><img src="/2022/05/27/isocells/image-20230211001849150.png"
alt="image-20230211001849150" /></p>
<h3 id="reference">reference</h3>
<p>Isolation cells and Level Shifter cells URL: <a
href="https://vlsitutorials.com/isolation-cells-level-shifter-cells-low-power-vlsi/">https://vlsitutorials.com/isolation-cells-level-shifter-cells-low-power-vlsi/</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>jitter amplification</title>
    <url>/2022/03/13/jitter-amplification/</url>
    <content><![CDATA[<h2 id="transient-noise-and-rms_jitter-function">1. transient noise and
rms_jitter function</h2>
<p><img
src="/2022/03/13/jitter-amplification/image-20220608233610066.png"
alt="image-20220608233610066" /></p>
<p><img
src="/2022/03/13/jitter-amplification/image-20220313230930333.png"
alt="image-20220313230930333" /></p>
<blockquote>
<p><code>RJ(rms)</code>: single Edge or Both Edge?</p>
<p><code>RJ(seed)</code>: what is it?</p>
</blockquote>
<h2 id="phase-noise-method">2 phase noise method</h2>
<p>Directly compare the input phase noise and output phase noise, the
input waveform maybe is the PLL output or other clock distribution end
point</p>
<h2 id="jitter-impulse-responsejir-jitter-impulse-responsejir">3. Jitter
Impulse Response(JIR) &amp; Jitter Impulse Response(JIR)</h2>
<p><img
src="/2022/03/13/jitter-amplification/image-20220313231013645.png"
alt="image-20220313231013645" /></p>
<p><img
src="/2022/03/13/jitter-amplification/image-20220313231027512.png"
alt="image-20220313231027512" /></p>
<p><img
src="/2022/03/13/jitter-amplification/image-20220313231038542.png"
alt="image-20220313231038542" /></p>
<h3 id="example">Example</h3>
<h4 id="low-pass-filter">Low Pass Filter</h4>
<p><img
src="/2022/03/13/jitter-amplification/image-20220322124344158.png"
alt="image-20220322124344158" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">32</span>;</span><br><span class="line">x = <span class="built_in">zeros</span>(N,<span class="number">1</span>);</span><br><span class="line">x(<span class="number">1</span>) = <span class="number">6</span>;</span><br><span class="line">x(<span class="number">2</span>) = <span class="number">-2</span>;</span><br><span class="line">x(<span class="number">3</span>) = <span class="number">0.5</span>;</span><br><span class="line">x = x/<span class="number">5</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">stem(x)</span><br><span class="line">Y = fft(x, N);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">abs</span>(Y(<span class="number">1</span>:N/<span class="number">2</span>)));</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/13/jitter-amplification/image-20220322124902394.png"
alt="image-20220322124902394" /></p>
<p><img
src="/2022/03/13/jitter-amplification/image-20220322124932584.png"
alt="image-20220322124932584" /></p>
<h4 id="high-pass-filter">High Pass Filter</h4>
<p><img
src="/2022/03/13/jitter-amplification/image-20220327010223664.png"
alt="image-20220327010223664" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">128</span>;</span><br><span class="line">j_hp = <span class="built_in">zeros</span>(N, <span class="number">1</span>);</span><br><span class="line">j_hp(<span class="number">1</span>)= <span class="number">1</span>;</span><br><span class="line">j_hp(<span class="number">2</span>) = <span class="number">0.5</span>;</span><br><span class="line">j_hp(<span class="number">3</span>) = <span class="number">-0.3</span>;</span><br><span class="line">j_hp(<span class="number">4</span>) = <span class="number">0.3</span>;</span><br><span class="line">j_hp(<span class="number">5</span>) = <span class="number">-0.1</span>;</span><br><span class="line">jtf_hp = <span class="built_in">abs</span>(fft(j_hp));</span><br><span class="line">semilogx(jtf_hp(<span class="number">1</span>:N/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">xlabel(<span class="string">&#x27;Freq&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Jitter Amplification Factor&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/13/jitter-amplification/image-20220327010421475.png"
alt="image-20220327010421475" /></p>
<h3 id="inverter-chain">inverter chain</h3>
<p><img
src="/2022/03/13/jitter-amplification/image-20220608232251056.png"
alt="image-20220608232251056" /></p>
<p><img
src="/2022/03/13/jitter-amplification/image-20220608232658054.png"
alt="image-20220608232658054" /></p>
<p><img
src="/2022/03/13/jitter-amplification/image-20220608232438188.png"
alt="image-20220608232438188" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ji = <span class="number">1e-12</span>; <span class="comment">% 1ps</span></span><br><span class="line">data = importdata(<span class="string">&#x27;/path/to/jir.csv&#x27;</span>);</span><br><span class="line">jo = data.data(:, <span class="number">2</span>);</span><br><span class="line">Ts = <span class="number">31.25e-12</span>;</span><br><span class="line">Fs = <span class="number">1</span>/Ts;</span><br><span class="line">jir = jo/ji;</span><br><span class="line">N = <span class="number">2</span>^(<span class="built_in">nextpow2</span>(<span class="built_in">length</span>(jir)<span class="number">-1</span>));</span><br><span class="line">Y = fft(jir, N);</span><br><span class="line">jtf = <span class="built_in">abs</span>(Y(<span class="number">1</span>:N/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">freqs= Fs/N*(<span class="number">0</span>:N/<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(feqs/<span class="number">1e9</span>, jtf, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Freq (GHz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;JTF&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;JTF of inverter chain&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/03/13/jitter-amplification/image-20220608233303576.png"
alt="image-20220608233303576" /></p>
<h2 id="reference">Reference</h2>
<p><a
href="https://people.engr.tamu.edu/spalermo/ecen689/lecture13_ee720_fwd_clk_deskew.pdf">Sam
Palermo, ECEN 720, Lecture 13 - Forwarded Clock Deskew Circuits</a></p>
<p>B. Casper and F. O'Mahony, "Clocking Analysis, Implementation and
Measurement Techniques for High-Speed Data Links—A Tutorial," in IEEE
Transactions on Circuits and Systems I: Regular Papers, vol. 56, no. 1,
pp. 17-39, Jan. 2009, doi: 10.1109/TCSI.2008.931647.</p>
<p>Phase-Locked Frequency Generation and Clocking : Architectures and
Circuits for Modern Wireless and Wireline Systems by Woogeun Rhee (2020,
Hardcover)</p>
<p>Mathuranathan Viswanathan, Digital Modulations using Matlab : Build
Simulation Models from Scratch</p>
<p>Tony Chan Carusone, University of Toronto, Canada, 2022 CICC
Educational Sessions "Architectural Considerations in 100+ Gbps Wireline
Transceivers"</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Jitter Decomposition in High-Speed Links</title>
    <url>/2022/05/21/jitter-decomposition/</url>
    <content><![CDATA[<p>Jitter separation lets you learn if the components of jitter are
random or deterministic. That is, if they are caused by crosstalk,
channel loss, or some other phenomenon. The identification of jitter and
noise sources is critical when debugging failure sources in the
transmission of high-speed serial signals</p>
<ul>
<li>Tail Fit Method</li>
<li>Spectral method</li>
</ul>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>RJ Extraction Methods</th>
<th>Rationale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Spectral</td>
<td>Speed/Consistency to Past Measurements;<br />Accuracy in low
Crosstalk or Aperiodic Bounded Uncorrelated Jitter (ABUJ)
conditions</td>
</tr>
<tr class="even">
<td>Tail Fit</td>
<td>General Purpose;<br />Accuracy in high Crosstalk or ABUJ
conditions</td>
</tr>
</tbody>
</table>
<h2 id="jitter-components">Jitter Components</h2>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220521190326201.png"
alt="image-20220521190326201" /></p>
<h2 id="dual-dirac-model">dual-Dirac model</h2>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220521181604467.png"
alt="image-20220521181604467" /></p>
<p><img src="/2022/05/21/jitter-decomposition/Figure-1.webp"
alt="Figure-1" /></p>
<h2 id="spectral-method">Spectral method</h2>
<blockquote>
<p>power spectral density (PSD) represents jitter spectrum and peaks in
the spectrum can be interpreted as PJ or DDJ, while the average noise
floor is the power of RJ</p>
</blockquote>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220521182929127.png"
alt="image-20220521182929127" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">S1 = sum(win);</span><br><span class="line">S2 = sum(win.^<span class="number">2</span>);</span><br><span class="line">N = <span class="built_in">length</span>(win);</span><br><span class="line">spec_nospur2 = (spec_nospur*S1).^<span class="number">2</span>/N/S2;    <span class="comment">% To obtain linear spectrum for rj</span></span><br><span class="line">rj_utj = <span class="built_in">sqrt</span>(sum(spec_nospur2))*<span class="number">1e12</span>;</span><br><span class="line"></span><br><span class="line">spec = <span class="number">1</span>*<span class="built_in">ones</span>(<span class="built_in">length</span>(spec_nospur), <span class="number">1</span>)*<span class="number">1e-21</span>;</span><br><span class="line">spec(index) = specx(index);</span><br><span class="line"><span class="comment">% insert fft nyquist frequency component between positive frequency and</span></span><br><span class="line"><span class="comment">% negative frequency component</span></span><br><span class="line"><span class="comment">% DC;posFreq;nyqFreq;negFreq</span></span><br><span class="line">spec_ifft = [spec;specnyq;<span class="built_in">conj</span>(spec(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">2</span>))]&#x27;;</span><br><span class="line">sfactor = sum(win)/<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line">spec_ifft = spec_ifft*sfactor;</span><br><span class="line">sig_rec = <span class="built_in">real</span>(ifft(spec_ifft));</span><br><span class="line">sig_rec = sig_rec(:);</span><br><span class="line">sig_rec_utj = sig_rec./win(<span class="number">1</span>:<span class="keyword">end</span>);</span><br></pre></td></tr></table></figure>
<h2 id="tail-fit-method">Tail Fit Method</h2>
<blockquote>
<p>Tail fitting algorithm based on the <strong>Gaussian tail
model</strong> by using probability distribution of collected jitter
value</p>
</blockquote>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220521191029433.png"
alt="image-20220521191029433" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">bin_sig = bin_sig*<span class="number">1e12</span>;</span><br><span class="line"></span><br><span class="line">x = qfuncinv(cdf_sig);</span><br><span class="line"></span><br><span class="line"><span class="comment">% coef(1)*bin_sig + coef(2) = x</span></span><br><span class="line"><span class="comment">% which x is norm(0, 1)</span></span><br><span class="line"><span class="comment">% bin_sig = (x - coef(2))/coef(1)</span></span><br><span class="line"><span class="comment">% Then bin is norm(-coef(2)/coef(1), 1/coef(1))</span></span><br><span class="line">coef = polyfit(bin_sig, x, <span class="number">1</span>);</span><br><span class="line">sigma = <span class="number">1</span>/coef(<span class="number">1</span>);</span><br><span class="line">mu = -coef(<span class="number">2</span>)*sigma;</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;sigma=%.3fps, mu=%.3fps\n&#x27;</span>, sigma, mu);</span><br></pre></td></tr></table></figure>
<h2 id="least-squares-ls-method">Least Squares (LS) method</h2>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220524005848719.png"
alt="image-20220524005848719" /></p>
<p>It is known that TIE jitter is a linear equation, shown in below
formula <span class="math display">\[
x[n] = d_n \times \left[ \Delta t_{pj}[n]+\Delta t_{DCD}[n] +\Delta
t_{ISI}[n]+\Delta t_{RJ}[n]\right]
\]</span> LS can be used to estimate the PJ, DCD, RJ , and ISI
parameters <span class="math inline">\([a,b,J_{DCD},J_0,
J_1...J_{(2^k-1)}]\)</span></p>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220524185332637.png"
alt="image-20220524185332637" /></p>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220524185351383.png"
alt="image-20220524185351383" /></p>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220524010446422.png"
alt="image-20220524010446422" /></p>
<h2 id="jitter-modeling">Jitter modeling</h2>
<h3 id="periodic-jitter-pj">Periodic Jitter (PJ)</h3>
<p>PJ is a repeating jitter <span class="math display">\[
\Delta t_{PJ}[n]=A\sin(2\pi f_0\cdot nT_s + \theta)=a \sin(2\pi f_0
\cdot nT_s)+b\cos(2\pi f_0 \cdot nT_s)
\]</span> where <span class="math inline">\(f_0\)</span> represents the
fundamental frequency of PJ; <span class="math inline">\(A\)</span> is
the amplitude of PJ; <span class="math inline">\(T_s\)</span> is the
data stream period, and <span class="math inline">\(\theta\)</span> is
the initial phase of PJ</p>
<blockquote>
<p>In the spectrum, the frequency of maximum amount of the jitter is PJ
frequency <span class="math inline">\(f_0\)</span>.</p>
</blockquote>
<h3 id="duty-cycle-distortion-dcd">Duty Cycle Distortion (DCD)</h3>
<p>DCD is viewed as a series of <strong>adjacent positive and negative
impulses</strong> <span class="math display">\[
\Delta t_{DCD}[n] = J_{DCD}\times (-1)^n =
[-J_{DCD},J_{DCD},-J_{DCD},J_{DCD},...]
\]</span> Where <span class="math inline">\(J_{DCD}\)</span> is the DCD
amplitude.</p>
<h3 id="random-jitter-rj">Random Jitter (RJ)</h3>
<p>RJ is created by unbounded jitter sources, such as Gaussian white
noise. The statistical PDF for RJ is enerally treated as a Gaussian
distribution <span class="math display">\[
f_{RJ}(\Delta t) = \frac{1}{\sqrt{2\pi\sigma}}\exp(-\frac{(\Delta
t)^2}{2\sigma^2})
\]</span></p>
<h2 id="remarks">Remarks</h2>
<h3 id="periodic-jitter-generator-and-insertion">Periodic Jitter
Generator and Insertion</h3>
<p><em>Analysis and Estimation of Jitter Sub-Components: Classification
and Segregation of Jitter Components</em></p>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220521212129098.png"
alt="image-20220521212129098" /></p>
<p><img
src="/2022/05/21/jitter-decomposition/image-20220521212142719.png"
alt="image-20220521212142719" /></p>
<h2 id="reference">Reference</h2>
<p>Mike Li. 2007. Jitter, noise, and signal integrity at high-speed
(First. ed.). Prentice Hall Press, USA.</p>
<p><a href="https://keysightevent.com/191023/handout/d">余宥浚 Jacky Yu,
Keysight Taiwan AEO, Advanced Jitter and Eye-Diagram Analysis</a></p>
<p>Y. Duan and D. Chen, "Accurate jitter decomposition in high-speed
links," 2017 IEEE 35th VLSI Test Symposium (VTS), 2017, pp. 1-6, doi:
10.1109/VTS.2017.7928918.</p>
<p>Y. Duan's phd thesis URL: <a
href="https://dr.lib.iastate.edu/handle/20.500.12876/30459">https://dr.lib.iastate.edu/handle/20.500.12876/30459</a></p>
<p>Y. Duan and D. Chen, "Fast and Accurate Decomposition of
Deterministic Jitter Components in High-Speed Links," in IEEE
Transactions on Electromagnetic Compatibility, vol. 61, no. 1, pp.
217-225, Feb. 2019, doi: 10.1109/TEMC.2018.2797122.</p>
<p>"Jitter Analysis: The Dual-Dirac Model, RJ/DJ, and Q-Scale",
Whitepaper: Keysight Technologies, U.S.A., Dec. 2017</p>
<p>Sharma, Vijender Kumar and Sujay Deb. "Analysis and Estimation of
Jitter Sub-Components." (2014).</p>
<p>Qingqi Dou and J. A. Abraham, "Jitter decomposition in ring
oscillators," Asia and South Pacific Conference on Design Automation,
2006., 2006, pp. 6 pp.-, doi: 10.1109/ASPDAC.2006.1594696.</p>
<p>E. Balestrieri, L. De Vito, F. Lamonaca, F. Picariello, S. Rapuano
and I. Tudosa, "The jitter measurement ways: The jitter decomposition,"
in IEEE Instrumentation &amp; Measurement Magazine, vol. 23, no. 7, pp.
3-12, Oct. 2020, doi: 10.1109/MIM.2020.9234759.</p>
<p>McClure, Mark Scott. "Digital jitter measurement and separation." PhD
diss., 2005.</p>
<p>Ren, Nan, Zaiming Fu, Shengcu Lei, Hanglin Liu, and Shulin Tian.
"Jitter generation model based on timing modulation and cross point
calibration for jitter decomposition." Metrology and Measurement Systems
28, no. 1 (2021).</p>
<p>M. P. Li, J. Wilstrup, R. Jessen and D. Petrich, "A new method for
jitter decomposition through its distribution tail fitting,"
International Test Conference 1999. Proceedings (IEEE Cat.
No.99CH37034), 1999, pp. 788-794, doi: 10.1109/TEST.1999.805809.</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>JTAG and Boundary Scan</title>
    <url>/2023/11/28/jtag/</url>
    <content><![CDATA[<p>Data Register, DR:</p>
<ul>
<li>Bypass Register, BR</li>
<li>Boundary Scan Register, BSR</li>
</ul>
<p>Instruction Register, IR</p>
<h2 id="tap-controller">TAP Controller</h2>
<p><img src="/2023/11/28/jtag/image-20240113191225838.png"
alt="image-20240113191225838" /></p>
<blockquote>
<ul>
<li>FSM and Shift Register of DR and IR works at the
<strong>posedge</strong> of the clock</li>
<li>TMS, TDI, TDO and Hold Register of DR and IR changes value at the
<strong>negedge</strong> of the clock</li>
</ul>
</blockquote>
<p><img src="/2023/11/28/jtag/image-20240113191409296.png"
alt="image-20240113191409296" /></p>
<p><img src="/2023/11/28/jtag/image-20240113191526490.png"
alt="image-20240113191526490" /></p>
<blockquote>
<p>capture IR <code>01</code>, the fixed is for easier fault
detection</p>
</blockquote>
<p><img src="/2023/11/28/jtag/image-20231129232443249.png"
alt="image-20231129232443249" /></p>
<p><img src="/2023/11/28/jtag/image-20231129233218011.png"
alt="image-20231129233218011" /></p>
<blockquote>
<p>After power-up, they may not be in sync, but there is a trick. Look
at the state machine and notice that no matter what state you are, if
<em>TMS stays at "1" for five clocks</em>, a TAP controller goes back to
the state "Test-Logic Reset". That's used to synchronize the TAP
controllers.</p>
</blockquote>
<blockquote>
<p>It is important to note that in a typical Boundary-Scan test, the
time between launching a signal from driver (at the falling edge of test
clock (TCK) in the <code>Update-DR</code> or <code>Update-IR</code> TAP
Controller state) and capturing that signal (at the rising edge of TCK
in the <code>Caputre-DR</code> TAP Controller state) is <strong>no less
tha 2.5 TCK cycles</strong></p>
</blockquote>
<p>Further, the time between successive launches on a driver is governed
- not only by the TCk rate - but by the amount of serial data shifting
needed to load the next pattern data in the concatenated Boundary-Scan
Registers of the Boundary-Scan chain</p>
<blockquote>
<p>Thus the effective test data rate of a driver could be thousands of
the times lower than the TCK rate</p>
<ol type="1">
<li>For DC-coupled interconnect, this time is of no concern</li>
<li>For AC-coupled interconnect, the signal may easily decay partially
or completely before it can be captured</li>
<li>If only partial decay occurs before capture, that decay will very
likely be completed before the driver produces the next edge</li>
</ol>
</blockquote>
<h2 id="ac-coupling">AC-coupling</h2>
<p>In general, AC-coupling can distort a signal transmitted across a
channel depending on its frequency.</p>
<p><code>Figure 5</code></p>
<ul>
<li>The high frequency signal is relatively unaffected by the
coupling</li>
<li>The low frequency signal is severely impacted
<ol type="1">
<li>it decays to <span class="math inline">\(V_T\)</span> after a few
time constants</li>
<li>its amplitude is double the input amplitude &gt; transient response,
before AC-coupling capacitor: <span class="math inline">\(-A_p \to
A_p\)</span>; after AC-coupling capacitor <span
class="math inline">\(V_T \to V_T+2A_p\)</span> &gt; A key item to note
is that the transitions in the original signal are preserved, although
their start and end points are offset &gt; &gt; compared to where they
were in the high frequency</li>
</ol></li>
</ul>
<h2 id="test-signal-implementation">Test signal implementation</h2>
<p>The test data is either the content of the Boundary-Scan Register
Update latch (U) when executing the (DC) EXTEST instruction, or an
<strong>"AC Signal"</strong> when an <em>AC testing instruction</em> is
loaded into the device.</p>
<blockquote>
<p>The AC signal is a test waveform suited for transmission through
AC-coupling</p>
</blockquote>
<p><img src="/2023/11/28/jtag/image-20240113184502597.png"
alt="image-20240113184502597" /></p>
<h2 id="test-signal-reception">Test signal reception</h2>
<ul>
<li>When <em>an AC testing instruction</em> is loaded, a specialized
test receiver detects transitoins of the AC signal seen at the input and
determines if this represents a logic '0' or '1'</li>
<li>When <em>EXTEST</em> is loaded, the input signal level is detected
and sent to the output of the test receiver to the Boundary-Scan
Register cell</li>
</ul>
<p>When testing for a shorted capacitor, the <em>test software</em> must
ensure that enough time has passed for the signal to decay before
entering <em>Capture-DR</em>, either by stopping TCk or by spending
additional TCK cycles in the <em>Run-Test/Idle</em> TAP Controller
state</p>
<h2 id="extest_pulse-extest_train">EXTEST_PULSE &amp; EXTEST_TRAIN</h2>
<blockquote>
<p>The two new AC-test instructions provided by this standard differ
primarily in the number and timing of transitions to provide flexibility
in dealing with the specific dynamic behavior of the channels being
tested</p>
</blockquote>
<p><strong>AC Test Signal</strong> essentially modulates test data so
that it will propagate through AC-coupled channels, for devices that
contatin AC pins</p>
<blockquote>
<p>Tools should use the <strong>EXTEST_PULSE</strong> instruction unless
there is a specific requirement for the <strong>EXTEST_TRAIN</strong>
instruction</p>
</blockquote>
<h3 id="extest_pulse">EXTEST_PULSE</h3>
<blockquote>
<p>Generate <strong>two</strong> additional driver transitions and
allows a tester to vary the <strong>time</strong> between them dependent
on how many TCK cycles the TAP is left in the <em>Run-Test/Idle</em> TAP
Controller state.</p>
<p>This is intended to allow any undesired transient condition to decay
to a <strong>DC steady-state value</strong> when that will make the
final transition more reliably detectable</p>
<p>The duration in the <em>Run-Test/Idle</em> TAP Controller state
should be <strong>at least three times</strong> the high-pass coupling
time constant. This allows the <em>first additional transition</em> to
decay away to the <strong>DC steady-state value</strong> for the
channel, and ensures that the full amplitude of the <em>final
transition</em> is added to or subtracted from that steady-state
value</p>
<p>This establishes a <em>known initial condition</em> for the <em>final
transition</em> and permits reliable specification of the detection
threshold of the test receiver</p>
</blockquote>
<p><img src="/2023/11/28/jtag/image-20240113190314947.png"
alt="image-20240113190314947" /></p>
<h3 id="extest_train">EXTEST_TRAIN</h3>
<blockquote>
<p>Generate <strong>multiple</strong> additional transitions, the
<strong>number</strong> dependent on how long the TAP is left in the
<em>Run-Test/Idle</em> TAP Controller state</p>
<p>This is intended to allow any undesired transient condition to decay
to an <strong>AC steady-state value</strong> when that will make the
final transition more reliably detectable</p>
</blockquote>
<p><img src="/2023/11/28/jtag/image-20240113190345323.png"
alt="image-20240113190345323" /></p>
<h2 id="ieee-std-1149.6-2003">IEEE Std 1149.6-2003</h2>
<p>This standard is built on top of IEEE Std 1149.1 using the same Test
Access Port structure and Boundary-Scan architecture.</p>
<ul>
<li>It adds the concept of a "test receiver" to input pins that are
expected to handle <strong>differential and/or AC-coupling</strong></li>
<li>It adds two new instructions that cause drivers to emit AC waveforms
that are processed by test receivers.</li>
</ul>
<h2 id="jtag-instruction">JTAG Instruction</h2>
<h2 id="implementation">Implementation</h2>
<ul>
<li>AC mode hysteresis, detect transistion</li>
<li>DC mode threshold is determined by jtag initial value</li>
</ul>
<h2 id="reference">reference</h2>
<p>IEEE Std 1149.1-2001, IEEE Standard Test Access Port and
Boundary-Scan Architecture, IEEE, 2001</p>
<p>IEEE Std 1149.6-2003, IEEE Standard for BoundaryScan Testing of
Advanced Digital Networks, IEEE, 2003</p>
<p>IEEE 1149.6 Tutorial | Testing AC-coupled and Differential High-speed
Nets [<a
href="https://www.asset-intertech.com/resources/eresources/ieee-11496-tutorial-testing-ac-coupled-and-differential-high-speed-nets/">https://www.asset-intertech.com/resources/eresources/ieee-11496-tutorial-testing-ac-coupled-and-differential-high-speed-nets/</a>]</p>
<p>Prof. James Chien-Mo Li, Lab of Dependable Systems, National Taiwan
University. VLSI Testing [<a
href="http://cc.ee.ntu.edu.tw/~cmli/VLSItesting/">http://cc.ee.ntu.edu.tw/~cmli/VLSItesting/</a>]</p>
<p>K.P. Parker, The Boundary Scan Handbook, 3rd ed., Kluwer Academic,
2003.</p>
<p>B. Eklow, K. P. Parker and C. F. Barnhart, "IEEE 1149.6: a
boundary-scan standard for advanced digital networks," in IEEE Design
&amp; Test of Computers, vol. 20, no. 5, pp. 76-83, Sept.-Oct. 2003,
doi: 10.1109/MDT.2003.1232259.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Latch Inference in Verilog</title>
    <url>/2022/05/09/latch-inference/</url>
    <content><![CDATA[<h2 id="always"><code>always@( * )</code></h2>
<p><code>always@( * )</code> blocks are used to describe Combinational
Logic, or Logic Gates. Only <code>=</code> (blocking) assignments should
be used in an <code>always@( * )</code> block.</p>
<h2 id="latch-inference">Latch Inference</h2>
<p>If you <strong>DON'T</strong> assign every element that can be
assigned inside an <code>always@( * )</code> block every time that
<code>always@( * )</code> block is executed, a latch will be inferred
for that element</p>
<p>The approaches to avoid latch generation:</p>
<ul>
<li>set default values</li>
<li>proper use of the <code>else</code> statement, and other flow
constructs</li>
</ul>
<h3 id="without-default-values">without default values</h3>
<blockquote>
<p>latch is generated</p>
</blockquote>
<h4 id="rtl">RTL</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP (</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> Trigger,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> Pass,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> A,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> C</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">		A = <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">if</span> (Trigger) <span class="keyword">begin</span></span><br><span class="line">			A = Pass;</span><br><span class="line">			C = Pass;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="synthesized-netlist">synthesized netlist</h4>
<p><img src="/2022/05/09/latch-inference/image-20220509170640006.png"
alt="image-20220509170640006" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Created by: Synopsys DC Ultra(TM) in wire load mode</span></span><br><span class="line"><span class="comment">// Version   : S-2021.06-SP5</span></span><br><span class="line"><span class="comment">// Date      : Mon May  9 17:09:18 2022</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TOP ( Trigger, Pass, A, C );</span><br><span class="line">  <span class="keyword">input</span> Trigger, Pass;</span><br><span class="line">  <span class="keyword">output</span> A, C;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  lanhq1 C_reg ( <span class="variable">.E</span>(Trigger), <span class="variable">.D</span>(Pass), <span class="variable">.Q</span>(C) );</span><br><span class="line">  an02d0 U3 ( <span class="variable">.A1</span>(Pass), <span class="variable">.A2</span>(Trigger), <span class="variable">.Z</span>(A) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="add-default-value">add default value</h3>
<blockquote>
<p>Default values are an easy way to avoid latch generation</p>
</blockquote>
<h4 id="rtl-1">RTL</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP (</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> Trigger,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> Pass,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> A,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> C</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">		A = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        	C = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">if</span> (Trigger) <span class="keyword">begin</span></span><br><span class="line">			A = Pass;</span><br><span class="line">			C = Pass;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="synthesized-netlist-1">synthesized netlist</h4>
<p><img src="/2022/05/09/latch-inference/image-20220509171319204.png"
alt="image-20220509171319204" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Created by: Synopsys DC Ultra(TM) in wire load mode</span></span><br><span class="line"><span class="comment">// Version   : S-2021.06-SP5</span></span><br><span class="line"><span class="comment">// Date      : Mon May  9 17:12:47 2022</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TOP ( Trigger, Pass, A, C );</span><br><span class="line">  <span class="keyword">input</span> Trigger, Pass;</span><br><span class="line">  <span class="keyword">output</span> A, C;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  nd12d0 U5 ( <span class="variable">.A1</span>(Pass), <span class="variable">.A2</span>(Trigger), <span class="variable">.ZN</span>(C) );</span><br><span class="line">  an02d0 U6 ( <span class="variable">.A1</span>(Pass), <span class="variable">.A2</span>(Trigger), <span class="variable">.Z</span>(A) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="if-evaluation"><code>if</code> evaluation</h2>
<p><code>signed</code> number cast to <code>unsigned</code>
automatically before evaluating</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tb.v</span></span><br><span class="line"><span class="keyword">module</span> tb; </span><br><span class="line">  <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">1</span>:<span class="number">0</span>] datasg;</span><br><span class="line">  <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] dataug;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    datasg = <span class="number">2&#x27;b11</span>;</span><br><span class="line">    dataug = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;datasg(%%d): %d&quot;</span>, datasg);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;dataug(%%d): %d&quot;</span>, dataug);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (datasg)</span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;datasg is OK&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dataug)</span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;dataug is OK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$finish</span>();</span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vlog tb.v</span><br><span class="line">$ vsim -c -do &quot;run;exit&quot; work.tb</span><br><span class="line"># Loading work.tb(fast)</span><br><span class="line"># run</span><br><span class="line"># datasg(%d): -1</span><br><span class="line"># dataug(%d): 3</span><br><span class="line"># datasg is OK</span><br><span class="line"># dataug is OK</span><br><span class="line"># ** Note: $finish    : tb.v(16)</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>UC Berkeley CS150 Lec #20: Finite State Machines <a
href="https://inst.eecs.berkeley.edu/~cs150/sp11/agenda/lec/lec20-fsm.pdf">Slides</a></p>
<p>Lee WF. Learning from VLSI Design Experience [electronic Resource] /
by Weng Fook Lee. 1st ed. 2019. Springer International Publishing; 2019.
doi:10.1007/978-3-030-03238-8</p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Layout Tricks Part 1 - compact, drain and source sharing</title>
    <url>/2022/02/19/layout-tricks-part1/</url>
    <content><![CDATA[<p>All credits to my colleague, Zhang Wenpian.</p>
<h3 id="planar-process-vs.-finfet-process">Planar process vs. FinFet
process</h3>
<p><img
src="/2022/02/19/layout-tricks-part1/local_Interconnect.drawio.svg"
alt="local_Interconnect.drawio" /></p>
<h3 id="standard-cell-tapcell">Standard Cell Tapcell</h3>
<p><img src="/2022/02/19/layout-tricks-part1/tapcell.drawio.svg"
alt="tapcell.drawio" /></p>
<h3 id="guard-ring-in-custom-block">Guard Ring in Custom block</h3>
<p>Place well tie and substrate tie where they are needed. Redundant
guard ring consume area and increase the routing of critical signal
net.</p>
<p><img
src="/2022/02/19/layout-tricks-part1/guardring_stypes.drawio.svg"
alt="guardring_stypes.drawio" /></p>
<h3 id="continuous-od">Continuous OD</h3>
<h4 id="performance-matching">Performance &amp; Matching</h4>
<p><img
src="/2022/02/19/layout-tricks-part1/image-20220219223723289.png"
alt="image-20220219223723289" /></p>
<h4 id="current-mirror">current mirror</h4>
<p>split diffusion with dummy transistors</p>
<p><img
src="/2022/02/19/layout-tricks-part1/mirror_continuous_OD_split_with_dummy.drawio.svg"
alt="mirror_continuous_OD_split_with_dummy.drawio" /></p>
<h4 id="cascode-structure">cascode structure</h4>
<p>off transistor split diffusion</p>
<p><img
src="/2022/02/19/layout-tricks-part1/cascode_continuous_OD_split_with_dummy.drawio.svg"
alt="cascode_continuous_OD_split_with_dummy.drawio" /></p>
<h4 id="sharing-source-drain">sharing source &amp; drain</h4>
<p><img src="/2022/02/19/layout-tricks-part1/sharing_SD.drawio.svg"
alt="sharing_SD.drawio" /></p>
<h3 id="stacked-mosfets">Stacked MOSFETs</h3>
<h3 id="reference">reference</h3>
<p>A. L. S. Loke et al., "Analog/mixed-signal design challenges in 7-nm
CMOS and beyond," 2018 IEEE Custom Integrated Circuits Conference
(CICC), 2018, pp. 1-8, doi: 10.1109/CICC.2018.8357060.</p>
<p>Stacked MOSFETs in analog layout <a
href="https://pulsic.com/stacked-mosfets-in-analog-layout/">https://pulsic.com/stacked-mosfets-in-analog-layout/</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Layout Tricks Part 2 - matching</title>
    <url>/2022/11/19/layout-tricks-part2/</url>
    <content><![CDATA[<ol type="1">
<li><p>Common Centroid</p>
<p>The common centroid technique describes that if there are n blocks
which are to be matched then the blocks are arranged symmetrically
around the common centre at equal distances from the centre. This
technique offers best matching for devices as it helps in avoiding
cross-chip gradients</p>
<p><img src="/2022/11/19/layout-tricks-part2/figure13.jpeg"
alt="HTML5 Icon" /></p></li>
<li><p>Inter-digitation</p>
<p>Interdigitation reduces the device mismatch as it suffers equally
from process variations in X dimension. This technique was used to
layout current mirrors and resistors in PTAT and BGR circuits. In the
Figure-15 below each brown stick represents a PFET of uniform length.
This representation is termed as an inter-digitated layout.</p>
<p><img src="/2022/11/19/layout-tricks-part2/figure14.jpeg"
alt="HTML5 Icon" /></p></li>
</ol>
<h3 id="reference">reference</h3>
<p>Mikael Sahrling, Layout Techniques for Integrated Circuit Designers
1st Edition , Artech House 2022</p>
<p>LAYOUT, <a
href="http://www.ee.columbia.edu/~kinget/EE6350_S16/">EE6350 VLSI Design
Lab</a> SMART TEMPERATURE SENSOR URL: <a
href="https://www.ee.columbia.edu/~kinget/EE6350_S16/06_TEMPSENS_Sukanya_Vani/layout.html">https://www.ee.columbia.edu/~kinget/EE6350_S16/06_TEMPSENS_Sukanya_Vani/layout.html</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Low-Dropout Regulator</title>
    <url>/2023/10/21/ldo/</url>
    <content><![CDATA[<p><em>TODO</em> 📅</p>
<h2 id="pmos-ldo">PMOS LDO</h2>
<p>A large output capacitor solves the sudden load change problem, but
the stability decreases because the large output capacitor forces the
output pole toward the origin with the role of dominant pole</p>
<h2 id="damping-factor-zeta-and-phase-margin">damping factor (<span
class="math inline">\(\zeta\)</span>) and phase margin</h2>
<p>phase margin is defined for <em>open loop</em> system</p>
<p>damping factor (<span class="math inline">\(\zeta\)</span>) is
defined for <em>close loop</em> system</p>
<p>the roughly 90 to 100 times of damping factor (<span
class="math inline">\(\zeta\)</span>) is phase margin</p>
<p><span class="math display">\[
\mathrm{PM} = 90\zeta ~ 100\zeta
\]</span></p>
<blockquote>
<p>in order to have a good stable system, we want <span
class="math inline">\(\zeta &gt; 0.5\)</span> or phase margin more than
<span class="math inline">\(45^o\)</span></p>
</blockquote>
<blockquote>
<p>We can analyze open loop system in a better perspective because it is
simpler</p>
</blockquote>
<p>DC output impedance of NMOS and PMOS LDO is the <em>same</em> for the
same error amplifier gain</p>
<p><span class="math display">\[
R_{\text{out}} = \frac{1}{\beta A_{o1} g_{m2}}
\]</span></p>
<p>The NMOS LDO has a faster response to line transients than the PMOS
LDO since it has btter (smaller) PSRR</p>
<p>A good PSRR is important when an LDO is used as a sub-regulator in
cascade with a switching regulator. The LDO would need to have a
sufficiently high rejection at the switching frequency of the switching
converter to filter out the ripples at that frequency</p>
<h2 id="reference">reference</h2>
<p>Hinojo, J.M., Martinez, C.I., &amp; Torralba, A.J. (2018). Internally
Compensated LDO Regulators for Modern System-on-Chip Design.</p>
<p>Mingoo Seok. ISSCC 2020 tutorial "Basics of Digital Low-Dropout (LDO)
Integrated Voltage Regulator"</p>
<p>Pavan Kumar Hanumolu. CICC 2015. "Low Dropout Regulators"</p>
<p>Chen, K. (2016). Power Management Techniques for Integrated Circuit
Design.</p>
<p>Morita, B.G. (2014). Understand Low-Dropout Regulator ( LDO )
Concepts to Achieve Optimal Designs.</p>
<p>H. -S. Kim, "Exploring Ways to Minimize Dropout Voltage for
Energy-Efficient Low-Dropout Regulators: Viable approaches that preserve
performance," in IEEE Solid-State Circuits Magazine, vol. 15, no. 2, pp.
59-68, Spring 2023, doi: 10.1109/MSSC.2023.3262767.</p>
<p>Ali Sheikholeslami, Circuit Intuitions: Voltage Regulators IEEE
Solid-State Circuits Magazine, Vol. 12, Issue 4, to appear, Fall
2020.</p>
<p>Operational Transconductance Amplifier II Multi-Stage Designs [<a
href="https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M07%20OTA%20II.pdf">https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M07%20OTA%20II.pdf</a>]</p>
<p>Toshiba, Load Transient Response of LDO and Methods to Improve it
Application Note [<a
href="https://toshiba.semicon-storage.com/info/application_note_en_20210326_AKX00312.pdf?did=66268">https://toshiba.semicon-storage.com/info/application_note_en_20210326_AKX00312.pdf?did=66268</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Link Modeling &amp; Analysis</title>
    <url>/2024/05/15/linkModeling/</url>
    <content><![CDATA[<ul>
<li><p>statistical eye/BER analysis</p></li>
<li><p>Channel Operation Margin (<strong>COM</strong>)</p></li>
</ul>
<h2 id="statistical-eye">statistical eye</h2>
<p><em>TODO</em> 📅</p>
<h3 id="reference">reference</h3>
<p>Sanders, Anthony, Michael Resso and John D'Ambrosia. "Channel
Compliance Testing Utilizing Novel Statistical Eye Methodology."
(2004).</p>
<h2 id="maximum-likelihood-sequence-estimation">Maximum-Likelihood
Sequence Estimation</h2>
<p><em>TODO</em> 📅</p>
<h3 id="reference-1">reference</h3>
<p>M. Emami Meybodi, H. Gomez, Y. -C. Lu, H. Shakiba and A.
Sheikholeslami, "Design and Implementation of an On-Demand
Maximum-Likelihood Sequence Estimation (MLSE)," in IEEE Open Journal of
Circuits and Systems, vol. 3, pp. 97-108, 2022, doi:
10.1109/OJCAS.2022.3173686.</p>
<p>Zaman, Arshad Kamruz (2019). A Maximum Likelihood Sequence Equalizing
Architecture Using Viterbi Algorithm for ADC-Based Serial Link.
Undergraduate Research Scholars Program. Available electronically from
[<a
href="https://hdl.handle.net/1969.1/166485">https://hdl.handle.net/1969.1/166485</a>]</p>
<h2 id="reference-2">reference</h2>
<p>Paul Muller Yusuf Leblebici École Polytechnique Fédérale de Lausanne
(EPFL). <a
href="https://designers-guide.org/modeling/JTOL_rev1.0.pdf">Pattern
generator model for jitter-tolerance simulation</a>; <a
href="https://designers-guide.org/modeling/fc_jtol_src_ns.vhd">VHDL-AMS
models</a></p>
<p>G. Balamurugan, A. Balankutty and C. -M. Hsu, "56G/112G Link
Foundations Standards, Link Budgets &amp; Models," 2019 IEEE Custom
Integrated Circuits Conference (CICC), Austin, TX, USA, 2019, pp. 1-95,
doi: 10.1109/CICC.2019.8780223.</p>
<p>Savo Bajic, ECE1392, Integrated Circuits for Digital Communications:
<strong>StatOpt in Python</strong> [<a
href="https://savobajic.ca/projects/academic/statopt/">https://savobajic.ca/projects/academic/statopt</a>]</p>
<p>Anritsu Company, "Measuring Channel Operating Margin," 2016. [<a
href="https://dl.cdn-anritsu.com/en-us/test-measurement/files/Technical-Notes/White-Paper/11410-00989A.pdf">https://dl.cdn-anritsu.com/en-us/test-measurement/files/Technical-Notes/White-Paper/11410-00989A.pdf</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Long-Term Jitter</title>
    <url>/2023/09/16/lt-jitter/</url>
    <content><![CDATA[<p><strong>long-term jitter</strong> is sometimes referred to as the
<strong>accumulated jitter</strong></p>
<p><img src="/2023/09/16/lt-jitter/image-20230916235523070.png"
alt="image-20230916235523070" /></p>
<ul>
<li><p>Cycle-Cycle Jitter <span class="math display">\[
\delta(\tau _2 - \tau _1) = \sqrt{2}\times\delta (\tau_1)
\]</span></p></li>
<li><p>Long Term Jitter <span class="math display">\[
\delta(\tau_N) = \sqrt{N}\times\delta (\tau_1)
\]</span></p></li>
</ul>
<h2 id="short-term-jitter">Short Term Jitter</h2>
<p><img src="/2023/09/16/lt-jitter/image-20230916235240675.png"
alt="image-20230916235240675" /></p>
<p><img src="/2023/09/16/lt-jitter/image-20230916235314423.png"
alt="image-20230916235314423" /></p>
<h2 id="long-term-jitter-ltj">Long Term Jitter (LTJ)</h2>
<p><img src="/2023/09/16/lt-jitter/image-20230916235647723.png"
alt="image-20230916235647723" /></p>
<p><img src="/2023/09/16/lt-jitter/image-20230916235709504.png"
alt="image-20230916235709504" /></p>
<h2 id="measuring-long-term-jitter">measuring long-term jitter</h2>
<p><img src="/2023/09/16/lt-jitter/image-20230916235033464.png"
alt="image-20230916235033464" /></p>
<h2 id="jitter-calculation-examples">Jitter Calculation Examples</h2>
<p><img src="/2023/09/16/lt-jitter/image-20230917003028143.png"
alt="image-20230917003028143" /></p>
<h2 id="references">references</h2>
<p>AN10007 Clock Jitter Definitions and Measurement Methods, SiTime [<a
href="https://www.sitime.com/sites/default/files/hiddenresources/AN10007-Jitter-and-measurement-methods_SIT.pdf">pdf</a>]</p>
<p>SERDES Design and Simulation Using the Analog FastSPICE Platform,
Silicon Creations [<a
href="https://www.siliconcr.com/sc-cms/uploads/u2u_presentation_sc_april25.pdf">pdf</a>]</p>
<p>Flexible clocking solutions in advanced processes from 180nm to 5nm,
Silicon Creations [<a
href="https://www.siliconcr.com/sc-cms/uploads/siliconcreations_iccad_2019_v2_191020.pdf">pdf</a>]</p>
<p>One-size-fits-all PLLs for Advanced Samsung Foundry Processes,
Silicon Creations [<a
href="https://www.siliconcr.com/sc-cms/uploads/siliconcreations_dac_2022_v2_22-07-12.pdf">pdf</a>]</p>
<p>Circuit Design and Verification of 7nm LowPower, Low-Jitter PLLs,
Silicon Creations, [<a
href="https://www.siliconcr.com/sc-cms/uploads/u2u-2018-sicr-plls-v3-180509.pdf">pdf</a>]</p>
<p>Lecture 10: Jitter, ECEN720: High-Speed Links Circuits and Systems
Spring 2023 [<a
href="https://people.engr.tamu.edu/spalermo/ecen689/lecture10_ee720_jitter.pdf">pdf</a>]</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Matlab toolbox</title>
    <url>/2023/09/24/mattool/</url>
    <content><![CDATA[<h2 id="impulse2pulse">impulse2pulse</h2>
<blockquote>
<p>serdes/impulse2pulse.m</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span> = <span class="title">impulse2pulse</span><span class="params">(I, N, dt)</span></span></span><br><span class="line"></span><br><span class="line">impulseSize = <span class="built_in">size</span>(I);</span><br><span class="line"></span><br><span class="line"><span class="comment">%Convert to Pulse by shifting and adding</span></span><br><span class="line">P = <span class="built_in">zeros</span>(impulseSize,<span class="string">&#x27;like&#x27;</span>,I);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> indx=<span class="number">1</span>:N</span><br><span class="line">    P = P + <span class="built_in">circshift</span>(I, indx,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">P = P*dt;  <span class="comment">% `dt` is the width of area</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
P_k = \Delta t \times \sum_j I_j
\]</span></p>
<h2 id="impulse2step">impulse2step</h2>
<blockquote>
<p>serdes/impulse2step.m</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span> = <span class="title">impulse2step</span><span class="params">(I,dt)</span></span></span><br><span class="line"></span><br><span class="line">[nr,nn] = <span class="built_in">size</span>(I);</span><br><span class="line"></span><br><span class="line">S = <span class="built_in">zeros</span>(nr,nn,<span class="string">&#x27;like&#x27;</span>,I);</span><br><span class="line"><span class="keyword">for</span> indx=<span class="number">2</span>:nr</span><br><span class="line">    S(indx,:) = S(indx<span class="number">-1</span>,:) + I(indx<span class="number">-1</span>,:)*dt;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
S_k = S_{k-1} + I_{k-1}\times \Delta t
\]</span></p>
<h2 id="step2impulse">step2impulse</h2>
<blockquote>
<p>serdes/step2impulse.m</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">I</span> = <span class="title">step2impulse</span><span class="params">(S,dt)</span></span></span><br><span class="line"></span><br><span class="line">I = diff(S)/dt;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
I_k = \frac{S_{k+1}- S_{k}}{\Delta t}
\]</span></p>
<h2 id="pulse2impulse">pulse2impulse</h2>
<blockquote>
<p>serdes/pulse2impulse.m</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">I</span> = <span class="title">pulse2impulse</span><span class="params">(P, N, dt )</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   The algorithm computes the step response from the pulse response and</span></span><br><span class="line"><span class="comment">%   then take the derivative to get the impulse response. The derivative</span></span><br><span class="line"><span class="comment">%   calculation has zero delay and is reasonably accurate up to one half</span></span><br><span class="line"><span class="comment">%   the Nyquist rate but then diverges rapidly back to zero at the Nyquist</span></span><br><span class="line"><span class="comment">%   rate.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Size input waveform</span></span><br><span class="line">[nr,nc] = <span class="built_in">size</span>(P);</span><br><span class="line"></span><br><span class="line"><span class="comment">%Remove DC component of waveform</span></span><br><span class="line">dcValues = P(<span class="number">1</span>,:);</span><br><span class="line">P = P - <span class="built_in">repmat</span>(dcValues,nr,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Convert to step response. No circshift here</span></span><br><span class="line">step = <span class="built_in">zeros</span>( nr, nc,<span class="string">&#x27;like&#x27;</span>,P );</span><br><span class="line"><span class="keyword">for</span> jj = <span class="number">1</span>:nc</span><br><span class="line">    <span class="keyword">for</span> indx = <span class="number">1</span>:N:nr</span><br><span class="line">        step(indx:nr,jj) = step(indx:nr,jj) + P(<span class="number">1</span>:nr-indx+<span class="number">1</span>,jj);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Take the derivative</span></span><br><span class="line">a1 = <span class="number">0.59</span>;</span><br><span class="line">a3 = <span class="number">-0.03</span>;</span><br><span class="line">stepExt = <span class="built_in">zeros</span>( nr+<span class="number">6</span>, nc, <span class="string">&#x27;like&#x27;</span>,P );</span><br><span class="line">I = coder.nullcopy(P);</span><br><span class="line"><span class="keyword">for</span> jj = <span class="number">1</span>:nc    </span><br><span class="line">    stepExt(<span class="number">1</span>:<span class="number">3</span>,jj) = step(<span class="number">1</span>,jj);</span><br><span class="line">    stepExt(<span class="number">4</span>:nr+<span class="number">3</span>,jj) = step(:,jj);</span><br><span class="line">    stepExt(nr+<span class="number">4</span>:nr+<span class="number">6</span>,jj) = step(nr,jj);</span><br><span class="line">    I(:,jj) = (a1*(stepExt(<span class="number">5</span>:nr+<span class="number">4</span>,jj) - stepExt(<span class="number">3</span>:nr+<span class="number">2</span>,jj)) + ...</span><br><span class="line">        a3*(stepExt(<span class="number">7</span>:nr+<span class="number">6</span>,jj) - stepExt(<span class="number">1</span>:nr,jj))) / dt;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pulse2wave">pulse2wave</h2>
<blockquote>
<p>serdes/pulse2wave.m</p>
<p>% The algorithms utilizes circular convolution to project the
pulse</p>
<p>% response onto the data pattern.</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">load(<span class="string">&#x27;PulseResponseReflective100ps.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line">P1 = pulse(:,<span class="number">1</span>) - pulse(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">P1 = P1(<span class="number">1</span>:<span class="number">2000</span>);</span><br><span class="line"><span class="comment">% P1 = P1 + 0.2;  % dc offset</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;pulse&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>(P1)</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">order = <span class="number">10</span>;</span><br><span class="line">data =<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">512</span>);</span><br><span class="line">data(<span class="number">1</span>, <span class="number">8</span>) = <span class="number">1</span>;</span><br><span class="line">data(<span class="number">1</span>, <span class="number">256</span>) = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;input sequence&#x27;</span>);</span><br><span class="line">stem(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">W1 = pulse2wave(P1,data,SamplesPerSymbol); </span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;waveform&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1)</span><br><span class="line">grid on;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/24/mattool/image-20230924130954034.png"
alt="image-20230924130954034" /></p>
<h2 id="pulse2pda">pulse2pda</h2>
<blockquote>
<p>B. K. Casper, M. Haycock and R. Mooney, "An accurate and efficient
analysis method for multi-Gb/s chip-to-chip signaling schemes," 2002
Symposium on VLSI Circuits. Digest of Technical Papers (Cat.
No.02CH37302), Honolulu, HI, USA, 2002, pp. 54-57, doi:
10.1109/VLSIC.2002.1015043.</p>
<p>Chang, Wei-Ju and Ruey-Beei Wu. “Eye diagram estimation and equalizer
design method for PAM4.” <em>2018 IEEE 22nd Workshop on Signal and Power
Integrity (SPI)</em> (2018): 1-4.</p>
</blockquote>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Mixing Signed and Unsigned in Verilog</title>
    <url>/2022/05/07/mixed-sign-verilog/</url>
    <content><![CDATA[<p>Sign Extension</p>
<ol type="1">
<li>Calculate the necessary minimum width of the sum so that it contains
all input possibilities</li>
<li>Extend the inputs' sign bits to the width of the answer</li>
<li>Add as usual</li>
<li>Ignore bits that ripple to the left of the answer's MSB</li>
</ol>
<ol type="1">
<li><strong>signed</strong></li>
</ol>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>inA (signed)</th>
<th>inB (signed)</th>
<th>outSum<br />(signed/unsigned)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>0101 (5)</td>
<td>1111 (-1)</td>
<td></td>
</tr>
<tr class="even">
<td><em>extend sign</em></td>
<td><strong>0</strong>0101</td>
<td><strong>1</strong>1111</td>
<td></td>
</tr>
<tr class="odd">
<td><em>sum result</em></td>
<td></td>
<td></td>
<td>00100</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inA;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inB;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">4</span>:<span class="number">0</span>] outSumSg;	<span class="comment">// signed result</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] outSumUs;			<span class="comment">// unsigned result</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		inA = <span class="number">4&#x27;b0101</span>;</span><br><span class="line">		inB = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">		outSumUs = inA + inB;</span><br><span class="line">		outSumSg = inA + inB;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%d): %0d&quot;</span>, outSumSg);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%b): %b&quot;</span>, outSumSg);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%d): %0d&quot;</span>, outSumUs);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%b): %b&quot;</span>, outSumUs);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>mixed</strong></li>
</ol>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>inA (signed)</th>
<th>inB (unsigned)</th>
<th>outSum<br />(signed/unsigned)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>0101 (5)</td>
<td>1111 (15)</td>
<td></td>
</tr>
<tr class="even">
<td><em>extend sign</em></td>
<td><strong>0</strong>0101</td>
<td><strong>0</strong>1111</td>
<td></td>
</tr>
<tr class="odd">
<td><em>sum result</em></td>
<td></td>
<td></td>
<td>10100</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inA;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] inB;</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 20%" />
<col style="width: 17%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>inA (unsigned)</th>
<th>inB (signed)</th>
<th>outSum<br />(signed/unsigned)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>0101 (5)</td>
<td>1111 (-1)</td>
<td></td>
</tr>
<tr class="even">
<td><em>extend sign</em></td>
<td><strong>0</strong>0101</td>
<td><strong>0</strong>1111</td>
<td></td>
</tr>
<tr class="odd">
<td><em>sum result</em></td>
<td></td>
<td></td>
<td>10100</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] inA;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inB;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">4</span>:<span class="number">0</span>] outSumSg;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] outSumUs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		inA = <span class="number">4&#x27;b0101</span>;</span><br><span class="line">		inB = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">		outSumUs = inA + inB;</span><br><span class="line">		outSumSg = inA + inB;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%d): %0d&quot;</span>, outSumSg);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%b): %b&quot;</span>, outSumSg);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%d): %0d&quot;</span>, outSumUs);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%b): %b&quot;</span>, outSumUs);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>xcelium</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcelium&gt; run</span><br><span class="line">signed out(%d): -12</span><br><span class="line">signed out(%b): 10100</span><br><span class="line">unsigned out(%d): 20</span><br><span class="line">unsigned out(%b): 10100</span><br><span class="line">xmsim: *W,RNQUIE: Simulation is complete.</span><br><span class="line">xcelium&gt; exit</span><br></pre></td></tr></table></figure>
<p><strong>vcs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiler version S-2021.09-SP2-1_Full64; Runtime version S-2021.09-SP2-1_Full64;  May  7 17:24 2022</span><br><span class="line">signed out(%d): -12</span><br><span class="line">signed out(%b): 10100</span><br><span class="line">unsigned out(%d): 20</span><br><span class="line">unsigned out(%b): 10100</span><br><span class="line">           V C S   S i m u l a t i o n   R e p o r t</span><br></pre></td></tr></table></figure>
<h3 id="observation">observation</h3>
<blockquote>
<p>When <em>signed</em> and <em>unsigned</em> is <strong>mixed</strong>,
the result is by default <strong>unsigned</strong>.</p>
<p>Prepend to operands with <strong>0</strong>s instead of extending
sign, even though the operands is signed</p>
<p>LHS <strong>DONT</strong> affect how the simulator operate on the
operands but what the results represent, signed or unsigned</p>
</blockquote>
<p>Therefore, although <code>outSumUs</code> is declared as signed, its
result is unsigned</p>
<h4 id="subtraction-example">subtraction example</h4>
<p>In logic arithmetic, addition and subtraction are commonly used for
digital design. Subtraction is similar to addition except that the
subtracted number is 2's complement. By using 2's complement for the
subtracted number, both addition and subtraction can be unified to using
addition only.</p>
<h5 id="operands-are-signed">operands are signed</h5>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>inA (signed)</th>
<th>inB (signed)</th>
<th>outSub<br />(signed/unsigned)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>1111 (-1)</td>
<td>0010 (2)</td>
<td></td>
</tr>
<tr class="even">
<td><em>extend sign</em></td>
<td><strong>1</strong>1111</td>
<td><strong>0</strong>0010</td>
<td></td>
</tr>
<tr class="odd">
<td><em>sub result</em></td>
<td></td>
<td></td>
<td>11101</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inA;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inB;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">4</span>:<span class="number">0</span>] outSubSg;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] outSubUs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		inA = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">		inB = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">		outSubUs = inA - inB;</span><br><span class="line">		outSubSg = inA - inB;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%d): %0d&quot;</span>, outSubSg);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%b): %b&quot;</span>, outSubSg);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%d): %0d&quot;</span>, outSubUs);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%b): %b&quot;</span>, outSubUs);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiler version S-2021.09-SP2-1_Full64; Runtime version S-2021.09-SP2-1_Full64;  May  7 17:46 2022</span><br><span class="line">signed out(%d): -3</span><br><span class="line">signed out(%b): 11101</span><br><span class="line">unsigned out(%d): 29</span><br><span class="line">unsigned out(%b): 11101</span><br><span class="line">           V C S   S i m u l a t i o n   R e p o r t</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcelium&gt; run</span><br><span class="line">signed out(%d): -3</span><br><span class="line">signed out(%b): 11101</span><br><span class="line">unsigned out(%d): 29</span><br><span class="line">unsigned out(%b): 11101</span><br><span class="line">xmsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>
<h5 id="operands-are-mixed">operands are mixed</h5>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>inA (signed)</th>
<th>inB (unsigned)</th>
<th>outSub<br />(signed/unsigned)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>1111 (-1)</td>
<td>0010 (2)</td>
<td></td>
</tr>
<tr class="even">
<td><em>extend sign</em></td>
<td><strong>0</strong>1111</td>
<td><strong>0</strong>0010</td>
<td></td>
</tr>
<tr class="odd">
<td><em>sub result</em></td>
<td></td>
<td></td>
<td>01101</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] inA;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] inB;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">4</span>:<span class="number">0</span>] outSubSg;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] outSubUs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		inA = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">		inB = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">		outSubUs = inA - inB;</span><br><span class="line">		outSubSg = inA - inB;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%d): %0d&quot;</span>, outSubSg);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;signed out(%%b): %b&quot;</span>, outSubSg);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%d): %0d&quot;</span>, outSubUs);</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;unsigned out(%%b): %b&quot;</span>, outSubUs);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiler version S-2021.09-SP2-1_Full64; Runtime version S-2021.09-SP2-1_Full64;  May  7 17:50 2022</span><br><span class="line">signed out(%d): 13</span><br><span class="line">signed out(%b): 01101</span><br><span class="line">unsigned out(%d): 13</span><br><span class="line">unsigned out(%b): 01101</span><br><span class="line">           V C S   S i m u l a t i o n   R e p o r t </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcelium&gt; run</span><br><span class="line">signed out(%d): 13</span><br><span class="line">signed out(%b): 01101</span><br><span class="line">unsigned out(%d): 13</span><br><span class="line">unsigned out(%b): 01101</span><br><span class="line">xmsim: *W,RNQUIE: Simulation is complete.</span><br><span class="line">xcelium&gt; exit</span><br></pre></td></tr></table></figure>
<h3 id="danger-sign">Danger Sign</h3>
<p><a
href="https://projectf.io/posts/numbers-in-verilog/">https://projectf.io/posts/numbers-in-verilog/</a></p>
<blockquote>
<p>Verilog has a nasty habit of treating everything as unsigned unless
all variables in an expression are signed. To add insult to injury, most
tools won’t warn you if signed values are being ignored.</p>
<p>If you take one thing away from this post:</p>
<p><strong>Never mix signed and unsigned variables in one
expression!</strong></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> signed_tb ();</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] x;  <span class="comment">// &#x27;x&#x27; is unsigned</span></span><br><span class="line">    <span class="keyword">logic</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] y;  <span class="comment">// &#x27;y&#x27; is signed</span></span><br><span class="line">    <span class="keyword">logic</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] x1, y1;</span><br><span class="line">    <span class="keyword">logic</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] move;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        x1 = x + move;  <span class="comment">// !? DANGER: &#x27;x&#x27; is unsigned but &#x27;move&#x27; is signed</span></span><br><span class="line">        y1 = y + move;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Coordinates (7,7):&quot;</span>);</span><br><span class="line">        x = <span class="number">8&#x27;d7</span>;</span><br><span class="line">        y = <span class="number">8&#x27;d7</span>;</span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;x : %b  %d&quot;</span>, x, x);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;y : %b  %d&quot;</span>, y, y);</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Move +4:&quot;</span>);</span><br><span class="line">        move = <span class="number">4</span>&#x27;sd4;  <span class="comment">// signed positive value</span></span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;x1: %b  %d  *LOOKS OK*&quot;</span>, x1, x1);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;y1: %b  %d&quot;</span>, y1, y1);</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Move -4:&quot;</span>);</span><br><span class="line">        move = -<span class="number">4</span>&#x27;sd4;  <span class="comment">// signed negative value</span></span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;x1: %b  %d  *SURPRISE*&quot;</span>, x1, x1);     <span class="comment">// 0000_0111 + &#123;0000&#125;_1100 = 0001_0011</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;y1: %b  %d&quot;</span>, y1, y1);                 <span class="comment">// 0000_0111 + &#123;1111&#125;_1100 = 0000_0011</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chronologic VCS simulator copyright 1991-2021</span><br><span class="line">Contains Synopsys proprietary information.</span><br><span class="line">Compiler version S-2021.09-SP2-2_Full64; Runtime version S-2021.09-SP2-2_Full64;  Nov 19 11:02 2022                                     </span><br><span class="line">Coordinates (7,7):</span><br><span class="line">x : 00000111    7</span><br><span class="line">y : 00000111            7</span><br><span class="line">Move +4:</span><br><span class="line">x1: 00001011           11  *LOOKS OK*</span><br><span class="line">y1: 00001011           11</span><br><span class="line">Move -4:</span><br><span class="line">x1: 00010011           19  *SURPRISE*</span><br><span class="line">y1: 00000011            3</span><br><span class="line">           V C S   S i m u l a t i o n   R e p o r t</span><br><span class="line">Time: 60</span><br><span class="line">CPU Time:      0.260 seconds;       Data structure size:   0.0Mb</span><br></pre></td></tr></table></figure>
<h3 id="reference">reference</h3>
<p>Lee WF. Learning from VLSI Design Experience [electronic Resource] /
by Weng Fook Lee. 1st ed. 2019. Springer International Publishing; 2019.
doi:10.1007/978-3-030-03238-8</p>
<p><a href="https://www.ece.ucdavis.edu/~bbaas/281/">Bevan Baas, VLSI
Digital Signal Processing, EEC 281 - VLSI Digital Signal
Processing</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Multicycle Paths Constraints in PrimeTime</title>
    <url>/2022/03/01/multicycle-paths/</url>
    <content><![CDATA[<p>PrimeTime <em>does not</em> automatically identifies multicycle
paths.</p>
<h4 id="specifying-multicycle-path-for-setup">specifying multicycle path
for setup</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">6</span> -from reg[<span class="number">26</span>]/CP -to reg/D</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">set_multicycle_path -setup <span class="number">6</span> -from reg[<span class="number">26</span>]/CP -to reg/D</span><br><span class="line"><span class="comment"># check the exception</span></span><br><span class="line">report_exception</span><br></pre></td></tr></table></figure>
<h4
id="specifying-multicycle-path-for-hold-new-data-every-6-cycles">specifying
multicycle path for hold (new data every 6 cycles)</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_multicycle_path -setup <span class="number">6</span> -to [get_pins <span class="string">&quot;*reg[*]/D&quot;</span>]</span><br><span class="line">set_multicycle_path -hold [<span class="keyword">expr</span> <span class="number">6</span><span class="number">-1</span>] -to [get_pins <span class="string">&quot;*reg[*]/D&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/01/multicycle-paths/image-20220301215938296.png"
alt="image-20220301215938296" /></p>
<p>M<sub>H</sub> stands for Hold Multiplier, M<sub>S</sub> for Setup
Multiplier. The Setup multiplier counts up with increasing clock cycles,
the Hold Multiplier counts up with decreasing cycles. The origin (0) for
the Hold Multiplier is always at the <code>Setup Multiplier - 1</code>
position.</p>
<h4 id="reporting-a-multicycle-path-with-report_timing">Reporting a
multicycle path with report_timing</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">report_timing -exceptions all -from *reg[<span class="number">26</span>]/CP -to *reg/D</span><br></pre></td></tr></table></figure>
<h4 id="timing-exceptions">Timing Exceptions</h4>
<p>If certain paths are <strong>not</strong> intended to operate
according to <em>the default setup and hold behavior assumed by the
PrimeTime tool</em>, you need to specify those paths as timing
exceptions. Otherwise, the tool might incorrectly report those paths as
having timing violations.</p>
<p>The PrimeTime tool lets you specify the following types of
exceptions:</p>
<ul>
<li>False path – A path that is never sensitized due to the logic
configuration, expected data sequence, or operating mode.</li>
<li>Multicycle path – A path designed to take more than one clock cycle
from launch to capture.</li>
<li>Minimum or maximum delay path – A path that must meet a delay
constraint that you explicitly specify as a time value.</li>
</ul>
<h4 id="ref">REF</h4>
<p>PrimeTime® User Guide Version O-2018.06-SP4 Chapter 1: Introduction
to PrimeTime Overview of Static Timing Analysis - Timing Exceptions</p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Interpolation and Decimation</title>
    <url>/2024/05/23/multirate/</url>
    <content><![CDATA[<p><em>TODO</em> 📅</p>
<h2 id="mutistage">Mutistage</h2>
<h2 id="polyphase-decomposition">Polyphase Decomposition</h2>
<h2 id="interpolation">Interpolation</h2>
<h3 id="zero-order-hold-zoh">Zero-Order Hold (ZOH)</h3>
<h3 id="first-order-hold-foh">First-Order Hold (FOH)</h3>
<h2 id="decimation">Decimation</h2>
<h2 id="reference">reference</h2>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Noise Analysis</title>
    <url>/2024/04/27/noise-folding/</url>
    <content><![CDATA[<h2 id="frequency-domain-representation-of-sampling">Frequency-domain
representation of sampling</h2>
<p><img src="/2024/04/27/noise-folding/image-20240428145937610.png"
alt="image-20240428145937610" /></p>
<blockquote>
<p><span class="math inline">\(\omega = \Omega T\)</span></p>
</blockquote>
<ul>
<li><p>continuous-time signal <span
class="math inline">\(x_c(t)\)</span></p></li>
<li><p><span class="math inline">\(x_s(t)\)</span> is, in a sense, a
continuous-time signal (specifically, an impulse train) that is zero,
except at integer multiples of <span
class="math inline">\(T\)</span></p></li>
<li><p>The sequence <span class="math inline">\(x[n]\)</span>, on the
other hand, is indexed on the integer variable n, which, in effect,
introduces a time normalization; i.e., the sequence of numbers <span
class="math inline">\(x[n]\)</span> contains no explicit information
about the sampling period <span
class="math inline">\(T\)</span></p></li>
</ul>
<blockquote>
<p>the samples of <span class="math inline">\(x_c(t)\)</span> are
represented by <em>finite numbers</em> in <span
class="math inline">\(x[n]\)</span> rather than as the <em>areas of
impulses</em>, as with <span class="math inline">\(x_s(t)\)</span></p>
</blockquote>
<p><span class="math inline">\(X_s(j\Omega)\)</span>, the Fourier
transform of <span class="math inline">\(x_s(t)\)</span> <span
class="math display">\[
X_s(j\Omega) = \sum_{n=-\infty}^{\infty}x_c(nT)e^{-j\Omega Tn}
\]</span> <img
src="/2024/04/27/noise-folding/image-20240428150000863.png"
alt="image-20240428150000863" /></p>
<p><span class="math inline">\(X(e^{j\omega})\)</span>, the
discrete-time Fourier transform (DTFT) of the sequence <span
class="math inline">\(x[n]\)</span> <span class="math display">\[
X(e^{j\omega}) = \sum_{n=-\infty}^{\infty}x[n]e^{-j\omega n}
\]</span> <img
src="/2024/04/27/noise-folding/image-20240428150020709.png"
alt="image-20240428150020709" /></p>
<p>where <span class="math inline">\(x[n] = x_c(nT)\)</span></p>
<h2 id="fourier-analysis-of-stationary-random-signals">Fourier Analysis
of Stationary Random Signals</h2>
<blockquote>
<p><img src="/2024/04/27/noise-folding/image-20240428161506523.png"
alt="image-20240428161506523" /></p>
<p>[<a
href="https://dsp.stackexchange.com/a/17348/59253">https://dsp.stackexchange.com/a/17348/59253</a>]</p>
</blockquote>
<blockquote>
<p>discrete-time random signal and autocorrelation <span
class="math display">\[
\phi[m] = \phi_c(mT)
\]</span> <img
src="/2024/04/27/noise-folding/image-20240428162643394.png"
alt="image-20240428162643394" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240428162655969.png"
alt="image-20240428162655969" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240428162735492.png"
alt="image-20240428162735492" /></p>
</blockquote>
<h2 id="energy-signals-vs-power-signal">Energy signals vs Power
signal</h2>
<p><img src="/2024/04/27/noise-folding/image-20240427155046131.png"
alt="image-20240427155046131" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240427155100927.png"
alt="image-20240427155100927" /></p>
<hr />
<p>A pure sine wave is expressed as <span class="math inline">\(y(t) =
A_0 \sin(2\pi f_0 t +\phi _0)\)</span>, its autocorrelation
function:</p>
<p><span class="math display">\[
\mathrm{R}(\tau) = \lim _{T\to \infty}\frac{1}{2T}\int_{-T}^{T}
y(t)y(t+\tau)dt
\]</span></p>
<p>where <span class="math inline">\(y(t)y(t+\tau)\)</span> can be
expressed as <span class="math display">\[\begin{align}
y(t)y(t+\tau) &amp;= A_0\sin(2\pi f_0 t+\phi_0)\cdot A_0\sin(2\pi f_0
t+\phi_0+2\pi f_0\tau) \\
&amp;= A_0^2\sin^2(2\pi f_0 t+\phi_0)\cdot \cos(2\pi f_0\tau) +
A_0^2\sin(2\pi f_0 t+\phi_0)\cos(2\pi f_0 t+\phi_0)\cdot \cos(2\pi
f_0\tau) \\
&amp;= \frac{1}{2}A_0^2 (1 - \cos(2(2\pi f_0 t+\phi_0)))\cdot \cos(2\pi
f_0\tau) + \frac{1}{2}A_0^2\sin(2(2\pi f_0 t+\phi_0))\cdot \cos(2\pi
f_0\tau) \\
&amp;= \frac{1}{2}A_0^2\cdot \cos(2\pi f_0\tau) -
\frac{1}{2}A_0^2\cos(2(2\pi f_0 t+\phi_0))\cdot \cos(2\pi f_0\tau) +
\frac{1}{2}A_0^2\sin(2(2\pi f_0 t+\phi_0))\cdot \cos(2\pi f_0\tau)
\end{align}\]</span></p>
<p>And substitute <span class="math inline">\(y(t)y(t+\tau)\)</span> in
<span class="math inline">\(\mathrm{R}(\tau)\)</span></p>
<p><span class="math display">\[\begin{align}
\mathrm{R}(\tau) &amp;= \lim _{T\to \infty}\frac{1}{2T}\int_{-T}^{T}
y(t)y(t+\tau)dt \\
&amp;= \lim _{T\to \infty}\int_{-T}^{T} \left[\frac{1}{2}A_0^2\cdot
\cos(2\pi f_0\tau) - \frac{1}{2}A_0^2\cos(2(2\pi f_0 t+\phi_0))\cdot
\cos(2\pi f_0\tau) + \frac{1}{2}A_0^2\sin(2(2\pi f_0 t+\phi_0))\cdot
\cos(2\pi f_0\tau)\right]dt \\
&amp; = \lim _{T\to \infty}\int_{-T}^{T} \frac{1}{2}A_0^2\cdot \cos(2\pi
f_0\tau) dt \\
&amp;= \frac{1}{2}A_0^2\cdot \cos(2\pi f_0\tau)
\end{align}\]</span></p>
<p>Taking Fourier transform of <span
class="math inline">\(\mathrm{R}(\tau)\)</span>, PSD is</p>
<p><span class="math display">\[
S_y(f) = \frac{1}{4}A_0^2 \delta(f-f_0) + \frac{1}{4}A_0^2 \delta(f+f_0)
\]</span></p>
<hr />
<p><img src="/2024/04/27/noise-folding/image-20240427162827347.png"
alt="image-20240427162827347" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240427170024123.png"
alt="image-20240427170024123" /></p>
<h3 id="reference">reference</h3>
<p>Topic 5 Energy &amp; Power Signals, Correlation &amp; Spectral
Density [<a
href="https://www.robots.ox.ac.uk/~dwm/Courses/2TF_2021/N5.pdf">https://www.robots.ox.ac.uk/~dwm/Courses/2TF_2021/N5.pdf</a>]</p>
<p>Topic 6 Random Processes and Signals [<a
href="https://www.robots.ox.ac.uk/~dwm/Courses/2TF_2021/N6.pdf">https://www.robots.ox.ac.uk/~dwm/Courses/2TF_2021/N6.pdf</a>]</p>
<p>Bae, Woorham; Jeong, Deog-Kyoon: 'Analysis and Design of CMOS
Clocking Circuits for Low Phase Noise' (Materials, Circuits and Devices,
2020)</p>
<h2 id="switched-capacitor">Switched-Capacitor</h2>
<p>The <strong>aliasing of the noise</strong>, or <strong>noise
folding</strong>, plays an important role in switched-capacitor as it
does in all switched-capacitor filters</p>
<p><img src="/2024/04/27/noise-folding/image-20240425215938141.png"
alt="image-20240425215938141" /></p>
<p>Assume for the moment that the switch is <em>always closed</em> (that
there is no hold phase), the single-sided noise density would be</p>
<p><img src="/2024/04/27/noise-folding/image-20240428182816109.png"
alt="image-20240428182816109" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240428180635082.png"
alt="image-20240428180635082" /></p>
<p><span class="math inline">\(v_s[n]\)</span> is the sampled version of
<span class="math inline">\(v_{RC}(t)\)</span>, i.e. <span
class="math inline">\(v_s[n]= v_{RC}(nT_C)\)</span> <span
class="math display">\[
S_s(e^{j\omega}) = \frac{1}{T_C}
\sum_{k=-\infty}^{\infty}S_{RC}(j(\frac{\omega}{T_C}-\frac{2\pi
k}{T_C})) \cdot d\omega
\]</span> where <span class="math inline">\(\omega \in [-\pi,
\pi]\)</span>, furthermore <span
class="math inline">\(\frac{d\omega}{T_C}= d\Omega\)</span> <span
class="math display">\[
S_s(j\Omega) = \sum_{k=-\infty}^{\infty}S_{RC}(j(\Omega-k\Omega_s))
\cdot d\Omega
\]</span></p>
<blockquote>
<p><img src="/2024/04/27/noise-folding/image-20240428215559780.png"
alt="image-20240428215559780" /></p>
</blockquote>
<p><img src="/2024/04/27/noise-folding/image-20240425220033340.png"
alt="image-20240425220033340" /></p>
<p>The noise in <span class="math inline">\(S_{RC}\)</span> is a
<em>stationary process</em> and so is <em>uncorrelated</em> over <span
class="math inline">\(f\)</span> allowing the <span
class="math inline">\(N\)</span> rectangles to be combined by simply
summing their noise powers</p>
<p><img src="/2024/04/27/noise-folding/sample_impulse_hold.drawio.svg"
alt="image-20240428225949327" /></p>
<blockquote>
<p><span class="math display">\[
X(j\Omega)d\Omega = \frac{1}{T_c}X(e^{j\omega})d\omega  
\]</span></p>
<p>ref. <em><a
href="https://raytroop.github.io/2022/05/01/sampling-dft">[Sampling of
Continuous Time Signals]</a></em> of EQ.(31) in the blog</p>
</blockquote>
<p><img src="/2024/04/27/noise-folding/image-20240428225949327.png"
alt="image-20240428225949327" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240425220400924.png"
alt="image-20240425220400924" /></p>
<p>where <span class="math inline">\(m\)</span> is the duty cycle</p>
<p><img src="/2024/04/27/noise-folding/image-20240427183257203.png"
alt="image-20240427183257203" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240427183349642.png"
alt="image-20240427183349642" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240427183516540.png"
alt="image-20240427183516540" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240427183458649.png"
alt="image-20240427183458649" /></p>
<blockquote>
<ul>
<li>Calculate autocorrelation function of noise at the output of the RC
filter</li>
<li>Calculate the spectrum by taking the <strong>discrete</strong> time
Fourier transform of the autocorrelation function</li>
</ul>
</blockquote>
<p><img src="/2024/04/27/noise-folding/image-20240427183700971.png"
alt="image-20240427183700971" /></p>
<p><img src="/2024/04/27/noise-folding/image-20240427195202127.png"
alt="image-20240427195202127" /></p>
<ul>
<li><span class="math inline">\(Vo_{[n-1]}\)</span> decay</li>
<li><span class="math inline">\(Vo_{[n]}\)</span> charge C</li>
</ul>
<h2 id="noise-aliasing">Noise Aliasing</h2>
<p><img src="/2024/04/27/noise-folding/SamplingProcess.drawio.svg"
alt="SamplingProcess.drawio" /></p>
<p>Where impulse train or "shah" function is defined as <span
class="math display">\[
\amalg(t) = T\sum_{i=-\infty}^{\infty}\delta(x-iT)
\]</span> where <span class="math inline">\(T\)</span> defines the
period, or sampling rate. Its Fourier transform is <span
class="math inline">\(2\pi \delta(\omega-i\frac{2\pi}{T})\)</span></p>
<p><strong>Multiplication Property</strong> of Fourier Transform <span
class="math display">\[
x_1(t)x_2(t)\overset{FT}{\longrightarrow}\frac{1}{2\pi}X_1(\omega)*X_2(\omega)
\]</span></p>
<p>Due to <span class="math inline">\(A = B+2C\)</span>, the noise in
the discrete time integrated from DC to <span
class="math inline">\(f_s/2\)</span> equals that of continuous time in
all frequency range.</p>
<blockquote>
<p>The DFT spectrum is periodic with period <strong>N</strong></p>
<p>The DTFT spectrum is periodic with period <span
class="math inline">\(2\pi\)</span></p>
<p>As a conclusion, the spectrum beyond <span
class="math inline">\(f_s/2\)</span> is <strong>redundant</strong> and
don't provide information</p>
</blockquote>
<h2 id="aliasing">Aliasing</h2>
<p>The frequencies <span class="math inline">\(f_{\text{sig}}\)</span>
and <span class="math inline">\(N· f_s ±f_{\text{sig}}\)</span> (N
integer), are <strong>indistinguishable</strong> in the <strong>discrete
time domain</strong>.</p>
<p><img src="/2024/04/27/noise-folding/image-20220626000016184.png"
alt="image-20220626000016184" /></p>
<blockquote>
<p>In order to prevent aliasing, we need <span
class="math inline">\(f_{\text{sig,max}}\lt \frac{f_s}{2}\)</span>. The
sampling rate <span class="math inline">\(f_s=2\cdot
f_{\text{sig,max}}\)</span> is called the <strong>Nyquist
Rate</strong>.</p>
<p>Two solution possibilities</p>
<ol type="1">
<li>Sample fast enough to cover all spectral components, including
"parasitic" ones outside band of interest</li>
<li>Limit <span class="math inline">\(f_{\text{sig,max}}\)</span>
through filtering - Filter out "parasitic" ones</li>
</ol>
</blockquote>
<p>Given below sequence <span class="math display">\[
X[n] =A e^{j\omega _0 T_s n}
\]</span></p>
<ol type="1">
<li><span class="math inline">\(kf_s + \Delta f\)</span></li>
</ol>
<p><span class="math display">\[\begin{align}
x[n] &amp;= Ae^{j\left( kf_s+\Delta f \right)2\pi T_sn} + Ae^{j\left(
-kf_s-\Delta f \right)2\pi T_sn} \\
&amp;= Ae^{j\Delta f\cdot 2\pi T_sn} + Ae^{-j\Delta f\cdot 2\pi T_sn}
\end{align}\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(kf_s - \Delta f\)</span></li>
</ol>
<p><span class="math display">\[\begin{align}
x[n] &amp;= Ae^{j\left( kf_s-\Delta f \right)2\pi T_sn} + Ae^{j\left(
-kf_s+\Delta f \right)2\pi T_sn} \\
&amp;= Ae^{-j\Delta f\cdot 2\pi T_sn} + Ae^{j\Delta f\cdot 2\pi T_sn}
\end{align}\]</span></p>
<blockquote>
<p>With sampling frequency <span
class="math inline">\(\frac{1}{T_s}\)</span>, continuous signal of <span
class="math inline">\(\frac{1}{2T_s}+\Delta f\)</span> and <span
class="math inline">\(-\frac{1}{2T_s}+\Delta f\)</span> can not be
distinguished <em>real signal</em></p>
</blockquote>
<p><img src="/2024/04/27/noise-folding/image-20230518232314980.png"
alt="image-20230518232314980" /></p>
<blockquote>
<p>Generally, The frequencies <span
class="math inline">\(f_{\text{sig}}\)</span> and <span
class="math inline">\(N· f_s ±f_{\text{sig}}\)</span> (N integer), are
<strong>indistinguishable</strong> in the <strong>discrete time
domain</strong>.</p>
</blockquote>
<h3 id="aliasing-example">Aliasing Example</h3>
<p>Given <span class="math inline">\(f_s = 1000\)</span> KHz</p>
<ol type="1">
<li><p><span class="math inline">\(f_{\text{sig}}=101\)</span> KHz</p>
<p><img src="/2024/04/27/noise-folding/image-20220626000206662.png"
alt="image-20220626000206662" /></p></li>
<li><p><span class="math inline">\(f_{\text{sig}}=899\)</span> KHz</p>
<p><img src="/2024/04/27/noise-folding/image-20220626000258632.png"
alt="image-20220626000258632" /></p></li>
<li><p><span class="math inline">\(f_{\text{sig}}=1101\)</span> KHz</p>
<p><img src="/2024/04/27/noise-folding/image-20220626000320755.png"
alt="image-20220626000320755" /></p></li>
</ol>
<h3 id="classes-of-sampling">Classes of Sampling</h3>
<ul>
<li><p>Nyquist-rate sampling</p>
<p><span class="math inline">\(f_s \gt 2 \cdot
f_{\text{sig,max}}\)</span></p></li>
<li><p>Oversampling</p>
<p><span class="math inline">\(f_s \gg 2\cdot
f_{\text{sig,max}}\)</span></p></li>
<li><p>Undersampling, subsampling</p>
<p><span class="math inline">\(f_s \lt 2\cdot
f_{\text{sig,max}}\)</span></p></li>
</ul>
<h2 id="dirac-pulses-and-spectrum">Dirac Pulses and spectrum</h2>
<p>Spectrum of <span class="math inline">\(x_d(t)\)</span> contains
<strong>scaled replicas</strong> of <span
class="math inline">\(X(f)\)</span> at <strong>integer
multiples</strong> of the sampling frequency <span
class="math inline">\(f_s\)</span></p>
<p><img src="/2024/04/27/noise-folding/image-20220626001925375.png"
alt="image-20220626001925375" /></p>
<p><img src="/2024/04/27/noise-folding/image-20220626001043693.png"
alt="image-20220626001043693" /></p>
<h2 id="reference-1">reference</h2>
<p>David Herres, The difference between signal under-sampling, aliasing,
and folding URL: <a
href="https://www.testandmeasurementtips.com/the-difference-between-signal-under-sampling-aliasing-and-folding-faq/">https://www.testandmeasurementtips.com/the-difference-between-signal-under-sampling-aliasing-and-folding-faq/</a></p>
<p>Pharr, Matt; Humphreys, Greg. (28 June 2010). Physically Based
Rendering: From Theory to Implementation. Morgan Kaufmann. ISBN
978-0-12-375079-2. <a
href="https://web.archive.org/web/20131016055332/http://graphics.stanford.edu/~mmp/chapters/pbrt_chapter7.pdf">Chapter
7 (Sampling and reconstruction)</a></p>
<p>Kundert, Ken. (2006). Simulating Switched-Capacitor Filters with
SpectreRF.</p>
<p>Pavan, Schreier and Temes, "Understanding Delta-Sigma Data
Converters, Second Edition" ISBN 978-1-119-25827-8</p>
<p>Boris Murmann, EE315B VLSI Data Conversion Circuits, Autumn 2013</p>
<p>- Noise Analysis in Switched-Capacitor Circuits, ISSCC 2011 /
tutorials</p>
<p>Tania Khanna, ESE568 Fall 2019, Mixed Signal Circuit Design and
Modeling URL: <a
href="https://www.seas.upenn.edu/~ese568/fall2019/">https://www.seas.upenn.edu/~ese568/fall2019/</a></p>
<p>Matt Pharr, Wenzel Jakob, and Greg Humphreys. 2016. Physically Based
Rendering: From Theory to Implementation (3rd. ed.). Morgan Kaufmann
Publishers Inc., San Francisco, CA, USA.</p>
<p>Bernhard E. Boser . Advanced Analog Integrated Circuits Switched
Capacitor Gain Stages [<a
href="https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M05%20SC%20Gain%20Stages.pdf">https://people.eecs.berkeley.edu/~boser/courses/240B/lectures/M05%20SC%20Gain%20Stages.pdf</a>]</p>
<p>Alan V Oppenheim, Ronald W. Schafer. Discrete-Time Signal Processing,
3rd edition</p>
<p>R. Gregorian and G. C. Temes. Analog MOS Integrated Circuits for
Signal Processing. Wiley-Interscience, 1986</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Non ideal capacitor and inductor</title>
    <url>/2023/12/24/nonideal-LC/</url>
    <content><![CDATA[<h2 id="conversion-relationships">Conversion Relationships</h2>
<h3 id="capacitor">Capacitor</h3>
<p><img src="/2023/12/24/nonideal-LC/image-20231224163730529.png"
alt="image-20231224163730529" /></p>
<hr />
<p><img src="/2023/12/24/nonideal-LC/image-20240119000951498.png"
alt="image-20240119000951498" /></p>
<p><img src="/2023/12/24/nonideal-LC/image-20240119001025892.png"
alt="image-20240119001025892" /></p>
<p><img src="/2023/12/24/nonideal-LC/image-20240119001309410.png"
alt="image-20240119001309410" /></p>
<h3 id="inductor">Inductor</h3>
<p><img src="/2023/12/24/nonideal-LC/image-20231224163740411.png"
alt="image-20231224163740411" /></p>
<h3 id="derivation">Derivation</h3>
<p><img src="/2023/12/24/nonideal-LC/image-20231224163905233.png"
alt="image-20231224163905233" /></p>
<p><img src="/2023/12/24/nonideal-LC/image-20231224163916109.png"
alt="image-20231224163916109" /></p>
<hr />
<p><img src="/2023/12/24/nonideal-LC/image-20231224212914366.png"
alt="image-20231224212914366" /></p>
<p><img src="/2023/12/24/nonideal-LC/image-20231224212625409.png"
alt="image-20231224212625409" /></p>
<p><img src="/2023/12/24/nonideal-LC/image-20231224212541383.png"
alt="image-20231224212541383" /></p>
<p><span class="math inline">\(V_o = V_i |A|e^{j\theta}\)</span>, and
<span class="math inline">\(A_r = |A|\cos\theta\)</span>, <span
class="math inline">\(A_i = |A|\sin\theta\)</span></p>
<p>Then <span class="math inline">\(I_i = (V_i - V_o)sC_f=
V_i(1-|A|e^{j\theta})sC_f\)</span>, impedance is shown as below</p>
<p><span class="math display">\[\begin{align}
Z &amp;= \frac{V_i}{I_i} \\
&amp;= \frac{1}{(1-|A|e^{j\theta})j\omega C_f} \\
&amp;= -\frac{j}{\omega
C_f\frac{1+|A|^2-2|A|\cos\theta}{1-|A|\cos\theta}} +
\frac{|A|\sin\theta}{\omega C_f (1+|A|^2-2|A|\cos\theta)} \\
\end{align}\]</span></p>
<p><span class="math inline">\(C_\text{eq}\)</span> and <span
class="math inline">\(R_\text{eq}\)</span> are obtained <span
class="math display">\[\begin{align}
C_\text{eq} &amp;= \frac{1+|A|^2-2A_r}{1-A_r}\cdot C_f \\
R_\text{eq} &amp;= \frac{A_i}{1+|A|^2-2A_r}\cdot \frac{1}{\omega C_f}
\end{align}\]</span></p>
<h2 id="series-or-parallel-representation">series or parallel
representation</h2>
<h2 id="reference">reference</h2>
<p>Tank Circuits/Impedances [<a
href="https://stanford.edu/class/ee133/handouts/lecturenotes/lecture5_tank.pdf">https://stanford.edu/class/ee133/handouts/lecturenotes/lecture5_tank.pdf</a>]</p>
<p>Resonant Circuits [<a
href="https://web.ece.ucsb.edu/~long/ece145b/Resonators.pdf">https://web.ece.ucsb.edu/~long/ece145b/Resonators.pdf</a>]</p>
<p>Series &amp; Parallel Impedance Parameters and Equivalent Circuits
[<a
href="https://assets.testequity.com/te1/Documents/pdf/series-parallel-impedance-parameters-an.pdf">https://assets.testequity.com/te1/Documents/pdf/series-parallel-impedance-parameters-an.pdf</a>]</p>
<p>ES Lecture 35: Non ideal capacitor, Capacitor Q and series RC to
parallel RC conversion [<a
href="https://youtu.be/CJ_2U5pEB4o?si=4j4CWsLSapeu-hBo">https://youtu.be/CJ_2U5pEB4o?si=4j4CWsLSapeu-hBo</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Nonlinear Systems</title>
    <url>/2023/10/05/nonlinearSystem/</url>
    <content><![CDATA[<h2 id="a-long-way-to-go">a long way to go</h2>
<p>💢 random process</p>
<p>💢 sde</p>
<hr />
<p>In applying frequency-domain techniques to the analysis of random
signals the natural approach is to Fourier transform the signals.</p>
<p>Unfortunately the Fourier transform of a stochastic process does not,
strictly speaking, exist because it has infinite signal energy.</p>
<h2 id="phase-noise-model">Phase Noise Model</h2>
<p>Consider a stable periodic oscillator subjected to random
fluctuations, so that is satisfies a vector Ito stochastic differential
equation of the form</p>
<p><span class="math display">\[
dX = \mathbf{f(X)}dt + G(X)dW
\]</span></p>
<h2 id="general-model">General Model</h2>
<p>Two assumptions:</p>
<ul>
<li><p>random trajectory perturbations in directions tangent to the
isochron surface passing through <span
class="math inline">\(X(t)\)</span> will never accumulate</p></li>
<li><p>random fluctuations in the direction of the tangent to the stable
orbit accumulate</p></li>
</ul>
<p>This suggests therefore the approximation</p>
<p><span class="math display">\[
X(t) \simeq \mathbf{x}_c(t+\alpha(t)) + \mathbf{\Delta}(t)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{\Delta}(t)\)</span>
represents a small perturbation belonging to the tangent space to the
isochron surface pass through <span
class="math inline">\(\mathbf{x}_c(t+\alpha(t))\)</span></p>
<p>If <span class="math inline">\(\phi(X(t))\)</span> is the asymptotic
phase corresponding to trajectory point <span
class="math inline">\(X(t)\)</span>, the <strong>phase
noise</strong></p>
<p><span class="math display">\[
\alpha(t) = \phi(X(t)) - t
\]</span></p>
<p>After rigorous Ito's process, it can be proven that the phase noise
<span class="math inline">\(\alpha(t)\)</span> satisfies the scalar Ito
stochastic differential equation</p>
<p><span class="math display">\[
d\alpha(t) =
\mathbf{q}_1^T(t+\alpha(t))G(\mathbf{x}_c(t+\alpha(t)))dW(t)
\]</span></p>
<p>The equation models the <em>unwrapped</em> phase noise <span
class="math inline">\(\alpha(t)\)</span>, which takes values in <span
class="math inline">\(\mathbb{R}\)</span></p>
<blockquote>
<p><span class="math inline">\(d\alpha(t) =
\mathbf{q}_1^T(t+\alpha(t))G(\mathbf{x}_c(t+\alpha(t)))dW(t)\)</span>
can be seen as the perturbation <span
class="math inline">\(G(\mathbf{x}_c(t+\alpha(t)))dW(t)\)</span>
projected onto phase gradient <span
class="math inline">\(\mathbf{q}_1\)</span></p>
</blockquote>
<h2 id="mathematical-background">mathematical background</h2>
<h2 id="linear-systems-of-odes">Linear systems of ODEs</h2>
<h2 id="exact-equations">Exact equations</h2>
<p>Suppose <span class="math inline">\(F(x; y)\)</span> is a function of
two variables, which we call the <strong>potential function</strong>,
which suggest potential energy, or electric potential (<span
class="math inline">\(F(x; y) = C\)</span>).</p>
<p>We take the <em>total derivative</em> of <span
class="math inline">\(F\)</span>: <span class="math display">\[
dF = \frac{\partial F}{\partial x}dx +\frac{\partial F}{\partial y}dy
\]</span> We apply the total derivative to <span
class="math inline">\(F(x; y) = C\)</span>, to find the differential
equation <span class="math inline">\(dF=0\)</span></p>
<p>An equation of the form <span class="math display">\[
M(x,y)+N(x,y)\frac{dy}{dx}=0
\]</span> is called <strong>exact</strong> if it was obtained as <span
class="math inline">\(dF = 0\)</span> for some <em>potential
function</em> <span class="math inline">\(F\)</span></p>
<h2 id="integrating-factor">integrating factor</h2>
<p>Given a linear first order equation: <span class="math display">\[
y&#39;+p(x)y = f(x)
\]</span> The <strong>integrating factor</strong> is defined as <span
class="math display">\[
r(x) = e^{\int p(x)dx}
\]</span> We multiply the above linear first order equation with <span
class="math inline">\(r(x)\)</span> <span
class="math display">\[\begin{align}
y&#39;+p(x)y &amp;= f(x) \\
e^{\int p(x)dx}y&#39;+e^{\int p(x)dx}p(x)y &amp;=e^{\int p(x)dx}f(x) \\
\frac{d}{dx}\left[e^{\int p(x)dx}y\right] &amp;=e^{\int p(x)dx}f(x) \\
e^{\int p(x)dx}y &amp;= \int e^{\int p(x)dx}f(x)dx + C \\
y &amp;= e^{-\int p(x)dx}\left(  \int e^{\int p(x)dx}f(x)dx + C \right)
\end{align}\]</span></p>
<blockquote>
<p>Of course, to get a closed form formula for <span
class="math inline">\(y\)</span>, we need to be able to find a closed
form formula for the integrals appearing above</p>
</blockquote>
<h2 id="nonlinear-autonomous-systems-of-odes">Nonlinear Autonomous
Systems of ODEs</h2>
<p>We restrict our attention to a two-dimensional autonomous system
<span class="math display">\[\begin{align}
x&#39; &amp;= f(x,y) \\
y&#39; &amp;= g(x,y)
\end{align}\]</span></p>
<p>where <span class="math inline">\(f(x,y)\)</span> and <span
class="math inline">\(g(x,y)\)</span> are functions of two variables,
and the derivatives are taken with respect to time <span
class="math inline">\(t\)</span></p>
<h2 id="critical-points">critical points</h2>
<p><strong>critical points</strong> are the points where both <span
class="math inline">\(f(x; y) = 0\)</span> and <span
class="math inline">\(g(x; y) = 0\)</span></p>
<h2 id="linearization">Linearization</h2>
<p>we want to linearize the two functions <span
class="math inline">\(f(x; y)\)</span> and <span
class="math inline">\(g(x; y)\)</span> that define this system. To do
so, we will replace <span class="math inline">\(f\)</span> and <span
class="math inline">\(g\)</span> by the <em>tangent plane</em>
approximation to the functions.</p>
<p>Since <span class="math inline">\((x_0; y_0)\)</span> is a critical
point, we know that <span class="math inline">\(f(x_0; y_0) =
0\)</span>, so the tangent plane is given by <span
class="math display">\[
L_f(x; y) = f_x(x_0; y_0)(x − x_0) + f_y(x_0; y_0)(y − y_0)
\]</span> Similarly, the tangent plane for <span
class="math inline">\(g(x; y)\)</span> near the critical point <span
class="math inline">\((x_0; y_0)\)</span> is given by <span
class="math display">\[
L_g(x; y) = g_x(x_0; y_0)(x − x_0) + g_y(x_0; y_0)(y − y_0)
\]</span> That means that we can <em>approximate</em> the solution to
<span class="math inline">\(x&#39; = f(x,y);\quad y&#39; =
g(x,y)\)</span> near the critical point <span
class="math inline">\((x_0, y_0)\)</span> <em>by</em> the solution to
the system <span class="math display">\[\begin{align}
\frac{dx}{dt} &amp;= f_x(x_0, y_0)(x − x_0) + f_y(x_0, y_0)(y − y_0) \\
\frac{dy}{dt} &amp;= g_x(x_0, y_0)(x − x_0) + g_y(x_0, y_0)(y − y_0)
\end{align}\]</span></p>
<p>Next, change variables to <span class="math inline">\((u,v)\)</span>.
That is <span class="math inline">\(u=x-x_0; \quad v=y-y_0\)</span>, so
that <span class="math inline">\((u,v)=(0,0)\)</span> corresponds to
<span class="math inline">\((x_0, y_0)\)</span></p>
<blockquote>
<p>Notice changing variables is not going to affect our differential
equations because <span class="math inline">\(x_0\)</span> and <span
class="math inline">\(y_0\)</span> are constant. <span
class="math display">\[\begin{align}
\frac{dx}{dt} &amp;= \frac{du}{dt} \\
\frac{dy}{dt} &amp;= \frac{dv}{dt}
\end{align}\]</span></p>
</blockquote>
<p>The <em>linearization</em> as the linear system <span
class="math display">\[
\begin{bmatrix}
u \\
v
\end{bmatrix}&#39;
=
\begin{bmatrix}
\frac{\partial f}{\partial x}(x_0,y_0) &amp; \frac{\partial f}{\partial
y}(x_0,y_0) \\
\frac{\partial g}{\partial x}(x_0,y_0) &amp; \frac{\partial g}{\partial
y}(x_0,y_0)
\end{bmatrix}
\begin{bmatrix}
u \\
v
\end{bmatrix}
\]</span></p>
<blockquote>
<p><strong>Jacobian matrix</strong>: derivative matrix</p>
</blockquote>
<h2 id="conservative-equations">Conservative equations</h2>
<p>An equation of the form <span class="math display">\[
x&#39;&#39; + f(x)=0
\]</span> for an arbitrary function <span
class="math inline">\(f(x)\)</span> is called a <strong>conservative
equation</strong></p>
<blockquote>
<p>The equations are conservative as there is no friction in the system
so the energy in the system is "conserved".</p>
</blockquote>
<p>Let us write this equation as a system of nonlinear ODE <span
class="math display">\[
x&#39; = y, \quad y&#39; = -f(x)
\]</span></p>
<p>Assume that we have an <em>autonomous system</em> of differential
equations defining <span class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>, <span class="math display">\[
x&#39; = f(x,y), \quad y&#39; = g(x,y)
\]</span> A <strong>trajectory</strong> for this system is a curve in
the <span class="math inline">\(xy\)</span>-plane that the solution
curve <span class="math inline">\((x(t); y(t))\)</span> will <em>stay
on</em> for <strong>all</strong> <span
class="math inline">\(t\)</span>.</p>
<blockquote>
<p>This curve will generally be given with</p>
<ul>
<li><span class="math inline">\(y\)</span> as a function of <span
class="math inline">\(x\)</span>,</li>
<li>or the level curve of some function <span class="math inline">\(F(x;
y)\)</span>.</li>
</ul>
</blockquote>
<h2 id="hamiltonian-systems">Hamiltonian Systems</h2>
<p>A generalization of <em>conservative equations</em> to systems is a
<strong>Hamiltonian system</strong>.</p>
<p>For these systems, the point is that the equation has a <em>conserved
quantity</em> called a <strong>Hamiltonian</strong>, which <em>does not
change as the system evolves in time</em>, which generally represents
the <em>energy of the system</em>. Calling this function <span
class="math inline">\(H(x; y)\)</span>, this means that <span
class="math display">\[
\frac{d}{dt}H(x,y) = 0
\]</span> Below give the definition of <strong>Hamiltonian
system</strong>:</p>
<blockquote>
<p>The system <span class="math display">\[\begin{align}
\frac{dx}{dt} &amp;= f(x,y) \\
\frac{dy}{dt} &amp;= g(x, y)
\end{align}\]</span></p>
<p>is <strong>Hamiltonian</strong> if there is a function <span
class="math inline">\(H(x,y)\)</span> so that <span
class="math display">\[\begin{align}
f(x,y) &amp;=-\frac{\partial H}{\partial y} \\
g(x,y) &amp;= \frac{\partial H}{\partial x}
\end{align}\]</span></p>
</blockquote>
<h2 id="limit-cycles">Limit cycles</h2>
<p>unforced nonlinear time-invariant differential systems of the form
<span class="math display">\[
\frac{d\mathbf{x}}{dt}=\mathbf{f(x)}
\]</span></p>
<p>For nonlinear systems, trajectories do not simply need to approach or
leave a single point. They may in fact approach a larger set, such as a
<em>circle</em> or <em>another closed curve</em>.</p>
<h2 id="poincarébendixson-theorem">Poincaré–Bendixson Theorem</h2>
<h2 id="mathieus-equation">Mathieu's equation</h2>
<h2 id="floquet-theory">Floquet Theory</h2>
<blockquote>
<p>The general theory of linear differential equations with periodic
coefficients</p>
</blockquote>
<p>When a small perturbation <span
class="math inline">\(\mathbf{\delta}(t)\)</span> is applied to a
periodic orbit <span class="math inline">\(\mathbf{x}_c(t)\)</span> so
that the oscillator position is <span class="math display">\[
\mathbf{x}(t)=\mathbf{x}_c(t)+\mathbf{\delta}(t)
\]</span> by performing a Taylor series expansion in the vicinity of
<span class="math inline">\(\mathbf{x}_c(t)\)</span>, we obtain</p>
<p><span class="math display">\[\begin{align}
\frac{d}{dt}(\mathbf{x}_c(t)+\mathbf{\delta}(t)) &amp;=
\mathbf{f}(\mathbf{x}_c(t)+\mathbf{\delta}(t)) \\
&amp;= \mathbf{f}(\mathbf{x}_c(t)) + \mathbf{A}(t)\mathbf{\delta}(t) +
O(||\mathbf{\delta}(t)||^2)
\end{align}\]</span></p>
<p>where <span class="math display">\[
\mathbf{A}(t) = \mathbf{J}(\mathbf{x}_c(t))
\]</span> denotes the vector field Jacobian evaluted along the periodic
orbit <span class="math inline">\(\mathbf{x}_c(t)\)</span></p>
<p>This indicates that small trajectory perturbations satisfy the linear
differential equation <span class="math display">\[
\frac{d\mathbf{\delta}}{dt} = \mathbf{A}(t)\mathbf{\delta}(t)
\]</span></p>
<blockquote>
<p>where <span class="math inline">\(\mathbf{A}(t)\)</span> is periodic
with period <span class="math inline">\(T\)</span> since <span
class="math inline">\(\mathbf{x}_c(t)\)</span> is periodic with the same
period</p>
</blockquote>
<p>Since <span class="math inline">\(\mathbf{x}_c(t)\)</span> solves the
differential equation, by differentiating <span class="math display">\[
\frac{d\mathbf{x}_c(t)}{dt} =\mathbf{f}(\mathbf{x}_c(t)
\]</span> we obtain <span class="math display">\[
\frac{d}{dt}\left(\frac{d\mathbf{x}_c(t)}{dt}\right)
=\frac{d\mathbf{f}}{d\mathbf{x}_c}\frac{d\mathbf{x}_c(t)}{dt}
\]</span> and denoting <span
class="math inline">\(\mathbf{v}(t)=d\mathbf{x}_c/dt\)</span>, then
<span class="math display">\[
\frac{d\mathbf{v}}{dt} = \mathbf{A}(t)\mathbf{v}(t)
\]</span> where the velocity vector <span
class="math inline">\(\mathbf{v}(t)\)</span> is periodic with period
<span class="math inline">\(T\)</span> and is tangent to orbit <span
class="math inline">\(C\)</span> at point <span
class="math inline">\(\mathbf{x}_c(t)\)</span></p>
<blockquote>
<p><strong>SPECIAL CASE:</strong></p>
<p>If the initial perturbation <span
class="math inline">\(\mathbf{\delta}(0)\)</span> is colinear with
vector <span class="math inline">\(\mathbf{v}(0)\)</span>, i.e., <span
class="math inline">\(\mathbf{\delta}(0) = \alpha
\mathbf{v}(0)\)</span>, then <span class="math display">\[
\mathbf{\delta}(t) = \alpha \mathbf{v}(t)
\]</span> for all <span class="math inline">\(t\)</span>, so that in
this case <span class="math inline">\(\mathbf{\delta}(t)\)</span>
<strong>remain</strong> colinear with <span
class="math inline">\(\mathbf{v}(t)\)</span> and is periodic with period
<span class="math inline">\(T\)</span></p>
</blockquote>
<p>Since the oscillator orbit we consider is stable, small perturbations
in <strong>directions other than the tangent to the trajectory</strong>
must <strong>disappear</strong> as <span
class="math inline">\(t\)</span> becomes large.</p>
<p>i.e., if <span class="math inline">\(\mathbf{\delta}(0)\)</span> has
no component along the <span
class="math inline">\(\mathbf{v}(0)\)</span> direction, we must have
<span class="math display">\[
\lim_{t\to \infty}\mathbf{\delta}(t) = 0
\]</span></p>
<h2 id="chaos">Chaos</h2>
<p>Achaotic system is extremely sensitive to initial conditions.</p>
<p>A small change in the initial conditions yields a very different
solution after a reasonably short time</p>
<h2 id="riemann-integral">Riemann integral</h2>
<p><em>standard</em> (Riemann) integral <span class="math display">\[
\int_0^T f(t)dt = \lim_{N\to\infty}\sum_{k=0}^{N-1}f(\tilde{t_k})\Delta
t_k,\quad\Delta t_k=t_{k+1}-t_k
\]</span> where the width of each interval is <span
class="math inline">\(T/N\)</span>, and for each interval <span
class="math inline">\(\Delta t_k\)</span>, we choose a value <span
class="math inline">\(\tilde{t_k}\in[t_k,t_{k+1}]\)</span> at which we
evaluate the function.</p>
<p><img src="/2023/10/05/nonlinearSystem/riemann_int.png"
alt="The Riemann integral construction; divide the function up into rectangles. Here, I’ve evaluated the function at the left edge of each rectangle." /></p>
<p>The Riemann integral construction; divide the function up into
rectangles. Here, I’ve evaluated the function at the <em>left edge</em>
of each rectangle.</p>
<blockquote>
<p>For <em>ordinary, smooth functions</em>, of course, this integral
converges to the same value <em>no matter</em> where we choose our
rectangle heights <span class="math inline">\(\tilde{t_k}\)</span> in
the interval.</p>
<p>However, Brownian motion is <em>less well behaved</em>.</p>
</blockquote>
<h2 id="lebesgue-integral">Lebesgue integral</h2>
<p>[<a href="https://qr.ae/py5x6K">What is the difference between a
Riemann and a Lebesgue integral, and why is the latter needed?</a>]</p>
<p>Riemann integration:</p>
<p><img src="/2023/10/05/nonlinearSystem/image-20230702004840807.png"
alt="image-20230702004840807" /></p>
<blockquote>
<p>The disadvantage of the Riemann integral is that it privileges the
role of intervals. It is ineffective when applied to a highly
discontinuous function</p>
</blockquote>
<p>Lebesgue integration:</p>
<p><img src="/2023/10/05/nonlinearSystem/image-20230702005049938.png"
alt="image-20230702005049938" /></p>
<h2 id="measure-and-probabilities">Measure and Probabilities</h2>
<blockquote>
<p>Probality is a measure of the size of a set</p>
</blockquote>
<h2 id="power-set">power set</h2>
<h2 id="sigma-algebra"><span
class="math inline">\(\sigma\)</span>-Algebra</h2>
<p>or <span class="math inline">\(\sigma\)</span>-field, Sigma-field</p>
<h2 id="measurable-space">measurable space</h2>
<p>If <span class="math inline">\(X\)</span> is a set and <span
class="math inline">\(A\)</span> is a <span
class="math inline">\(\sigma\)</span>-algebra on <span
class="math inline">\(X\)</span>, then the tuple <span
class="math inline">\((X,A)\)</span> is called the <strong>measurable
space</strong> (also <strong>Borel space</strong>)</p>
<h2 id="probability-space">probability space</h2>
<h2 id="filtration-and-information-flow">filtration and information
flow</h2>
<h2 id="martingale">martingale</h2>
<p>A stochastic process <span class="math inline">\(M_t\)</span> is a
<strong>martingale</strong> if</p>
<ul>
<li><p>its <em>mean</em> is bounded</p></li>
<li><p>and <em>the conditional expectation given access to it’s history
up to time</em> <span class="math inline">\(t&#39;\)</span> is equal to
the value at that time</p></li>
</ul>
<p>that is <span class="math display">\[\begin{align}
\mathbb{E}[|M_t|] &amp;\lt \infty \\
\mathbb{E}[M_t|{M_s,s\leq t&#39;}] &amp;= M_{t&#39;}, \quad \text{for
all } t&#39;\leq t
\end{align}\]</span></p>
<blockquote>
<p>In less formal language, this means that the “best guess" for the
future value of a martingale is always the most recent observed value;
knowing <span class="math inline">\(M_{t&#39;}\)</span> is just as good
as knowing the entire history of <span
class="math inline">\(M_t\)</span> up to <span
class="math inline">\(t&#39;\)</span></p>
<p>If <span class="math inline">\(W_t\)</span> is your wealth at the
<span class="math inline">\(t^{th}\)</span> round of a fair game, like
betting on a coin flip, then <span class="math inline">\(W_t\)</span> is
a martingale; on average you end up with the same amount of money you
started with.</p>
</blockquote>
<h2 id="wss-process">WSS process</h2>
<p>A random process <span class="math inline">\(X(t)\)</span> is
<strong>wide-sense stationary</strong> if:</p>
<ol type="1">
<li><span class="math inline">\(\mu _x(t)=\text{constant}\)</span>, for
all <span class="math inline">\(t\)</span>, and</li>
<li><span class="math inline">\(R_X(t_1, t_2)=R_x(t_1-t_2)\)</span> for
all <span class="math inline">\(t_1, t_2\)</span></li>
</ol>
<h2 id="autocorrelation">autocorrelation</h2>
<p><span class="math display">\[
R_X(t_1, t_2) = \mathbb{E}[X(t_1)X(t_2)]
\]</span></p>
<h2 id="temporal-average">temporal average</h2>
<p>Consider the following function: <span class="math display">\[
\hat{R_X}(\tau) = \frac{1}{2T}\int_{-T}^{T}X(t+\tau)X(t)dt
\]</span> This function is the temporal average of <span
class="math inline">\(X(t+\tau)X(t)\)</span></p>
<p>Then <span class="math display">\[
\mathbb{E}[\hat{R_X}(\tau)] = R_X(\tau)
\]</span></p>
<h2 id="power-spectral-density">power spectral density</h2>
<h3 id="time-domain">time domain</h3>
<p>Define <span class="math display">\[
P_X = \mathbb{E}\left[ \lim_{T\to
\infty}\frac{1}{2T}\int_{-T}^{T}|X(t)|^2dt \right]
\]</span> Then we have <span class="math inline">\(P_X =
\frac{1}{2\pi}\int_{-\infty}^{\infty}S_X(\omega)d\omega\)</span> or
<span class="math inline">\(P_X =
\int_{-\infty}^{\infty}S_X(f)df\)</span></p>
<h2 id="frequency-domain">frequency domain</h2>
<p>The <em>power spectral density (PSD)</em> of a <em>WSS process</em>
is defined as <span class="math display">\[
S_X(\omega) = \lim_{T\to
\infty}\frac{\mathbb{E}[|\tilde{X}_T(\omega)|^2]}{2T}
\]</span> where <span class="math inline">\(\tilde{X}_T(\omega) =
\int_{-T}^{T}X(t)e^{-j\omega t}dt\)</span> is the Fourier transform of
<span class="math inline">\(X(t)\)</span> limited to <span
class="math inline">\([-T, T]\)</span>, Parseval's theorem is
applied.</p>
<p>That is <span class="math display">\[\begin{align}
P_X  &amp;= \frac{1}{2\pi}\int_{-\infty}^{\infty}S_X(\omega)d\omega \\
&amp;= \frac{1}{2\pi}\int_{-\infty}^{\infty}\lim_{T\to
\infty}\frac{\mathbb{E}[|\tilde{X}_T(\omega)|^2]}{2T}d\omega
\end{align}\]</span></p>
<h2 id="einstein-wiener-khinchin-theorem">Einstein-Wiener-Khinchin
Theorem</h2>
<blockquote>
<p>The Einstein-Wiener-Khinchin theorem is a fundamental result. It
states that for any <em>wide sense stationary process</em>, the power
spectral density <span class="math inline">\(S_X(\omega)\)</span> is the
Fourier transform of the autocorrelation function.</p>
</blockquote>
<p>The power spectral density <span
class="math inline">\(S_X(\omega)\)</span> of a <em>WSS process</em> is
<span class="math display">\[
S_X(\omega) = \int_{-\infty}^{\infty}R_X(\tau)e^{-j\omega \tau}d\tau =
\mathcal{F}(R_X(\tau))
\]</span> assuming that <span
class="math inline">\(\int_{-\infty}^{\infty}R_X(\tau)^2d\tau \lt
\infty\)</span> so that the Fourier transform of <span
class="math inline">\(R_X(\tau)\)</span> exists</p>
<p><img src="/2023/10/05/nonlinearSystem/image-20230715101317632.png"
alt="image-20230715101317632" /></p>
<h2 id="wiener-process-or-brownian-motion">Wiener Process (or Brownian
Motion)</h2>
<blockquote>
<p><span class="math inline">\(\text{SDE} = \text{ODE} +
\text{GWN}\)</span></p>
<p>where <span class="math inline">\(\text{GWN}\)</span> is
<strong>Gaussian White Noise</strong></p>
</blockquote>
<p>a Brownian Motion <span
class="math inline">\(\{W_t\}_{t:t\in[0,\infty]}\)</span> is a
stochastic process, whose conditional likelihood is Gaussian with a
variance that increase linearly in the time interval that one considers
and a zero mean</p>
<ul>
<li><span class="math inline">\(W_0 = 0\)</span></li>
<li><span class="math inline">\(W_t \sim \mathbb{N}(0, t)\)</span></li>
<li><span class="math inline">\(W_{t2} - W_{t1}\)</span> is independent
from <span class="math inline">\(W_{t4} - W_{t3}\)</span> for <span
class="math inline">\(0\leq t_1\leq t_2 \leq t_3 \leq t_4\)</span></li>
</ul>
<blockquote>
<p>Brownian motion <span class="math inline">\(W_t\)</span> is an
example of a <strong>Gaussian process</strong></p>
<p>Wiener process can be thought of as the <strong>integral</strong> of
white noise</p>
</blockquote>
<p>The implications of these assumptions are: <span
class="math display">\[
E[W_t] = 0
\]</span></p>
<p><span class="math display">\[
Var(W_t) = E[W_t^2] = t
\]</span></p>
<ul>
<li><p>A single trajectory <span class="math inline">\(t \to
W_t(\omega)\)</span> is <strong>continuous</strong>, yet extremely
spiky, that is <span class="math inline">\(\frac{dW_t}{dt}\)</span>
<strong>does not</strong> exist.</p></li>
<li><p>Yet, the Brownian Motion itself is well defined of course. that
is <span class="math inline">\(W_t = \int_0^tdW_u\)</span>
<strong>does</strong> exist</p></li>
</ul>
<p><span class="math display">\[
W_t = \int_0^tdW_u
\]</span></p>
<p>What does it really mean?</p>
<ul>
<li><span class="math inline">\(dW_t \sim \mathbb{N}(0,
dt)\)</span></li>
<li><span class="math inline">\(\frac{dW_t}{dt}\sim
\mathbb{N}(0,1)\)</span></li>
</ul>
<p><img src="/2023/10/05/nonlinearSystem/image-20230702094054155.png"
alt="image-20230702094054155" /></p>
<h2 id="ito-sde-with-brownian-motion">Ito SDE with Brownian Motion</h2>
<p><span class="math display">\[
\frac{dX_t}{dt} = f(X_t) + g(X_t)\frac{dW_t}{dt}
\]</span></p>
<p>is not well defined and hence only a popular <em>'Symbolic
Representation'</em></p>
<p>For SDEs, the proper representation is the <strong>'Pathwise
Stochastic Integral Representation'</strong></p>
<p><img src="/2023/10/05/nonlinearSystem/image-20230702155217093.png"
alt="image-20230702155217093" /></p>
<blockquote>
<p><strong>stochastic integral</strong>:</p>
<p>It doesn’t have the same geometrically intuitive nature as the
Riemann integral, but there is an analogy here;</p>
<p>instead of a finite sum of simple functions which are rectangles, we
are now dealing with <strong>a finite sum of 'simple random variables'
multiplied by increments of a Brownian walk</strong>, which are
Gaussian.</p>
</blockquote>
<h2 id="stochastic-differential-equation-sde">stochastic differential
equation (SDE)</h2>
<h2 id="wiener-stochastic-integral">Wiener Stochastic Integral</h2>
<p>Let <span class="math inline">\(L^2([0,T])\)</span> denote the space
of measurable functions <span
class="math inline">\(f:[0,T]\longrightarrow \mathbb{R}\)</span> such
that <span class="math display">\[
||f||_{L^2([0,T])}=\sqrt{\int_0^T|f(t|^2dt}\lt \infty
\]</span> In the above definition, <span
class="math inline">\(||f||_{L^2([0,T])}\)</span> represents the norm of
the function <span class="math inline">\(f\in L^2([0,T])\)</span>, and
known as <em>square-integrable functions</em></p>
<p><span class="math inline">\(\int_0^Tf(t)dB_t\)</span> has the
centered Gaussian distribution <span class="math display">\[
\int_0^Tf(t)dB_t \simeq \mathbb{N}\left(0,\int_0^T|f(t)|^2dt\right)
\]</span> where <span class="math inline">\(f\in L^2([0,T])\)</span></p>
<p>The Wiener stochastic integral <span class="math inline">\(\int_0^T
f(t)dB_t\)</span> is a Gaussian random variable that cannot be
"computed" in the way standard integrals are computed via the use of
primitives. However, when <span class="math inline">\(f\in
L^2([0,T])\)</span> and is continuously differentiable on <span
class="math inline">\([0,T]\)</span>, we have the integration by parts
relation <span class="math display">\[
\int_0^Tf(t)dB_t = f(T)B_T -\int_0^TB_tf&#39;(t)dt
\]</span></p>
<h2 id="ito-stochastic-integral">Ito Stochastic Integral</h2>
<p>The biggest advantage of Ito formulation is that the evaluations of
the function are totally uncorrelated with the increment, by
contruction.</p>
<p>That is to say, that because we evaluate the function <span
class="math inline">\(f(x,B_t, t)\)</span> at the <strong>left</strong>
point of the midpoint, our limiting sum is <span class="math display">\[
\int f(x,B_t, t)dB_t = \lim_{N\to \infty}\sum
f(x_{t_k},B_{t_k},t_k)(B_{t_{k+1}}-B_{t_k})
\]</span></p>
<blockquote>
<p>For a deterministic integral, the convergence of the integral does
<strong>NOT</strong> depend on wheter the integrands is evaluated at the
left, mid or end point.</p>
<p>The Ito stochastic integral uses the left end point for the
integrand.</p>
</blockquote>
<p>But because the increment <span
class="math inline">\((B_{t_{k+1}}-B_{t_k})\)</span> is
<strong>uncorrelated</strong> with <span
class="math inline">\(B_{t_k}\)</span>, it's also <strong>uncorrelated
with any function of <span
class="math inline">\(B_{t_k}\)</span></strong>, i.e. <span
class="math inline">\(f(x_{t_k},B_{t_k},t_k)\)</span>. and the limiting
sum always has <strong>mean zero </strong></p>
<p>This leads to the nice property that an Ito integral <span
class="math display">\[
\int _S ^ T f(x, t)dB_t
\]</span> always has mean zero, and is a martingale</p>
<blockquote>
<p><span class="math inline">\(f(x, t)\)</span> omit <span
class="math inline">\(B_t\)</span> due to uncorrelated property</p>
</blockquote>
<h2 id="quadratic-variation">quadratic variation</h2>
<p>Step function approximation of Brownian motion</p>
<p><span class="math display">\[\begin{align}
E\left[\left( \int_0^Tu_t dB_t \right)^2\right] &amp;= E\left[\int_0^T
|u_t|^2 dt \right] \\
E\left[\int_0^T u_t dB_t\right] &amp;= 0
\end{align}\]</span></p>
<h2 id="basic-ito-formula">Basic Ito formula</h2>
<p>For <span class="math inline">\(f\)</span> is twice continuously
differentiable on <span class="math inline">\([0, T]\)</span>, Taylor's
formula written at the second order for Brownian motion reads <span
class="math display">\[
df(B_t) = f&#39;(B_t)dB_t + \frac{1}{2}f^{&#39;&#39;}(B_t)dt
\]</span> for <strong>infinitesimally small</strong> <span
class="math inline">\(dt\)</span>.</p>
<p>Note that writing this formula as <span class="math display">\[
\frac{df(B_t)}{dt}=f&#39;(B_t)\frac{dB_t}{dt}+\frac{1}{2}f^{&#39;&#39;}(B_t)
\]</span> <strong>does not</strong> make sense because the pathwise
derivative <span class="math display">\[
\frac{dB_t}{dt}\simeq \pm\frac{\sqrt{dt}}{dt}\simeq
\pm\frac{1}{\sqrt{dt}}\simeq \pm\infty
\]</span> of <span class="math inline">\(B_t\)</span> with respect to
<span class="math inline">\(t\)</span> does not exist.</p>
<p>With <span class="math inline">\(f(B_t)-f(B_0)=\int_0^t
df(B_s)\)</span>, we get the integral form of Ito formula for Brownian
motion <span class="math display">\[
f(B_t) =
f(B_0)+\int_0^tf&#39;(B_s)dB_s+\frac{1}{2}\int_0^tf^{&#39;&#39;}(B_s)ds
\]</span></p>
<h2 id="ito-processes">Ito processes</h2>
<p>A stochastic process <span class="math inline">\((X_t)_{t\in
\mathbb{R}_+}\)</span> that can be written as <span
class="math display">\[
X_t = X_0 + \int_0^t v_sds + \int_0^t u_sdB_s,\quad t\geq0
\]</span> or differential notation <span class="math display">\[
dX_t = v_tdt + u_tdB_t
\]</span> where <span
class="math inline">\((u_t)_{t\in\mathbb{R}_+}\)</span> and <span
class="math inline">\((v_t)_{t\in\mathbb{R}_+}\)</span> are
<em>square-integrable adapted process</em></p>
<h2 id="ito-formula-for-ito-processes">Ito formula for Ito
processes</h2>
<p>For any Ito process <span
class="math inline">\((X_t)_{t\in\mathbb{R}_+}\)</span> and any <span
class="math inline">\(f\)</span> that is continuously differentiable on
<span class="math inline">\(t\in[0,T]\)</span> and twice differentiable
in <span class="math inline">\(x\in\mathbb{R}\)</span>, with bounded
derivatives <span class="math display">\[
f(t,X_t) = f(0,X_0)+\int_0^t\frac{\partial f}{\partial s}(s,X_s)ds +
\int_0^t v_s\frac{\partial f}{\partial x}(s,X_s)ds + \int_0^t
u_s\frac{\partial f}{\partial
x}(s,X_s)dB_s+\frac{1}{2}\int_0^t|u_s|^2\frac{\partial ^2 f}{\partial
x^2}(s,X_s)ds
\]</span> Due to <span class="math inline">\(\int_0^t
df(s,X_s)=f(t,X_t)-f(0,X_0)\)</span> <span class="math display">\[
\int_0^t df(s,X_s)=\int_0^t\frac{\partial f}{\partial s}(s,X_s)ds +
\int_0^t v_s\frac{\partial f}{\partial x}(s,X_s)ds + \int_0^t
u_s\frac{\partial f}{\partial
x}(s,X_s)dB_s+\frac{1}{2}\int_0^t|u_s|^2\frac{\partial ^2 f}{\partial
x^2}(s,X_s)ds
\]</span> which allow us to rewrite in differential notation, as <span
class="math display">\[
df(t,X_t) = \frac{\partial f}{\partial t}(t,X_t)dt + v_t\frac{\partial
f}{\partial x}(t, X_t)dt+u_t\frac{\partial f}{\partial
x}(t,X_t)dB_t+\frac{1}{2}|u_t|^2\frac{\partial ^2 f}{\partial x^2}(t,
X_t)dt
\]</span></p>
<ul>
<li><p>In case the function <span class="math inline">\(x \to
f(x)\)</span> does <strong>not depend on the time variable <span
class="math inline">\(t\)</span></strong>, we get <span
class="math display">\[
df(X_t) = v_t\frac{\partial f}{\partial x}(X_t)dt+u_t\frac{\partial
f}{\partial x}(X_t)dB_t+\frac{1}{2}|u_t|^2\frac{\partial ^2 f}{\partial
x^2}(X_t)dt
\]</span></p></li>
<li><p><span class="math inline">\(X_t = B_t\)</span> while taking <span
class="math inline">\(v_t=0\)</span>, <span
class="math inline">\(u_t=1\)</span> and <span
class="math inline">\(X_0=0\)</span> in Ito process, Ito formula reads
<span class="math display">\[
f(t, B_t) = f(0, B_0)+\int_0^t\frac{\partial f}{\partial s}(s,B_s)ds +
\int_0^t\frac{\partial f}{\partial
x}(s,B_s)dB_s+\frac{1}{2}\int_0^t\frac{\partial ^2 f}{\partial
x^2}(s,B_s)ds
\]</span> i.e. in differential notation: <span class="math display">\[
df(t, B_t) = \frac{\partial f}{\partial t}(t,B_t)dt + \frac{\partial
f}{\partial x}(t,B_t)dB_t+\frac{1}{2}\frac{\partial ^2 f}{\partial
x^2}(t,B_t)dt
\]</span></p></li>
</ul>
<hr />
<p><strong>Ito Lemma</strong>, it says that if the input to a function
follows an Ito SDE, then the output to a sufficiently smooth function
follows also an Ito SDE.</p>
<p><img src="/2023/10/05/nonlinearSystem/image-20230702160220762.png"
alt="image-20230702160220762" /></p>
<hr />
<h2 id="bivariate-ito-formula">Bivariate Ito formula</h2>
<p>Consider two Ito processes <span class="math inline">\((X_t)_{t\in
\mathbb{R} _+}\)</span> and <span class="math inline">\((Y_t)_{t\in
\mathbb{R} _+}\)</span> written in <em>integral form</em> as</p>
<p><span class="math display">\[\begin{align}
X_t &amp;= X_0 + \int_0^t v_sds + \int_0^t u_s dB_s, \quad t \geq 0 \\
Y_t &amp;= Y_0 + \int_0^t b_sds + \int_0^t a_s dB_s, \quad t \geq 0
\end{align}\]</span></p>
<p>or in <em>differential notation</em> as</p>
<p><span class="math display">\[\begin{align}
dX_t &amp;= v_t dt +u_tdB_t \\
dY_t &amp;= b_tdt + a_tdB_t
\end{align}\]</span></p>
<p>The Ito formula can also be written for functions <span
class="math inline">\(f\)</span> of two state variables as</p>
<p><span class="math display">\[\begin{align}
df(t,X_t, Y_t) &amp;= \frac{\partial f}{\partial t}(t,X_t,Y_t)dt +
\frac{\partial f}{\partial x}(t, X_t, Y_t)dX_t +
\frac{1}{2}|u_t|^2\frac{\partial ^2 f}{\partial x^2}(t, X_t, Y_t)dt \\
&amp;+\frac{\partial f}{\partial y}(t, X_t, Y_t)d_t +
\frac{1}{2}|a_t|^2\frac{\partial ^2 f}{\partial y^2}(t, X_t, Y_t)dt +
u_ta_t\frac{\partial ^2 f}{\partial x \partial y}(t,X_t,Y_t)dt
\end{align}\]</span></p>
<h2 id="ito-multiplication-table">Ito multiplication table</h2>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(\cdot\)</span></th>
<th><span class="math inline">\(dt\)</span></th>
<th><span class="math inline">\(dB_t\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(dt\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(dB_t\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(dt\)</span></td>
</tr>
</tbody>
</table>
<p>That is</p>
<p><span class="math display">\[\begin{align}
dt\cdot dt &amp;= 0 \\
dt\cdot dB_t &amp;= 0 \\
dB_t \cdot dB_t &amp;= dt
\end{align}\]</span></p>
<p>It follows from above Ito table that</p>
<p><span class="math display">\[\begin{align}
dX_t \cdot dY_t &amp;= (v_tdt+u_tdB_t)\cdot (b_tdt + a_tdB_t) \\
&amp;= b_tv_t(dt)^2+b_tu_tdtdB_t +a_tv_tdtdB_t +a_tu_t(dB_t)^2 \\
&amp;= a_tu_t dt
\end{align}\]</span></p>
<p>and we also have <span class="math display">\[\begin{align}
(dX_t)^2 &amp;= (v_tdt + u_tdB_t)^2 \\
&amp;= (v_t)^2 (dt)^2 + (u_t)^2(dB_t)^2 + 2u_tv_t(dt\cdot dB_t) \\
&amp;= (u_t)^2dt
\end{align}\]</span></p>
<blockquote>
<p><span class="math inline">\(dB_t = \sqrt{dt}\)</span></p>
</blockquote>
<h2 id="ito-formula-using-ito-multiplication-table">Ito formula using
Ito multiplication table</h2>
<p>with <span class="math inline">\((u_t)^2dt=(dX_t)^2\)</span> and
<span class="math inline">\(X_t = v_tdt + u_tdB_t\)</span>, Ito
formula's differential notation can be rewritten as <span
class="math display">\[\begin{align}
df(t,X_t) &amp;= \frac{\partial f}{\partial t}(t,X_t)dt +
v_t\frac{\partial f}{\partial x}(t, X_t)dt+u_t\frac{\partial f}{\partial
x}(t,X_t)dB_t+\frac{1}{2}|u_t|^2\frac{\partial ^2 f}{\partial x^2}(t,
X_t)dt \\
&amp;= \frac{\partial f}{\partial t}(t,X_t)dt + \frac{\partial
f}{\partial x}(t,X_t)\cdot (v_tdt + u_tdB_t) + \frac{1}{2}\frac{\partial
^2 f}{\partial x^2}(t, X_t)\cdot |u_t|^2dt \\
&amp;= \frac{\partial f}{\partial t}(t,X_t)dt + \frac{\partial
f}{\partial x}(t,X_t)dX_t + \frac{1}{2}\frac{\partial ^2 f}{\partial
x^2}(t, X_t)\cdot (dX_t)^2 \\
&amp; = \frac{\partial f}{\partial t}(t,X_t)dt + \frac{\partial
f}{\partial x}(t,X_t)dX_t + \frac{1}{2}\frac{\partial ^2 f}{\partial
x^2}(t, X_t)dX_t\cdot dX_t
\end{align}\]</span></p>
<p>and the Ito formula for function <span
class="math inline">\(f\)</span> of two state variables can be rewritten
as</p>
<p><span class="math display">\[\begin{align}
df(t,X_t, Y_t)
&amp;= \frac{\partial f}{\partial t}(t,X_t,Y_t)dt + \frac{\partial
f}{\partial x}(t, X_t, Y_t)dX_t + \frac{1}{2}\frac{\partial ^2
f}{\partial x^2}(t, X_t, Y_t)(dX_t))^2 \\
&amp;+\frac{\partial f}{\partial y}(t, X_t, Y_t)d_t +
\frac{1}{2}\frac{\partial ^2 f}{\partial y^2}(t, X_t, Y_t)(dY_t)^2 +
\frac{\partial ^2 f}{\partial x \partial y}(t,X_t,Y_t)(dX_t\cdot dY_t)
\end{align}\]</span></p>
<p>where <span class="math inline">\((dX_t)^2 = |u_t|^2dt\)</span>,
<span class="math inline">\((dY_t)^2=|a_t|^2dt\)</span> and <span
class="math inline">\(dX_t\cdot dY_t = u_ta_tdt\)</span></p>
<h2 id="solving-a-geometric-brownian-motion">Solving a Geometric
Brownian Motion</h2>
<h2 id="geometric-brownian-motion-gbm">Geometric Brownian motion
(GBM)</h2>
<p>A <strong>geometric Brownian motion (GBM)</strong> (also known as
<strong>exponential Brownian motion</strong>)</p>
<p>A stochastic process <span class="math inline">\(S_t\)</span> is said
to follow a <strong>GBM</strong> if it satisfies the following (SDE) [<a
href="https://en.wikipedia.org/w/index.php?title=Geometric_Brownian_motion&amp;oldid=1161374200">link</a>]:
<span class="math display">\[
dS_t = \mu S_t dt + \sigma S_t dW_t
\]</span> where <span class="math inline">\(W_t\)</span> is a Wiener
process or Brownian motion</p>
<p>and <span class="math inline">\(\mu\)</span> ('the percentage drift')
and <span class="math inline">\(\sigma\)</span> ('the percentage
volatility') are constants.</p>
<blockquote>
<p>The former parameter is used to model deterministic trends,</p>
<p>while the latter parameter models unpredictable events occurring
during the motion.</p>
</blockquote>
<h2 id="solving-step-by-step">solving step by step</h2>
<p>[<a href="https://youtu.be/y0s2GXREymI">Quant Guild</a>]</p>
<p>Given the stochastic differential equation <span
class="math display">\[
dS_t = \mu S_t dt + \sigma S_t dW_t, \quad t\in[t_0, T]
\]</span> that represents the dynamics of a stock process, it is
desirable to recover the function for simulation.</p>
<p>First, recall <strong>Ito lemma</strong> where <span
class="math inline">\(y(t, X_t)\)</span> represents a time-dependent
function of a stochastic process <span class="math display">\[
dy(t,X_t) = \frac{\partial y}{\partial t}dt + \frac{\partial y}{\partial
X_t}dX_t + \frac{1}{2}\frac{\partial ^2 y}{\partial X_t^2}(dX_t)^2
\]</span> Now, consider the following log transformation of the stock
process <span class="math display">\[
g(S_t) = \ln(S_t)
\]</span> We can apply Ito lemma to the log transformation function
<span class="math display">\[
dg(S_t) = \frac{\partial g}{\partial t}dt + \frac{\partial g}{\partial
S_t}dS_t +\frac{1}{2}\frac{\partial ^2 g}{\partial X_t^2}(dX_t)^2
\]</span> It follows from <span class="math inline">\(g(S_t) =
\ln(S_t)\)</span> and <span class="math inline">\(dS_t = \mu S_t dt +
\sigma S_t dW_t\)</span> with <em>Ito multiplication table</em> <span
class="math display">\[\begin{align}
\frac{\partial g}{\partial t} &amp;= 0 \\
\frac{\partial g}{\partial S_t} &amp;= \frac{1}{S_t} \\
\frac{\partial ^2  g}{\partial S_t ^2} &amp;= -\frac{1}{S_t^2} \\
(dX_t)^2 &amp;= 0 + 0 + \sigma^2S_t^2(dW_t)^2 = \sigma^2S_t^2dt
\end{align}\]</span></p>
<p>By substitution of these results into <span
class="math inline">\(dg(S_t) = \frac{\partial g}{\partial t}dt +
\frac{\partial g}{\partial S_t}dS_t +\frac{1}{2}\frac{\partial ^2
y}{\partial X_t^2}(dX_t)^2\)</span>, we obtain <span
class="math display">\[\begin{align}
dg(S_t) &amp;= 0 + \frac{1}{S_t}(\mu S_t dt + \sigma S_t dW_t) +
\frac{1}{2}(-\frac{1}{S_t^2})\sigma^2S_t^2dt \\
&amp;= \mu dt + \sigma dW_t - \frac{1}{2}\sigma^2 dt \\
&amp;= \left(\mu - \frac{1}{2}\sigma^2\right) + \sigma dW_t
\end{align}\]</span></p>
<p>We can now integrate both sides <span class="math display">\[
\int_{t_0}^Tdg(S_t) = \int_{t_0}^T \left(\mu -
\frac{1}{2}\sigma^2\right)dt + \int_{t_0}^T\sigma dW_t
\]</span></p>
<p><span class="math display">\[
g(S_t) - g(S_{t_0}) = \left(\mu - \frac{1}{2}\sigma^2\right)(T - {t_0})
+ \sigma(W_T - W_{t_0})
\]</span></p>
<p>Let's substitute <span class="math inline">\(g(S_t) =
\ln(S_t)\)</span> into above equation <span class="math display">\[
\ln(S_t) - \ln(S_{t_0}) = \left(\mu - \frac{1}{2}\sigma^2\right)(T -
{t_0}) + \sigma(W_T - W_{t_0})
\]</span> after arranging, the closed form solution is <span
class="math display">\[
S_T = S_{t_0}e^{(\mu-\frac{1}{2}\sigma^2)(T-t_0)+\sigma(W_T-W_{t_0})}
\]</span></p>
<h2 id="paper">paper</h2>
<p>A. Demir, A. Mehrotra and J. Roychowdhury, "Phase noise in
oscillators: a unifying theory and numerical methods for
characterization," in IEEE Transactions on Circuits and Systems I:
Fundamental Theory and Applications, vol. 47, no. 5, pp. 655-674, May
2000, doi: 10.1109/81.847872. [<a
href="https://www.researchgate.net/profile/Jaijeet-Roychowdhury/publication/3774912_Phase_noise_in_oscillators_a_unifying_theory_and_numerical_methods_for_characterisation/links/56436c0308ae54697fb2e543/Phase-noise-in-oscillators-a-unifying-theory-and-numerical-methods-for-characterisation.pdf">pdf</a>]</p>
<p>demir, Alper. (2000). Floquet theory and non-linear perturbation
analysis for oscillators with differential-algebraic equations.
International Journal of Circuit Theory and Applications - INT J CIRCUIT
THEOR APPL. 28. 163-185.
10.1002/(SICI)1097-007X(200003/04)28:23.0.CO;2-K.</p>
<h2 id="book">book</h2>
<p>⭐ Levy, Bernard. (2020). <strong>Random Processes with Applications
to Circuits and Communications</strong>. 10.1007/978-3-030-22297-0.</p>
<p>Sundararajan, D.. (2023). <strong>Signals and Systems: A Practical
Approach</strong>. 10.1007/978-3-031-19377-4.</p>
<p>Øksendal, Bernt. (2000). <strong>Stochastic Differential Equations:
An Introduction with Applications</strong>.
10.1007/978-3-662-03185-8.</p>
<p>Chicone, Carmen Charles. <strong>Ordinary Differential Equations with
Applications. 2nd ed</strong>. New York ; Berlin: Springer, 2006.</p>
<p>⭐ Stanley H. Chan (2021). <strong>Introduction to Probability for
Data Science</strong>. Michigan Publishing, [<a
href="https://probability4datascience.com/index.html">link</a>]</p>
<p>Simo Särkkä and Arno Solin (2019). <strong>Applied Stochastic
Differential Equations</strong>. Cambridge University Press. Cambridge,
UK. [<a href="https://github.com/AaltoML/SDE">link</a>]</p>
<p>Gerald Teschl, <strong>Ordinary Differential Equations and Dynamical
Systems</strong> A.M.S., 2012</p>
<p>Kurt Bryan; Brian Winkel (2020), "2021-Bryan, Kurt - SIMIODE Online
Digital Textbook - <strong>Differential Equations: A Toolbox for
Modeling the World</strong>.,"
https://www.simiode.org/resources/8208.</p>
<p>Jordan, D.W. and Smith, P. (2007) <strong>Nonlinear Ordinary
Differential Equations: An Introduction for Scientists and Engineers.
4th Edition</strong>, Oxford University Press, New York.</p>
<p>Strogatz, S.H. (2015). <strong>Nonlinear Dynamics and Chaos: With
Applications to Physics, Biology, Chemistry, and Engineering (2nd
ed.)</strong>. CRC Press. https://doi.org/10.1201/9780429492563</p>
<p>⭐ Nicolas Privault. <strong>Introduction to Stochastic Finance with
Market Examples, Second Edition</strong>, Chapman &amp; Hall/CRC
Financial Mathematics Series, 2022</p>
<p>⭐ Nicolas Privault. <strong>MH4514 Financial Mathematics</strong>
[<a href="https://personal.ntu.edu.sg/nprivault/indext.html">link</a>,
<a
href="https://drive.google.com/file/d/1iCsMdtJctWK2fo65WP5iqNvQ73acObzU">MH4514_notes</a>]</p>
<p>Evans, Lawrence C.. <strong>Stochastic differential equations version
1.2</strong> [<a
href="https://www.cmor-faculty.rice.edu/~cox/stoch/SDE.course.pdf">pdf</a>]</p>
<p>Evans, Lawrence C.. <strong>An Introduction to Stochastic
Differential Equations.</strong> (2014).</p>
<p>⭐ Matt Charnley. <strong>Differential Equations: An Introduction for
Engineers</strong> [<a
href="https://sites.rutgers.edu/matthew-charnley/course-materials/differential-equations-an-introduction-for-engineers/">link</a>]</p>
<p>⭐ Jiří Lebl. <strong>Notes on Diffy Qs: Differential Equations for
Engineers</strong> [<a
href="https://www.jirka.org/diffyqs/">link</a>]</p>
<h2 id="measure-theoretic-probability-theory">measure-theoretic
probability theory</h2>
<p>Jacod, J., &amp; Protter, P. (2004). <strong>Probability Essentials
(Second edition.)</strong>. Springer Berlin Heidelberg.</p>
<p>Sebastien Roch, UW-Madison. <strong>Lecture Notes on
Measure-theoretic Probability Theory</strong> [<a
href="https://people.math.wisc.edu/~roch/grad-prob/index.html">link</a>]</p>
<p>Matthew N. Bernstein <strong>Demystifying measure-theoretic
probability theory</strong> [<a
href="https://mbernste.github.io/posts/self_info/">part1</a>, <a
href="https://mbernste.github.io/posts/measure_theory_2/">part2</a>, <a
href="https://mbernste.github.io/posts/measure_theory_3/">part3</a>]</p>
<p>Edwin Chen. <strong>Layman's Introduction to Measure Theory</strong>
[<a
href="https://blog.echen.me/2011/03/14/laymans-introduction-to-measure-theory/">link</a>]</p>
<p>Ales Cerný. <strong>Mathematical Techniques in Finance: Tools for
Incomplete Markets - Second Edition</strong></p>
<h2 id="blogs">blogs</h2>
<p>⭐ Prof. Dr. Maxim Ulrich, KIT. <strong>Stochastic Calculus:
Basics</strong> [<a
href="https://youtube.com/playlist?list=PLyQSjcv8LwAEdNgdVnNH02-JTJfrwCt81">https://youtube.com/playlist?list=PLyQSjcv8LwAEdNgdVnNH02-JTJfrwCt81</a>]</p>
<p>⭐ Lewis Smith. <strong>Itô and Stratonovich; a guide for the
perplexed</strong> [<a
href="https://www.robots.ox.ac.uk/~lsgs/posts/2018-09-30-ito-strat.html">https://www.robots.ox.ac.uk/~lsgs/posts/2018-09-30-ito-strat.html)</a>]</p>
<p>布朗运动、伊藤引理、BS 公式（前篇） [<a
href="https://zhuanlan.zhihu.com/p/38293827">https://zhuanlan.zhihu.com/p/38293827</a>]</p>
<p>Wiener Process <span class="math inline">\(dB^2=dt\)</span> [<a
href="https://math.stackexchange.com/q/81865/1059887">https://math.stackexchange.com/q/81865/1059887</a>]</p>
<p>Professor Steve Lalley Statistics 385: Brownian Motion and Stochastic
Calculus Fall 2016 [<a
href="https://galton.uchicago.edu/~lalley/Courses/385/">https://galton.uchicago.edu/~lalley/Courses/385/</a>]</p>
<p>18.S096 | Fall 2013 | Undergraduate MIT. Topics In Mathematics With
Applications In Finance [<a
href="https://ocw.mit.edu/courses/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/pages/syllabus/">https://ocw.mit.edu/courses/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/pages/syllabus/</a>]</p>
<p>Mathuranathan, Power and Energy of a Signal : Demystified URL: <a
href="https://www.gaussianwaves.com/2013/12/power-and-energy-of-a-signal/">https://www.gaussianwaves.com/2013/12/power-and-energy-of-a-signal/</a></p>
<p>White Noise : Simulation and Analysis using Matlab gaussianwaves.com
[<a
href="https://www.gaussianwaves.com/2013/11/simulation-and-analysis-of-white-noise-in-matlab/">https://www.gaussianwaves.com/2013/11/simulation-and-analysis-of-white-noise-in-matlab/)</a>]</p>
<p>Prof. J. Nathan Kutz AMATH 568 Advanced Differential Equations:
Asymptotics &amp; Perturbations [<a
href="https://faculty.washington.edu/kutz/am568/am568.html">https://faculty.washington.edu/kutz/am568/am568.html</a>]</p>
<p>Asymptotics and perturbation methods - Prof. Steven Strogatz [<a
href="https://youtube.com/playlist?list=PL5EH0ZJ7V0jV7kMYvPcZ7F9oaf_YAlfbI">https://youtube.com/playlist?list=PL5EH0ZJ7V0jV7kMYvPcZ7F9oaf_YAlfbI)</a>]
via <span class="citation" data-cites="YouTube">@YouTube</span></p>
<p>Simo Särkkä and Arno Solin (2014). <strong>Applied Stochastic
Differential Equations</strong>. <em>Lecture notes of the course
Becs-114.4202 Special Course in Computational Engineering II held in
Autumn 2014</em>. (<a
href="https://users.aalto.fi/~ssarkka/course_s2014/sde_course_booklet.pdf">Booklet
as PDF</a>, <a
href="https://users.aalto.fi/~ssarkka/course_s2014/">Slides and
exercises</a>). (2012 material is <a
href="https://users.aalto.fi/~ssarkka/course_s2012/pdf/">here</a>).</p>
<p>Ben Chugg. Itô Integral: Construction and Basic Properties [<a
href="https://benchugg.com/research_notes/intro_ito/">https://benchugg.com/research_notes/intro_ito/</a>]</p>
<p>Ben Chugg. Itô Processes and The Fundamental Theorem of Stochastic
Calculus [<a
href="https://benchugg.com/research_notes/sde_ito_lemma/">https://benchugg.com/research_notes/sde_ito_lemma/)</a>]</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Parallel Compensation in Two stage amplifier</title>
    <url>/2022/03/07/parallel-compensation/</url>
    <content><![CDATA[<blockquote>
<p><strong>Parallel Compensation</strong> is also known as <strong>Lead
Compensation</strong>, <strong>Pole-Zero Compensation</strong></p>
</blockquote>
<p><img
src="/2022/03/07/parallel-compensation/image-20220307234938855.png"
alt="image-20220307234938855" /></p>
<p><strong>Note</strong>: The dominant pole is at output of the first
stage, i.e. <span
class="math inline">\(\frac{1}{R_{EQ}C_{EQ}}\)</span>.</p>
<p><img
src="/2022/03/07/parallel-compensation/image-20221006001114562.png"
alt="image-20221006001114562" /></p>
<h4 id="pole-and-zero-in-transfer-function">Pole and Zero in transfer
function</h4>
<blockquote>
<p>Design with operational amplifiers and analog integrated circuits /
Sergio Franco, San Francisco State University. – Fourth edition</p>
</blockquote>
<p><img
src="/2022/03/07/parallel-compensation/image-20221005220854411.png"
alt="image-20221005220854411" /></p>
<p><span class="math display">\[
Y = \frac{1}{R_1} + sC_1+\frac{1}{R_c+1/SC_c}
\]</span></p>
<p><span class="math display">\[\begin{align}
Z &amp;= \frac{1}{\frac{1}{R_1} + sC_1+\frac{1}{R_c+1/SC_c}} \\
&amp;= \frac{R_1(1+sR_cC_c)}{s^2R_1C_1R_cC_c+s(R_1C_c+R_1C_1+R_cC_c)+1}
\end{align}\]</span> If <span class="math inline">\(p_{1c} \ll
p_{3c}\)</span>, two real roots can be found <span
class="math display">\[\begin{align}
p_{1c} &amp;= \frac{1}{R_1C_c+R_1C_1+R_cC_c} \\
p_{3c} &amp;= \frac{R_1C_c+R_1C_1+R_cC_c}{R_1C_1R_cC_c}
\end{align}\]</span></p>
<p>The additional zero is <span class="math display">\[
z_c = \frac{1}{R_cC_c}
\]</span> Given <span class="math inline">\(R_c \ll R\)</span> and <span
class="math inline">\(C_c \gg C\)</span> <span
class="math display">\[\begin{align}
p_{1c} &amp;\simeq \frac{1}{R_1(C_c+C_1)} \simeq \frac{1}{R_1C_c}\\
p_{3c} &amp;= \frac{1}{R_cC_1}+\frac{1}{R_cC_c}+\frac{1}{R_1C_1} \simeq
\frac{1}{R_cC_1}
\end{align}\]</span></p>
<p>The output pole is unchanged, which is <span class="math display">\[
p_2 = \frac{1}{R_LC_L}
\]</span> We usually <strong>cancel</strong> <span
class="math inline">\(p_2\)</span> with <span
class="math inline">\(z_c\)</span>, i.e. <span class="math display">\[
R_cC_c=R_LC_L
\]</span></p>
<h4 id="phase-margin">Phase margin</h4>
<p>unity-gain frequency <span class="math inline">\(\omega_t\)</span>
<span class="math display">\[
\omega_t = A_\text{DC}\cdot P_{1c} =\frac{g_{m1}g_{m2}R_L}{C_c}
\]</span></p>
<ol type="1">
<li><p>PM=45<span class="math inline">\(^o\)</span> <span
class="math display">\[
p_{3c} = \omega_t
\]</span> Then, <span class="math inline">\(C_c\)</span> and <span
class="math inline">\(R_c\)</span> can be obtained</p>
<p><span class="math display">\[\begin{align}
   R_c &amp;= \sqrt{\frac{R_1}{C_1\cdot A_{DC}\cdot
p_2}}=\sqrt{\frac{R_1\cdot R_LC_L}{C_1\cdot A_{DC}}} \\
C_c &amp;= \sqrt{\frac{A_{DC}\cdot C_1}{R_1\cdot
p_2}}=\sqrt{\frac{A_{DC}\cdot C_1 \cdot R_LC_L}{R_1}}
\end{align}\]</span></p></li>
<li><p>PM=60<span class="math inline">\(^o\)</span> <span
class="math display">\[
p_{3c} = 2\cdot\omega_t
\]</span> Then, <span class="math inline">\(C_c\)</span> and <span
class="math inline">\(R_c\)</span> can be obtained <span
class="math display">\[\begin{align}
   R_c &amp;= \sqrt{\frac{R_1}{C_1\cdot 2A_{DC}\cdot p_2}} =
\sqrt{\frac{R_1\cdot R_LC_L}{C_1\cdot 2A_{DC}}} \\
   &amp;= \sqrt{\frac{C_L}{2g_{m1}g_{m2}C_1}}\\
C_c &amp;= \sqrt{\frac{2A_{DC}\cdot C_1}{R_1\cdot p_2}} =
\sqrt{\frac{2A_{DC}\cdot C_1 \cdot R_LC_L}{R_1}} \\
&amp;= R_L\sqrt{2g_{m1}g_{m2}C_1C_L}
\end{align}\]</span></p>
<p>for the unity-gain frequency <span
class="math inline">\(\omega_t\)</span> we find <span
class="math display">\[
\omega_t = \sqrt{\frac{1}{2}\cdot \frac{g_{m1}g_{m2}}{C_1C_L}}
\]</span> The parallel compensation shows a remarkably good result. The
new 0 dB frequency lies only a factor <span
class="math inline">\(\sqrt{2}\)</span> lower than the theoretical
maximum</p></li>
</ol>
<blockquote>
<p>To increase <span class="math inline">\(\phi_m\)</span>, we need to
<strong>raise</strong> <span class="math inline">\(C_c\)</span> a bit
while <strong>lowering</strong> <span class="math inline">\(R_c\)</span>
in proportion in order to maintain pole-zero cancellation. This causes
<span class="math inline">\(p_{1c}\)</span> and <span
class="math inline">\(p_{3c}\)</span> to split a bit further apart.</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line"></span><br><span class="line">fd = <span class="number">84</span>*<span class="number">1e3</span>;	<span class="comment">% dominant freq, unit: Hz</span></span><br><span class="line">fnd = <span class="number">3.25</span>*<span class="number">1e6</span>;	<span class="comment">% unit: Hz</span></span><br><span class="line">C = <span class="number">478</span>*<span class="number">1e-15</span>;</span><br><span class="line">R = <span class="number">1</span>/fd/(<span class="number">2</span>*<span class="built_in">pi</span>)/C;</span><br><span class="line">Adc = <span class="number">10</span>^(<span class="number">80</span>/<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">ri = <span class="number">2</span>; <span class="comment">% PM=45: 1;  PM=60: 2</span></span><br><span class="line">Rc = (R/C/fnd/<span class="number">2</span>/<span class="built_in">pi</span>/ri/Adc)^<span class="number">0.5</span>; <span class="comment">% compensation resistor</span></span><br><span class="line">Cc = (ri*Adc*C/fnd/<span class="number">2</span>/<span class="built_in">pi</span>/R)^<span class="number">0.5</span>; <span class="comment">% compensation capacitor</span></span><br><span class="line"></span><br><span class="line">wzc = <span class="number">1</span>/<span class="number">2</span>/<span class="built_in">pi</span>/Rc/Cc; <span class="comment">% zero frequency</span></span><br></pre></td></tr></table></figure>
<h4 id="reference">reference</h4>
<p>Viola Schäffer, Designing Amplifiers for Stability, ISSCC 2021
Tutorials</p>
<p>R.Eschauzier "Wide Bandwidth Low Power Operational Amplifiers", Delft
University Press, 1994.</p>
<p>Gene F. Franklin, J. David Powell, and Abbas Emami-Naeini. 2018.
Feedback Control of Dynamic Systems (8th Edition) (8th. ed.). Pearson.
6.7 Compensation</p>
<p>Application Note AN-1286 Compensation for the LM3478 Boost
Controller</p>
<p>ECEN 607 Advanced Analog Circuit Design Techniques Spring 2017 URL:
<a
href="https://people.engr.tamu.edu/s-sanchez/Lec_for_607_stability%20Jan27.pdf">Lect
1D Op-Amps Stability and Frequency Compensation Techniques</a></p>
<p>Sergio Franco, San Francisco State University, Design with
Operational Amplifiers and Analog Integrated Circuits, 4/e</p>
<p>J. H. Huijsing, 6.2.2.1 Two-GA-stage Parallel Compensation (PC),
"Operational Amplifiers, Theory and Design, 3rd ed. New York: Springer,
2017"</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>PERC</title>
    <url>/2023/11/04/perc/</url>
    <content><![CDATA[<ul>
<li><p>CD: current density checks</p></li>
<li><p>P2P: point to point resistance checks</p></li>
<li><p>LDL: logic driven layout checks, latch up related</p></li>
<li><p>TOPO: topology, circuit connection and device size
checks</p></li>
</ul>
<blockquote>
<p>database</p>
<ul>
<li><p>CD, P2P, LDL : dfmdb</p></li>
<li><p>TOPO: svdb</p></li>
</ul>
</blockquote>
<h2 id="references">references</h2>
<p>Frank Feng. New Approach For Full Chip Electrical Reliability
Verification [<a
href="https://cse.nsysu.edu.tw/app/index.php?Action=downloadfile&amp;file=WVhSMFlXTm9MelV3TDNCMFlWOHhOamN6TnpWZk5qYzFNVGd6TjE4NE5ESXlOQzV3WkdZPQ==&amp;fname=1454FCFGGCPO45YTNOJCJGJGMKPKHC3534FG35YSA1GDXWFC34QOA0OOQOOKZWCDSSPOGDMP20NO4124YWB4B4LKYSMOQL0400YT34PKUWNK20FG00POUSXXYWXWOO15JCLKSWXWDCOKHG2050JCQKHCXTNPNOVSUSB4JCVW20HGJGTTWW40ZXIH5004A4GDMKJG5020OPMOJDLOML51NOFCSWROB454DGKKFCSTGCDCTXNPA4TWRKGDWW30CGKKDGB0YWLKIH05ML44WSFGQOTWOOECYWGHRKCCDD15A4XSFC14FCJGOO25WXROQLNK00JD31PKWSEC50A4SSOKHHTT">pdf</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Periodic Analysis</title>
    <url>/2023/10/28/periodic/</url>
    <content><![CDATA[<h1 id="pss-and-hb-overview">PSS and HB Overview</h1>
<p>The steady-state response is the response that results after any
transient effects have dissipated.</p>
<p><strong>The large signal solution is the starting point for
small-signal analyses</strong>, including periodic AC, periodic transfer
function, periodic noise, periodic stability, and periodic scattering
parameter analyses.</p>
<blockquote>
<p>Designers refer periodic steady state analysis in <em>time
domain</em> as <strong>"PSS"</strong> and corresponding <em>frequency
domain</em> notation as <strong>"HB"</strong></p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231028163033255.png"
alt="image-20231028163033255" /></p>
<h1 id="harmonic-balance-analysis">Harmonic Balance Analysis</h1>
<p>The idea of harmonic balance is to find a set of port voltage
waveforms (or, alternatively, the harmonic voltage components) that give
the same currents in both the <em>linear-network equations</em> and
<em>nonlinear-network equations</em></p>
<blockquote>
<p>that is, the currents satisfy Kirchoff's current law</p>
</blockquote>
<p>Define an <strong>error function</strong> at <em>each harmonic</em>,
<span class="math inline">\(f_k\)</span>, where <span
class="math display">\[
f_k = I_{\text{LIN}}(k\omega) + I_{\text{NL}}(k\omega)
\]</span> where <span class="math inline">\(k=0, 1, 2,...,K\)</span></p>
<blockquote>
<p>Note that each <span class="math inline">\(f_k\)</span> is implicitly
a function of all voltage components <span
class="math inline">\(V(k\omega)\)</span></p>
</blockquote>
<h2 id="newton-solution-of-the-harmonic-balance-equation">Newton
Solution of the Harmonic-Balance Equation</h2>
<h3 id="iterative-process-and-jacobian-formulation">Iterative Process
and Jacobian Formulation</h3>
<p><img src="/2023/10/28/periodic/image-20231108222451147.png"
alt="image-20231108222451147" /></p>
<p>The elements of the Jacobian are the derivatives <span
class="math display">\[
\frac{\partial F_{\text{n,k}}}{\partial _{\text{m,l}}}
\]</span> where <span class="math inline">\(n\)</span> and <span
class="math inline">\(m\)</span> are the port indices <span
class="math inline">\((1,N)\)</span>, and <span
class="math inline">\(k\)</span> and <span
class="math inline">\(l\)</span> are the harmonic indices <span
class="math inline">\((0,...,K)\)</span></p>
<h3 id="selecting-the-number-of-harmonics-and-time-samples">Selecting
the Number of Harmonics and Time Samples</h3>
<p>In theory, the waveforms generated in nonlinear analysis have an
infinite number of harmonics, so a complete description of the operation
of a <strong>nonlinear</strong> circuit would appear to require current
and voltage vectors of <em>infinite</em> dimension.</p>
<p>Fortunately, the magnitudes of frequency components invariably
decrease with frequency; otherwise the time wavefroms would represent
infinite power.</p>
<h3 id="initial-estimate">Initial Estimate</h3>
<p>One important property of Newton's method is that its speed and
reliability of convergence depend strongly upon the initial estimate of
the solution vector.</p>
<h1 id="shooting-newton">Shooting Newton</h1>
<h1 id="nonlinearity-linear-time-varying-nature">Nonlinearity &amp;
Linear Time-Varying Nature</h1>
<h2 id="nonlinearity-nature">Nonlinearity Nature</h2>
<p>The nonlinearity causes the signal to be replicated at multiples of
the carrier, an effect referred to as <strong>harmonic
distortion</strong>, and adds a skirt to the signal that increases its
bandwidth, an effect referred to as <strong>intermodulation
distortion</strong></p>
<p><img src="/2023/10/28/periodic/image-20231029093504162.png"
alt="image-20231029093504162" /></p>
<blockquote>
<p>It is possible to eliminate the effect of <em>harmonic
distortion</em> with a bandpass filter, however the frequency of the
<em>intermodulation distortion</em> products overlaps the frequency of
the desired signal, and so cannot be completely removed with
filtering.</p>
</blockquote>
<h2 id="time-varying-linear-nature">Time-Varying Linear Nature</h2>
<p><img src="/2023/10/28/periodic/image-20231029101042671.png"
alt="image-20231029101042671" /></p>
<blockquote>
<p><strong>linear</strong> with respect to <span
class="math inline">\(v_{in}\)</span> and
<strong>time-varying</strong></p>
</blockquote>
<p>Given <span class="math inline">\(v_{in}(t)=m(t)\cos (\omega_c
t)\)</span> and LO signal of <span
class="math inline">\(\cos(\omega_{LO} t)\)</span>, then <span
class="math display">\[
v_{out}(t) = \text{LPF}\{m(t)\cos(\omega_c t)\cdot \cos(\omega_{LO} t)\}
\]</span> and <span class="math display">\[
v_{out}(t) = m(t)\cos((\omega_c - \omega_{LO})t)
\]</span></p>
<blockquote>
<p>A <em>linear periodically-varying</em> transfer function implements
<em>frequency translation</em></p>
</blockquote>
<h1 id="periodic-small-signal-analyses">Periodic small signal
analyses</h1>
<p><img src="/2023/10/28/periodic/image-20231108231145369.png"
alt="image-20231108231145369" /></p>
<h2 id="analysis-in-simulator">Analysis in Simulator</h2>
<ol type="1">
<li>LPV analyses start by performing a periodic analysis to compute the
<strong>periodic operating point</strong> with only the <strong>large
clock signal</strong> applied (the LO, the clock, the carrier,
etc.).</li>
<li>The circuit is then <strong>linearized about this time-varying
operating point</strong> (expand about the periodic equilibrium point
with a Taylor series and discard all but the first-order term)</li>
<li>and the <strong>small information signal</strong> is applied. The
response is calculated using linear time-varying analysis</li>
</ol>
<blockquote>
<p>Versions of this type of small-signal analysis exists for both
harmonic balance and shooting methods</p>
</blockquote>
<blockquote>
<p>PAC is useful for predicting the output sidebands produced by a
particular input signal</p>
<p>PXF is best at predicting the input images for a particular
output</p>
</blockquote>
<h2 id="conversion-matrix-analysis">Conversion Matrix Analysis</h2>
<p><strong>Large-signal/small-signal analysis</strong>, or
<strong>conversion matrix analysis</strong>, is useful for a large class
of problems wherein a <strong>nonlinear device</strong> is driven, or
"pumped" by a <strong>single large sinusoidal signal</strong>; another
signal, much smaller, is applied; and we seek only the <strong>linear
response to the small signal</strong>.</p>
<blockquote>
<p>The most common application of this technique is in the design of
mixers and in nonlinear noise analysis</p>
</blockquote>
<ol type="1">
<li>First, analyzing the <strong>nonlinear device</strong> under
large-signal excitatin only, where the harmonic-balance method can be
applied</li>
<li>Then, the <strong>nonlinear elements</strong> in the device's
equivalent circuit are then <strong>linearized</strong> to create
<strong>small-signal, linear, time-varying elements</strong></li>
<li>Finally, a <strong>small-signal analysis</strong> is performed</li>
</ol>
<h3 id="element-linearized">Element Linearized</h3>
<p>Below shows a <strong>nonlinear resistive element</strong>, which has
the <span class="math inline">\(I/V\)</span> relationship <span
class="math inline">\(I=f(V)\)</span>. It is driven by a
<em>large-signal voltage</em></p>
<p><img src="/2023/10/28/periodic/image-20220511203515431.png"
alt="image-20220511203515431" /></p>
<p>Assuming that <span class="math inline">\(V\)</span> consists of the
sum of a large-signal component <span class="math inline">\(V_0\)</span>
and a small-signal component <span class="math inline">\(v\)</span>,
with Taylor series <span class="math display">\[
f(V_0+v) = f(V_0)+\frac{d}{dV}f(V)|_{V=V_0}\cdot
v+\frac{1}{2}\frac{d^2}{dV^2}f(V)|_{V=V_0}\cdot v^2+...
\]</span> The small-signal, incremental current is found by subtracting
the large-signal component of the current <span class="math display">\[
i(v)=I(V_0+v)-I(V_0)
\]</span> If <span class="math inline">\(v \ll V_0\)</span>, <span
class="math inline">\(v^2\)</span>, <span
class="math inline">\(v^3\)</span>,... are negligible. Then, <span
class="math display">\[
i(v) = \frac{d}{dV}f(V)|_{V=V_0}\cdot v
\]</span></p>
<blockquote>
<p><strong>linearized about this time-varying operating
point:</strong></p>
<p><strong>expand about the periodic equilibrium point with a Taylor
series and discard all but the first-order term</strong></p>
</blockquote>
<p><span class="math inline">\(V_0\)</span> need not be a DC quantity;
it can be a <strong>time-varying large-signal voltage</strong> <span
class="math inline">\(V_L(t)\)</span> and that <span
class="math inline">\(v=v(t)\)</span>, a function of time. Then</p>
<p><span class="math display">\[
i(t)=g(t)v(t)
\]</span> where <span
class="math inline">\(g(t)=\frac{d}{dV}f(V)|_{V=V_L(t)}\)</span></p>
<blockquote>
<p>The <em>time-varying</em> conductance <span
class="math inline">\(g(t)\)</span>, is the derivative of the element's
<span class="math inline">\(I/V\)</span> characteristic at the
<em>large-signal voltage</em></p>
<p>By an analogous derivation, one could have a current-controlled
resistor with the <span class="math inline">\(V/I\)</span>
characteristic <span class="math inline">\(V = f_R(I)\)</span> and
obtain the <em>small-signal</em> <span
class="math inline">\(v/i\)</span> relation <span
class="math display">\[
v(t) = r(t)i(t)
\]</span> where <span class="math inline">\(r(t) =
\frac{d}{dI}f_R(I)|_{I=I_L(t)}\)</span></p>
</blockquote>
<p>A <strong>nonlinear element</strong> excited by <em>two tones</em>
supports currents and voltages at mixing frequencies <span
class="math inline">\(m\omega_1+n\omega_w\)</span>, where <span
class="math inline">\(m\)</span> and <span
class="math inline">\(n\)</span> are integers. If one of those tones,
<span class="math inline">\(\omega_1\)</span> has such a <strong>low
level</strong> that it does not generate harmonics and the other is a
large-signal sinusoid at <span class="math inline">\(\omega_p\)</span>,
then the mixing frequencies are <span
class="math inline">\(\omega=\pm\omega_1+n\omega_p\)</span>, which shown
in below figure</p>
<p><img src="/2023/10/28/periodic/image-20231108223600922.png"
alt="image-20231108223600922" /></p>
<p>A more compact representation of the mixing frequencies is <span
class="math display">\[
\omega_n=\omega_0+n\omega_p
\]</span> which includes only half of the mixing frequencies:</p>
<ul>
<li>the negative components of the lower sidebands
(<strong>LSB</strong>)</li>
<li>and the positive components of the upper sidebands
(<strong>USB</strong>)</li>
</ul>
<p><img src="/2023/10/28/periodic/image-20220511211336437.png"
alt="image-20220511211336437" /></p>
<blockquote>
<p>For real signal, positive- and negative-frequency components are
complex conjugate pairs</p>
</blockquote>
<h3 id="conversion-mattrix-as-bridge">Conversion Mattrix as Bridge</h3>
<p>The <strong>frequency-domain</strong> currents and voltages in a
<strong>time-varying</strong> circuit element are related by a
<strong>conversion matrix</strong></p>
<p>The <em>small-signal</em> voltage and current can be expressed in the
frequency notation as <span class="math display">\[
v&#39;(t) = \sum_{n=-\infty}^{\infty}V_ne^{j\omega_nt}
\]</span> and <span class="math display">\[
i&#39;(t) = \sum_{n=-\infty}^{\infty}I_ne^{j\omega_nt}
\]</span> where <span class="math inline">\(v&#39;(t)\)</span> and <span
class="math inline">\(i&#39;(t)\)</span> are <strong>not</strong>
Fourier series, which includes only half of the mixing frequencies</p>
<p>The conductance waveform <span class="math inline">\(g(t)\)</span>
can be expressed by its <strong>Fourier series</strong> <span
class="math display">\[
g(t)=\sum_{n=-\infty}^{\infty}G_ne^{jn\omega_pt}
\]</span> Which is harmonics of <em>large-signal</em> <span
class="math inline">\(\omega_p\)</span></p>
<p>Then the voltage and current are related by Ohm's law <span
class="math display">\[
i&#39;(t)=g(t)v&#39;(t)
\]</span> Then <span class="math display">\[
\sum_{k=-\infty}^{\infty}I_ke^{j\omega_kt}=\sum_{n=-\infty}^{\infty}\sum_{m=-\infty}^{\infty}G_nV_me^{j\omega_{m+n}t}
\]</span></p>
<blockquote>
<p>A linear periodically-varying transfer function implements
<strong>frequency translation</strong></p>
</blockquote>
<h1 id="cyclostationary-noise-analysis">Cyclostationary Noise
Analysis</h1>
<blockquote>
<p>which is referred to as a "periodic noise" or PNoise analysis</p>
</blockquote>
<h2 id="white-noise">White Noise</h2>
<blockquote>
<p>completely <strong>uncorrelated</strong> versus time</p>
<p>For white noise the PSD is a constant and the autocorrelation
function is an impulse centered at <span
class="math inline">\(0\)</span>, <span
class="math inline">\(R_n(t,\tau)=R(t)\delta(\tau)\)</span></p>
<p>The energy-storage elements cause the noise spectrum to be shaped and
the noise to be time-correlated.</p>
<p>This is a general property. It the noise has shape in the frequency
domain then the noise is correlated in time, and vice versa.</p>
</blockquote>
<h2 id="pnoise">PNOISE</h2>
<ul>
<li><p>In LPTV analysis, noise may <em>up-convert</em> or
<em>down-convert</em> by <span class="math inline">\(N\cdot f_c\)</span>
(<strong>noise folding</strong>)</p></li>
<li><p>PNOISE output is <strong>cyclostationary noise</strong></p>
<p>Described by a collection of PSDs at various sidebands: 0 PSDs at
various sidebands: <span class="math inline">\(0, \pm f_c, \pm2f_c,
\pm3f_c\)</span>, …</p></li>
</ul>
<blockquote>
<p><span class="math inline">\(f_c\)</span>: fundamental frequency of
PSS</p>
</blockquote>
<h3 id="simulation-of-switched-capacitor-noise">Simulation of
switched-capacitor noise</h3>
<blockquote>
<p>Periodic steady-state analysis is originally intended to analyze a
continuous-time circuit with periodic input signals or excitations.</p>
</blockquote>
<p>To simulate a switched-capacitor circuit appropriately, one needs to
recognize that the <strong>output of a switched capacitor circuit is a
discrete-time</strong> rather than a continuous-time signal. This
discrete-time signal should be treated as the output of the circuit
sampled after it has settled to the final value for each sampling
period.</p>
<p>There are two techniques that one can use to force the simulator to
evaluate the output signal correctly in the manner described</p>
<ul>
<li><p>First, in more recent versions of SpectreRF, PNOISE analysis
provides a specialized time-domain analysis method</p>
<p>By enabling this option, the simulator would analyze noise only
<strong>at particular time instants</strong></p></li>
<li><p>Second, on older versions of spectreRF, <strong>an explicit
(ideal) sample-and-hold</strong> block can be used similarly to force
the simulator to evaluate only the output of the circuit at the
<strong>correct time instants</strong>.</p>
<blockquote>
<p>Recall that a sample-and-hold would impose a <em>zero-order hold</em>
on a discrete-time signal; thus, the resulting sinc-shaped response in
the frequency domain has to be compensated for</p>
</blockquote></li>
</ul>
<h1 id="linear-time-varying">Linear Time Varying</h1>
<p>The response of a relaxed LTV system at a time <span
class="math inline">\(t\)</span> due to an impulse applied at a time
<span class="math inline">\(t − \tau\)</span> is denoted by <span
class="math inline">\(h(t, \tau)\)</span></p>
<blockquote>
<p>The first argument in the impulse response denotes the time of
observation.</p>
<p>The second argument indicates that the system was excited by an
impulse launched at a time <span class="math inline">\(\tau\)</span>
<em>prior to</em> the time of observation.</p>
<p>Thus, the response of an LTV system not only depends on how long
before the observation time it was excited by the impulse but also on
the observation instant.</p>
<p>The output <span class="math inline">\(y(t)\)</span> of an initially
relaxed LTV system with impulse response <span
class="math inline">\(h(t, \tau)\)</span> is given by the convolution
integral <span class="math display">\[
y(t) = \int_0^{\infty}h(t,\tau)x(t-\tau)d\tau
\]</span> Assuming <span class="math inline">\(x(t) = e^{j2\pi f
t}\)</span> <span class="math display">\[
y(t) = \int_0^{\infty}h(t,\tau)e^{j2\pi f (t-\tau)}d\tau = e^{j2\pi f
t}\int_0^{\infty}h(t,\tau)e^{-j2\pi f\tau}d\tau
\]</span> The (<em>time-varying</em>) frequency response can be
interpreted as <span class="math display">\[
H(j2\pi f, t) = \int_0^{\infty}h(t,\tau)e^{-j2\pi f\tau}d\tau
\]</span> Linear Periodically Time-Varying (LPTV) Systems, which is a
special case of an LTV system whose impulse response satisfies <span
class="math display">\[
h(t, \tau) = h(t+T_s, \tau)
\]</span> In other words, the response to an impulse remains unchanged
if the time at which the output is observed (<span
class="math inline">\(t\)</span>) and the time at which the impulse is
applied (denoted by <span class="math inline">\(t_1\)</span>) are both
shifted by <span class="math inline">\(T_s\)</span> <span
class="math display">\[
H(j2\pi f, t+T_s) = \int_0^{\infty}h(t+T_s,\tau)e^{-j2\pi f\tau}d\tau =
\int_0^{\infty}h(t,\tau)e^{-j2\pi f\tau}d\tau = H(j2\pi f, t)
\]</span> <span class="math inline">\(H(j2\pi f, t)\)</span> of an LPTV
system is periodic with timeperiod <span
class="math inline">\(T_s\)</span>, it can be expanded as a Fourier
series in <span class="math inline">\(t\)</span>, resulting in <span
class="math display">\[
H(j2\pi f, t) = \sum_{k=-\infty}^{\infty} H_k(j2\pi f)e^{j2\pi f_s k t}
\]</span> The coefficients of the Fourier series <span
class="math inline">\(H_k(j2\pi f)\)</span> are given by <span
class="math display">\[
H_k(j2\pi f) = \frac{1}{T_s}\int_0^{T_s} H(j2\pi f, t) e^{-j2\pi k f_s
t}dt
\]</span></p>
</blockquote>
<h2 id="lti-and-ltv">LTI and LTV</h2>
<p><img src="/2023/10/28/periodic/image-20231104145535168.png"
alt="image-20231104145535168" /></p>
<h2 id="linear-and-periodically-time-varying">Linear and Periodically
Time Varying</h2>
<blockquote>
<p>Gain varies periodically with time</p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231104150000310.png"
alt="image-20231104150000310" /></p>
<p>Owing to <span class="math inline">\(H(j\omega, t) = H(j\omega,
t+T_s)\)</span>, <span class="math inline">\(H(j\omega,t)\)</span> can
be expanded in a <strong>Fourier Series</strong> <span
class="math display">\[
H(j\omega,t) = \sum_k H_k(j\omega)e^{jk\omega _s t}
\]</span> <img
src="/2023/10/28/periodic/image-20231104152637888.png" /></p>
<h3 id="response-of-an-lptv-system">Response of an LPTV System</h3>
<p><img src="/2023/10/28/periodic/image-20231104153142972.png"
alt="image-20231104153142972" /></p>
<p><img src="/2023/10/28/periodic/image-20231104153625881.png"
alt="image-20231104153625881" /></p>
<h3 id="harmonic-transfer-functions">Harmonic Transfer Functions</h3>
<p><img src="/2023/10/28/periodic/image-20231104155412790.png"
alt="image-20231104155412790" /></p>
<p><img src="/2023/10/28/periodic/image-20231104155447057.png"
alt="image-20231104155447057" /></p>
<blockquote>
<p>Harmonic Transfer Functions can be found using <em>PAC</em>
analysis</p>
</blockquote>
<h3 id="summary">Summary</h3>
<p><img src="/2023/10/28/periodic/image-20231104155732917.png"
alt="image-20231104155732917" /></p>
<p><img src="/2023/10/28/periodic/image-20231104155942718.png"
alt="image-20231104155942718" /></p>
<h2 id="sampled-lptv">Sampled LPTV</h2>
<p><img src="/2023/10/28/periodic/image-20231105175749755.png"
alt="image-20231105175749755" /></p>
<p>Move sampler before summation</p>
<p><img src="/2023/10/28/periodic/image-20231105174949907.png"
alt="image-20231105174949907" /></p>
<blockquote>
<p>Owing to <span class="math display">\[
k\omega_sT_sn=kn\cdot2\pi
\]</span> We get <span class="math display">\[
e^{jk\omega_s T_s n} = e^{jkn\cdot 2\pi} = 1
\]</span></p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231105172503777.png"
alt="image-20231105172503777" /></p>
<blockquote>
<p>LPTV system sampled at <span class="math inline">\(T_s\)</span> is
equivalent to LTI system sampled at <span
class="math inline">\(T_s\)</span></p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231105172615426.png"
alt="image-20231105172615426" /></p>
<p><img src="/2023/10/28/periodic/image-20231105173646462.png"
alt="image-20231105173646462" /></p>
<blockquote>
<p><span class="math display">\[
H_{\text{eq}}(j\omega) = \sum_k H_k(j\omega)
\]</span></p>
<p>The result derived above makes intuitive sense due to the
following.</p>
<p>When an <strong>LPTV</strong> system is excited by a tone at <span
class="math inline">\(f\)</span> , the output comprises of tones at
frequencies <span class="math inline">\(f + k f_s\)</span>, where <span
class="math inline">\(k\)</span> is an integer. When sampled at <span
class="math inline">\(f_s\)</span>, frequency components higher than
<span class="math inline">\(f_s\)</span> are aliased to <span
class="math inline">\(f\)</span> . Thus, if one is only interested in
the samples of the system's output, they could as well be produced by a
properly chosen <strong>LTI</strong> filter acting on an input tone at a
frequency <span class="math inline">\(f\)</span> .</p>
<p>Note that the equivalence holds only for samples, and not for the
waveforms. <span class="math inline">\(y(nT_s) = \hat{y}(nT_s)\)</span>,
but <span class="math inline">\(y(t)\)</span> need not equal <span
class="math inline">\(\hat{y}(t)\)</span></p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231105173847572.png"
alt="image-20231105173847572" /></p>
<h2 id="finding-the-equivalent-filter">Finding the Equivalent
Filter</h2>
<blockquote>
<p>Frequency Domain Approach <span
class="math inline">\(H_{eq}(j\omega)=\sum_k H_k(j\omega)\)</span></p>
<p>Wasted effort in computing all <span
class="math inline">\(H_k\)</span> first and then adding them up.</p>
</blockquote>
<p>We prefer to employ Time Domain Approaches</p>
<p><img src="/2023/10/28/periodic/image-20231105221411598.png"
alt="image-20231105221411598" /></p>
<h3 id="reciprocity">Reciprocity</h3>
<p><img src="/2023/10/28/periodic/image-20231105223906470.png"
alt="image-20231105223906470" /></p>
<blockquote>
<p>Does not work with <em>controlled sources</em></p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231105224203744.png"
alt="image-20231105224203744" /></p>
<h3 id="interreciprocity">Interreciprocity</h3>
<blockquote>
<p>Handle <em>controlled sources</em></p>
</blockquote>
<p><img src="/2023/10/28/periodic/image-20231105225346724.png"
alt="image-20231105225346724" /></p>
<p><img src="/2023/10/28/periodic/image-20231105225359292.png"
alt="image-20231105225359292" /></p>
<table>
<thead>
<tr class="header">
<th>origin</th>
<th>transformer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VCVS</td>
<td>CCCS</td>
</tr>
<tr class="even">
<td>CCCS</td>
<td>VCVS</td>
</tr>
<tr class="odd">
<td>VCCS</td>
<td>VCCS</td>
</tr>
<tr class="even">
<td>CCVS</td>
<td>CCVS</td>
</tr>
</tbody>
</table>
<h1 id="reference">reference</h1>
<p>K. S. Kundert, "Introduction to RF simulation and its application,"
in IEEE Journal of Solid-State Circuits, vol. 34, no. 9, pp. 1298-1319,
Sept. 1999, doi: 10.1109/4.782091. [<a
href="https://designers-guide.org/analysis/rf-sim.pdf">pdf</a>]</p>
<p>Stephen Maas, Nonlinear Microwave and RF Circuits, Second Edition ,
Artech, 2003.</p>
<p>Phillips, Joel R. and Kenneth S. Kundert. "Noise in mixers,
oscillators, samplers, and logic: an introduction to cyclostationary
noise." <em>Proceedings of the IEEE 2000 Custom Integrated Circuits
Conference (Cat. No.00CH37044)</em> (2000): 431-438. [<a
href="https://designers-guide.org/theory/cyclo-preso.pdf">pdf</a>]</p>
<p>Karti Mayaram. ECE 521 Fall 2016 Analog Circuit Simulation:
Simulation of Radio Frequency Integrated Circuits [<a
href="https://web.engr.oregonstate.edu/~karti/ece521/lec16_11_16.pdf">pdf1</a>,
<a
href="https://web.engr.oregonstate.edu/~karti/ece521/lec16_11_23.pdf">pdf2</a>]</p>
<p>The Value Of RF Harmonic Balance Analyses For Analog Verification:
Frequency domain periodic large and small signal analyses. [<a
href="https://semiengineering.com/the-value-of-rf-harmonic-balance-analyses-for-analog-verification/">https://semiengineering.com/the-value-of-rf-harmonic-balance-analyses-for-analog-verification/</a>]</p>
<p>Shanthi Pavan, "Demystifying Linear Time Varying Circuits"</p>
<p>S. Pavan and G. C. Temes, "Reciprocity and Inter-Reciprocity: A
Tutorial— Part I: Linear Time-Invariant Networks," in IEEE Transactions
on Circuits and Systems I: Regular Papers, vol. 70, no. 9, pp.
3413-3421, Sept. 2023, doi: 10.1109/TCSI.2023.3276700.</p>
<p>S. Pavan and G. C. Temes, "Reciprocity and Inter-Reciprocity: A
Tutorial—Part II: Linear Periodically Time-Varying Networks," in IEEE
Transactions on Circuits and Systems I: Regular Papers, vol. 70, no. 9,
pp. 3422-3435, Sept. 2023, doi: 10.1109/TCSI.2023.3294298.</p>
<p>S. Pavan and R. S. Rajan, "Interreciprocity in Linear Periodically
Time-Varying Networks With Sampled Outputs," in IEEE Transactions on
Circuits and Systems II: Express Briefs, vol. 61, no. 9, pp. 686-690,
Sept. 2014, doi: 10.1109/TCSII.2014.2335393.</p>
<p>Prof. Shanthi Pavan. Introduction to Time - Varying Electrical
Network. [<a
href="https://youtube.com/playlist?list=PLyqSpQzTE6M8qllAtp9TTODxNfaoxRLp9">https://youtube.com/playlist?list=PLyqSpQzTE6M8qllAtp9TTODxNfaoxRLp9</a>]</p>
<p>Shanthi Pavan. EE5323: Advanced Electrical Networks (Jan-May. 2015)
[<a
href="https://www.ee.iitm.ac.in/vlsi/courses/ee5323/start">https://www.ee.iitm.ac.in/vlsi/courses/ee5323/start</a>]</p>
<p>R. S. Ashwin Kumar. EE698W: Analog circuits for signal processing [<a
href="https://home.iitk.ac.in/~ashwinrs/2022_EE698W.html">https://home.iitk.ac.in/~ashwinrs/2022_EE698W.html</a>]</p>
<p>Piet Vanassche, Georges Gielen, and Willy Sansen. 2009. Systematic
Modeling and Analysis of Telecom Frontends and their Building Blocks
(1st. ed.). Springer Publishing Company, Incorporated.</p>
<p>Beffa, Federico. (2023). Weakly Nonlinear Systems.
10.1007/978-3-031-40681-2.</p>
<p>Wereley, Norman. (1990). Analysis and control of linear periodically
time varying systems.</p>
<p>Hameed, S. (2017). Design and Analysis of Programmable Receiver
Front-Ends Based on LPTV Circuits. <em>UCLA</em>. ProQuest ID:
Hameed_ucla_0031D_15577. Merritt ID: ark:/13030/m5gb6zcz. Retrieved from
<a
href="https://escholarship.org/uc/item/51q2m7bx">https://escholarship.org/uc/item/51q2m7bx</a></p>
<p>Matt Allen. Introduction to Linear Time Periodic Systems. [<a
href="https://youtu.be/OCOkEFDQKTI">https://youtu.be/OCOkEFDQKTI</a>]</p>
<p>Fivel, Oren. "Analysis of Linear Time-Varying &amp; Periodic
Systems." <em>arXiv preprint arXiv:2202.00498</em> (2022).</p>
<p>RF Harmonic Balance Analysis for Nonlinear Circuits [<a
href="https://resources.pcb.cadence.com/blog/2019-rf-harmonic-balance-analysis-for-nonlinear-circuits">https://resources.pcb.cadence.com/blog/2019-rf-harmonic-balance-analysis-for-nonlinear-circuits</a>]</p>
<p>Steer, Michael. Microwave and RF Design (Third Edition, 2019). NC
State University, 2019.</p>
<p>Steer, Michael. Harmonic Balance Analysis of Nonlinear RF Circuits -
Case Study Index: CS_AmpHB [<a
href="https://youtu.be/BM5ZQgfb_sY?si=bjN_hMe-wvoeGHzu">link</a>]</p>
<p>Vishal Saxena, "SpectreRF Periodic Analysis" URL:<a
href="https://www.eecis.udel.edu/~vsaxena/courses/ece614/Handouts/SpectreRF%20Periodic%20Analysis.pdf">https://www.eecis.udel.edu/~vsaxena/courses/ece614/Handouts/SpectreRF%20Periodic%20Analysis.pdf</a></p>
<p>Josh Carnes,Peter Kurahashi. "Periodic Analyses of Sampled Systems"
URL:<a
href="https://slideplayer.com/slide/14865977/">https://slideplayer.com/slide/14865977/</a></p>
<p>Kundert, Ken. (2006). Simulating Switched-Capacitor Filters with
SpectreRF. URL:<a
href="https://designers-guide.org/analysis/sc-filters.pdf">https://designers-guide.org/analysis/sc-filters.pdf</a></p>
<p>Article (20482538) Title: Why is pnoise sampled(jitter) different
than pnoise timeaverage on a driven circuit? URL:<a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V000009EStcUAG">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V000009EStcUAG</a></p>
<p>Article (20467468) Title: The mathematics behind choosing the upper
frequency when simulating pnoise jitter on an oscillator URL:<a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V000007MnBUUA0">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O0V000007MnBUUA0</a></p>
<p>Andrew Beckett. "Simulating phase noise for PFD-CP". URL:<a
href="https://groups.google.com/g/comp.cad.cadence/c/NPisXTElx6E/m/XjWxKbbfh2cJ">https://groups.google.com/g/comp.cad.cadence/c/NPisXTElx6E/m/XjWxKbbfh2cJ</a></p>
<p>Dr. Yanghong Huang. MATH44041/64041: Applied Dynamical Systems [<a
href="https://personalpages.manchester.ac.uk/staff/yanghong.huang/teaching/MATH4041/default.htm">https://personalpages.manchester.ac.uk/staff/yanghong.huang/teaching/MATH4041/default.htm</a>]</p>
<p>Jeffrey Wong. Math 563, Spring 2020 Applied computational analysis
[<a
href="https://services.math.duke.edu/~jtwong/math563-2020/main.html">https://services.math.duke.edu/~jtwong/math563-2020/main.html</a>]</p>
<p>Jeffrey Wong. Math 353, Fall 2020 Ordinary and Partial Differential
Equations [<a
href="https://services.math.duke.edu/~jtwong/math353-2020/main.html">https://services.math.duke.edu/~jtwong/math353-2020/main.html</a>]</p>
<p>Tip of the Week: Please explain in more practical (less theoretical)
terms the concept of "oscillator line width." [<a
href="https://community.cadence.com/cadence_blogs_8/b/rf/posts/please-explain-in-more-practical-less-theoretical-terms-the-concept-of-quot-oscillator-line-width-quot">https://community.cadence.com/cadence_blogs_8/b/rf/posts/please-explain-in-more-practical-less-theoretical-terms-the-concept-of-quot-oscillator-line-width-quot</a>]</p>
<p>Rubiola, E. (2008). Phase Noise and Frequency Stability in
Oscillators (The Cambridge RF and Microwave Engineering Series).
Cambridge: Cambridge University Press. doi:10.1017/CBO9780511812798</p>
<p>Dr. Ulrich L. Rohde, Noise Analysis, Then and Today [<a
href="https://www.microwavejournal.com/articles/29151-noise-analysis-then-and-today">https://www.microwavejournal.com/articles/29151-noise-analysis-then-and-today</a>]</p>
<p>Nicola Da Dalt and Ali Sheikholeslami. 2018. Understanding Jitter and
Phase Noise: A Circuits and Systems Perspective (1st. ed.). Cambridge
University Press, USA.</p>
<p>Kester, Walt. (2005). Converting Oscillator Phase Noise to Time
Jitter. [<a
href="https://www.analog.com/media/en/training-seminars/tutorials/MT-008.pdf">https://www.analog.com/media/en/training-seminars/tutorials/MT-008.pdf</a>]</p>
<p>Drakhlis, B.. (2001). Calculate oscillator jitter by using
phase-noise analysis: Part 2 of two parts. Microwaves and Rf. 40.
109-119.</p>
<p>Explanation for sampled PXF analysis. [<a
href="https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/45055/explanation-for-sampled-pxf-analysis/1376140#1376140">https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/45055/explanation-for-sampled-pxf-analysis/1376140#1376140</a>]</p>
<p>模拟放大器的低噪声设计技术2-3实践 아날로그 증폭기의 저잡음 설계
기법2-3실습 [<a
href="https://youtu.be/vXLDfEWR31k?si=p2gbwaKoTxtfvrTc">https://youtu.be/vXLDfEWR31k?si=p2gbwaKoTxtfvrTc</a>]</p>
<p>2.2 How POP Really Works [<a
href="https://www.simplistechnologies.com/documentation/simplis/ast_02/topics/2_2_how_pop_really_works.htm">https://www.simplistechnologies.com/documentation/simplis/ast_02/topics/2_2_how_pop_really_works.htm</a>]</p>
<p>Jaeha Kim. Lecture 11. Mismatch Simulation using PNOISE [<a
href="https://ocw.snu.ac.kr/sites/default/files/NOTE/7037.pdf">https://ocw.snu.ac.kr/sites/default/files/NOTE/7037.pdf</a>]</p>
<p>Hueber, G., &amp; Staszewski, R. B. (Eds.) (2010).
<em>Multi-Mode/Multi-Band RF Transceivers for Wireless Communications:
Advanced Techniques, Architectures, and Trends</em>. John Wiley &amp;
Sons. https://doi.org/10.1002/9780470634455</p>
<p>B. Boser,A. Niknejad ,S.Gambin 2011 EECS 240 Topic 6: Noise Analysis
[<a
href="https://mixsignal.files.wordpress.com/2013/06/t06noiseanalysis_simone-1.pdf">https://mixsignal.files.wordpress.com/2013/06/t06noiseanalysis_simone-1.pdf</a>]</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>import package in SystemVerilog compilation</title>
    <url>/2022/03/24/pkg-import-compile-sv/</url>
    <content><![CDATA[<h3 id="import-and-compile-order">import and compile order</h3>
<h4 id="project">project</h4>
<p><strong>yapp_pkg.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yapp_pkg;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> uvm_config_db<span class="variable">#(virtual yapp_if)</span> yapp_vif_config;</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_packet.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_monitor.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_sequencer.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_seqs.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_tx_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;yapp_env.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>
<p><strong>yapp_tx_monitor.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_tx_monitor <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Collected Data handle</span></span><br><span class="line">  yapp_packet pkt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count packets collected</span></span><br><span class="line">  <span class="keyword">int</span> num_pkt_col;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component macro</span></span><br><span class="line">  `uvm_component_utils_begin(yapp_tx_monitor)</span><br><span class="line">    `uvm_field_int(num_pkt_col, UVM_ALL_ON + UVM_NOCOMPARE)</span><br><span class="line">  `uvm_component_utils_end</span><br><span class="line"><span class="comment">/////////////////// virtual interface ////////////////////</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">interface</span> yapp_if vif;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line">      ...</span><br><span class="line">     </span><br><span class="line"><span class="keyword">endclass</span> : yapp_tx_monitor</span><br></pre></td></tr></table></figure>
<p><strong>yapp_tx_driver.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_tx_driver <span class="keyword">extends</span> uvm_driver <span class="variable">#(yapp_packet)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">////////////////// virtual interface ////////////////////</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">interface</span> yapp_if vif;</span><br><span class="line"> <span class="comment">/////////////////////////////////////////////////////</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">int</span> num_sent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component macro</span></span><br><span class="line">  `uvm_component_utils_begin(yapp_tx_driver)</span><br><span class="line">    `uvm_field_int(num_sent, UVM_ALL_ON + UVM_NOCOMPARE)</span><br><span class="line">  `uvm_component_utils_end</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructor - required syntax for UVM automation and utilities</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">  <span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">    `uvm_info(get_type_name(), &#123;<span class="string">&quot;start of simulation for &quot;</span>, get_full_name()&#125;, UVM_HIGH)</span><br><span class="line">  <span class="keyword">endfunction</span> : start_of_simulation_phase</span><br><span class="line">      ...</span><br><span class="line">     </span><br><span class="line"><span class="keyword">endclass</span> : yapp_tx_driver </span><br></pre></td></tr></table></figure>
<p><strong>yapp_if.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> yapp_if (<span class="keyword">input</span> clock, <span class="keyword">input</span> reset );</span><br><span class="line"><span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line"><span class="keyword">timeprecision</span> <span class="number">100</span>ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////// import package //////////////////////</span></span><br><span class="line"><span class="keyword">import</span> yapp_pkg::*;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////    </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Actual Signals</span></span><br><span class="line">  <span class="keyword">logic</span>              in_data_vld;</span><br><span class="line">  <span class="keyword">logic</span>              in_suspend;</span><br><span class="line">  <span class="keyword">logic</span>       [<span class="number">7</span>:<span class="number">0</span>]  in_data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// signal for transaction recording</span></span><br><span class="line">  <span class="keyword">bit</span> monstart, drvstart;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// local storage for payload</span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] payload_mem [<span class="number">0</span>:<span class="number">63</span>];</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endinterface</span> : yapp_if</span><br></pre></td></tr></table></figure>
<blockquote>
<p>virtual interface is in package;</p>
<p><code>yapp_pkg</code> is imported into interface</p>
</blockquote>
<blockquote>
<p>!!!
<code>typedef uvm_config_db#(virtual yapp_if) yapp_vif_config;</code> is
<strong>forward declaration</strong></p>
<p><em>A forward <code>typedef</code> declares an identifier as a type
in advance of the full definition of that type</em></p>
</blockquote>
<h4 id="vcs-compile">VCS compile</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vcs -full64 -R -sverilog  -ntb_opts uvm-1.2 +UVM_TESTNAME=short_yapp_012_test  -f vcs.f  </span><br></pre></td></tr></table></figure>
<p><strong>vcs.f</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-timescale=1ns/1ns</span><br><span class="line"></span><br><span class="line">+incdir+../sv</span><br><span class="line"></span><br><span class="line">../sv/yapp_if.sv</span><br><span class="line">../sv/yapp_pkg.sv</span><br><span class="line">./clkgen.sv</span><br><span class="line">./hw_top.sv</span><br><span class="line">./tb_top.sv</span><br></pre></td></tr></table></figure>
<p><em>output ERROR</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error-[SV-LCM-PND] Package not defined</span><br><span class="line">../sv/yapp_if.sv, 18</span><br><span class="line">yapp_if, &quot;yapp_pkg::&quot;</span><br><span class="line">  Package scope resolution failed. Token &#x27;yapp_pkg&#x27; is not a package. </span><br><span class="line">  Originating module &#x27;yapp_if&#x27;.</span><br><span class="line">  Move package definition before the use of the package.</span><br></pre></td></tr></table></figure>
<h4 id="xrun-compile">xrun compile</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xrun -f xrun.f</span><br></pre></td></tr></table></figure>
<p><strong>xrun.f</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-64</span><br><span class="line"></span><br><span class="line">-uvmhome  CDNS-1.2</span><br><span class="line"></span><br><span class="line">// incdir for include files</span><br><span class="line">-incdir ../sv</span><br><span class="line"></span><br><span class="line">+UVM_TESTNAME=short_yapp_012_test</span><br><span class="line"></span><br><span class="line">-timescale 1ns/1ns</span><br><span class="line"></span><br><span class="line">// compile files</span><br><span class="line">../sv/yapp_if.sv</span><br><span class="line">../sv/yapp_pkg.sv</span><br><span class="line">./clkgen.sv</span><br><span class="line">./hw_top.sv</span><br><span class="line">./tb_top.sv</span><br></pre></td></tr></table></figure>
<p><em>output Error</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file: ../sv/yapp_if.sv</span><br><span class="line">import yapp_pkg::*;</span><br><span class="line">              |</span><br><span class="line">xmvlog: *E,NOPBIND (../sv/yapp_if.sv,18|14): Package yapp_pkg could not be bound.</span><br><span class="line">        interface worklib.yapp_if:sv</span><br><span class="line">                errors: 1, warnings: 0</span><br></pre></td></tr></table></figure>
<h4 id="solution">solution</h4>
<p>place <code>../sv/yapp_pkg.sv</code> before
<code>../sv/yapp_if.sv</code>.</p>
<blockquote>
<p>In this particular example, <code>yapp_pkg</code> is NOT needed in
interface. just delete <code>import yapp_pkg::*</code> is enough in
<code>../sv/yapp_if.sv</code></p>
</blockquote>
<h3 id="plain-example">plain example</h3>
<p>The order of compilation unit DON'T matter</p>
<h4 id="project-1">project</h4>
<p><strong>hw_top.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hw_top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clock and reset signals</span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>]  clock_period;</span><br><span class="line">  <span class="keyword">logic</span>         run_clock;</span><br><span class="line">  <span class="keyword">logic</span>         clock;</span><br><span class="line">  <span class="keyword">logic</span>         reset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// YAPP Interface to the DUT</span></span><br><span class="line">  yapp_if in0(clock, reset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLKGEN module generates clock</span></span><br><span class="line">  clkgen clkgen (</span><br><span class="line">    <span class="variable">.clock</span>(clock),</span><br><span class="line">    <span class="variable">.run_clock</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.clock_period</span>(<span class="number">32&#x27;d10</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  yapp_router dut(</span><br><span class="line">    <span class="variable">.reset</span>(reset),</span><br><span class="line">    <span class="variable">.clock</span>(clock),</span><br><span class="line">    <span class="variable">.error</span>(),</span><br><span class="line">    <span class="comment">// YAPP interface signals connection</span></span><br><span class="line">    <span class="variable">.in_data</span>(in0<span class="variable">.in_data</span>),</span><br><span class="line">    <span class="variable">.in_data_vld</span>(in0<span class="variable">.in_data_vld</span>),</span><br><span class="line">    <span class="variable">.in_suspend</span>(in0<span class="variable">.in_suspend</span>),</span><br><span class="line">    <span class="comment">// Output Channels</span></span><br><span class="line">    <span class="comment">//Channel 0   </span></span><br><span class="line">    <span class="variable">.data_0</span>(),</span><br><span class="line">    <span class="variable">.data_vld_0</span>(),</span><br><span class="line">    <span class="variable">.suspend_0</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="comment">//Channel 1   </span></span><br><span class="line">    <span class="variable">.data_1</span>(),</span><br><span class="line">    <span class="variable">.data_vld_1</span>(),</span><br><span class="line">    <span class="variable">.suspend_1</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="comment">//Channel 2   </span></span><br><span class="line">    <span class="variable">.data_2</span>(),  </span><br><span class="line">    <span class="variable">.data_vld_2</span>(),</span><br><span class="line">    <span class="variable">.suspend_2</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="comment">// Host Interface Signals</span></span><br><span class="line">    <span class="variable">.haddr</span>(),</span><br><span class="line">    <span class="variable">.hdata</span>(),</span><br><span class="line">    <span class="variable">.hen</span>(),</span><br><span class="line">    <span class="variable">.hwr_rd</span>());</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>yapp_router.sv</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> yapp_router (<span class="keyword">input</span> clock,                              </span><br><span class="line">                    <span class="keyword">input</span> reset,                            </span><br><span class="line">                    <span class="keyword">output</span> error,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Input channel</span></span><br><span class="line">                    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in_data,                           </span><br><span class="line">                    <span class="keyword">input</span> in_data_vld,                     </span><br><span class="line">                    <span class="keyword">output</span> in_suspend,</span><br><span class="line">                    <span class="comment">// Output Channels</span></span><br><span class="line">                    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_0,  <span class="comment">//Channel 0</span></span><br><span class="line">                    <span class="keyword">output</span> <span class="keyword">reg</span> data_vld_0, </span><br><span class="line">                    <span class="keyword">input</span> suspend_0, </span><br><span class="line">                    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_1,  <span class="comment">//Channel 1</span></span><br><span class="line">                    <span class="keyword">output</span> <span class="keyword">reg</span> data_vld_1, </span><br><span class="line">                    <span class="keyword">input</span> suspend_1, </span><br><span class="line">                    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_2,  <span class="comment">//Channel 2</span></span><br><span class="line">                    <span class="keyword">output</span> <span class="keyword">reg</span> data_vld_2,</span><br><span class="line">                    <span class="keyword">input</span> suspend_2,</span><br><span class="line">     </span><br><span class="line">                    <span class="comment">// Host Interface Signals</span></span><br><span class="line">                    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] haddr,</span><br><span class="line">                    <span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] hdata,</span><br><span class="line">                    <span class="keyword">input</span> hen,</span><br><span class="line">                    <span class="keyword">input</span> hwr_rd);                            </span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span>    </span><br></pre></td></tr></table></figure>
<h4 id="compile">compile</h4>
<p>place <strong>hw_top.sv</strong> <em>before or after</em>
<strong>yapp_router.sv</strong> doesn't matter, the compiler (xrun, vcs)
can compile them successfully.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Always place package before DUT is preferred choice during
compiling.</p>
<h3 id="refernce">refernce</h3>
<p><a
href="https://verificationacademy.com/forums/systemverilog/class-forward-declaration#answer-41383">class
forward declaration</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Phase Noise and Jitter Simulation</title>
    <url>/2023/10/21/phasenoise-jitter/</url>
    <content><![CDATA[<h2 id="phase-noise">Phase noise</h2>
<p>The phase noise does not affect the total power in the signal, it
only affects its distribution.</p>
<ul>
<li>Without phase noise, <span class="math inline">\(S_v(f)\)</span> is
a series of impulse functions at the harmonics of <span
class="math inline">\(f_o\)</span>.</li>
<li>With phase noise, the impulse functions spread, becoming fatter and
shorter but retaining the same total power</li>
</ul>
<p><img src="/2023/10/21/phasenoise-jitter/image-20231029164227587.png"
alt="image-20231029164227587" /></p>
<blockquote>
<p><strong>line width</strong>: corner frequency <span
class="math inline">\(f_{\Delta}\)</span>, where the power drops 3dB</p>
</blockquote>
<h2 id="lorentian-spectrum">Lorentian Spectrum</h2>
<p>A more precise analysis shows that the spectrum of a free-running
oscillator does indeed have a Lorentian profile:</p>
<ol type="1">
<li>it is <strong>flat</strong> for frequencies below a given corner
frequency</li>
<li>and rolls off as <span class="math inline">\(1/f^2\)</span> above
it.</li>
</ol>
<p>The spectrum of the signal <span class="math inline">\(x(t +
α(t))\)</span> can be expressed as <span class="math display">\[
S_x(f)=\sum_{n}\left| X_n \right|^2\frac{\omega_0^2 n^2
c}{\frac{1}{4}\omega_0^4 n^4 c^2+(\omega+n\omega_0)^2}
\]</span> The integral in above equation around each harmonic is equal
to the power of the harmonic itself <span class="math inline">\(\left|
X_n \right|^2\)</span></p>
<p>This means that the <strong>excess phase noise</strong>
<strong>DONT</strong> change the energy of the signal; it just spreads
its energy over the frequency spectrum, blurring the very sharp
frequency impulse of an ideal noiseless oscillator.</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220504130750290.png"
alt="image-20220504130750290" /></p>
<h2 id="vco-varactor">VCO varactor</h2>
<blockquote>
<p>Two methods: 1. pss + pac; 2. pss+psp</p>
</blockquote>
<h3 id="pss-pac">PSS + PAC</h3>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220510192206354.png"
alt="image-20220510192206354" /></p>
<p>pss time domain</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220510192351590.png"
alt="image-20220510192351590" /></p>
<p>using the <strong>0-harmonic</strong></p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220510192447040.png"
alt="image-20220510192447040" /></p>
<h3 id="pss-psp">PSS + PSP</h3>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220510192753324.png"
alt="image-20220510192753324" /></p>
<p>using <strong>Y11</strong> of <code>psp</code></p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220510192639080.png"
alt="image-20220510192639080" /></p>
<h3 id="results">results</h3>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220510193036717.png"
alt="image-20220510193036717" /></p>
<blockquote>
<p>which are same</p>
</blockquote>
<h2 id="vco-phase-noise">VCO Phase Noise</h2>
<h3 id="pnoise---timeaverage">pnoise - timeaverage</h3>
<ol type="1">
<li><p><em>Direct Plot/Pnoise/Phase Noise</em> or</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220511112856934.png"
alt="image-20220511112856934" /></p></li>
<li><p>manually calculate by definition</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220511112806122.png"
alt="image-20220511112806122" /></p></li>
<li><p><code>output noise</code> with unit <code>dBc</code></p>
<p><em>Direct Plot/Pnoise/Output Noise Units:dBc/Hz and Noise
convention: SSB</em></p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220511113248984.png"
alt="image-20220511113248984" /></p></li>
</ol>
<blockquote>
<p>The above method 2 and 3 only apply to <code>timeaveage</code> pnoise
simulation,</p>
</blockquote>
<h3 id="pnoise---sampledjitteredge-crossing">pnoise -
sampled(jitter)/Edge Crossing</h3>
<p><img src="/2023/10/21/phasenoise-jitter/EdgePhaseNoise.drawio.svg"
alt="EdgePhaseNoise.drawio" /></p>
<p><em>Direct Plot/Pnoise/<strong>Edge</strong> Phase Noise</em> or</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220515214901120.png"
alt="image-20220515214901120" /></p>
<p>Another way, the following equation can also be used for
<code>sampled(jitter)/Edge Crossing</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PhaseNoise(dBc/Hz) = dB20( OutputNoise(V/sqrt(Hz)) / slopeCrossing / Tper*twoPi ) - dB10(2)</span><br></pre></td></tr></table></figure>
<p>where <code>dB10(2)</code> is used to obtain SSB from DSB</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220511150337318.png"
alt="image-20220511150337318" /></p>
<h3 id="output-noise-of-sampledjitter-pnoise">Output Noise of
sampled(jitter) pnoise</h3>
<p>The last section's <code>Output Noise (V**2/Hz)</code> can be
obtained by <em>transient noise simulation</em></p>
<p>The idea is that sample waveform with ideal clock, subtract DC
offset, then fft(psd)</p>
<ul>
<li>samplesRaw = sample(wv)</li>
<li>samplePost = samplesRaw - average(samplesRaw)</li>
<li>Output Noise (V**2/Hz) = psd(samplePost)</li>
</ul>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220516184543148.png"
alt="image-20220516184543148" /></p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220516184844296.png"
alt="image-20220516184844296" /></p>
<p><strong>Expression</strong>:</p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220516185506348.png"
alt="image-20220516185506348" /></p>
<blockquote>
<p>The computation cost is typically very high, and the accuracy is
lesser as compared to PSS/Pnoise</p>
</blockquote>
<h2 id="pnoise-sampledjitter-sampled-phase-option">Pnoise
Sampled(jitter): Sampled Phase Option</h2>
<ul>
<li>Identical to <strong>noisetype=timedomain</strong> in old GUI</li>
<li>Use model:
<ul>
<li>Sampleds Per Period: number of ponits</li>
<li>Add Specific Points: specific time point, still time points</li>
</ul></li>
</ul>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220712085426461.png"
alt="image-20220712085426461" /></p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220712085836315.png"
alt="image-20220712085836315" /></p>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220712090011204.png"
alt="image-20220712090011204" /></p>
<blockquote>
<p>pss beat freq = 5GHz</p>
<p>pnoise sweeptype: absolute, from 100k to 2.5GHz</p>
</blockquote>
<h2 id="transient-noise">Transient noise</h2>
<h3 id="phase-noise-from-transient-noise-analysis">phase noise from
transient noise analysis</h3>
<ol type="1">
<li>The Phase Noise function is now available in the Direct Plot form
(Results-Direct Plot-Main Form) after Transient Analysis is run
<ul>
<li>Absolute jitter Method</li>
<li>Direct Power Spectral Density Method</li>
</ul></li>
<li><code>PN</code> phase noise function
<ul>
<li>Absolute jitter Method</li>
<li>Direct Power Spectral Density Method</li>
</ul></li>
</ol>
<blockquote>
<p><strong>Absolute jitter Method</strong>: Phase noise is defined as
the power spectral density of the absolute jitter of an input
waveform</p>
<p>and <strong>absolute jitter method</strong> is the default method</p>
</blockquote>
<p>In below discussion, we only think about the
<code>absolute jitter method</code></p>
<h3 id="psd-and-phase-noise">PSD and Phase Noise</h3>
<blockquote>
<ul>
<li>phase noise is single-sideband</li>
<li>psd is double-sideband</li>
<li>Then the ratio is <strong>2</strong></li>
</ul>
</blockquote>
<h4 id="by-pss_pnoise">By PSS_Pnoise</h4>
<p><code>jee</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rfEdgePhaseNoise(?result &quot;pnoise_sample_pm0&quot; ?eventList &#x27;nil) + 10 * log10(2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>convert <strong>single-sideband</strong> phase noise to psd by
multiplying 2 or <code>10 * log10(2)</code></p>
</blockquote>
<h4 id="by-trannoise-pn-function">By trannoise <code>PN</code>
function</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PN(clip(VT(&quot;/Out1&quot;) 2.60417e-08 0.000400052) &quot;rising&quot; 1.65 ?Tnom (1 / 3.84e+07) ?windowName &quot;Rectangular&quot; ?smooth 1 ?windowSize 15000 ?detrending &quot;None&quot; ?cohGain 1 ?methodType &quot;absJitter&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>double-sideband psd</p>
</blockquote>
<h4 id="by-trannoise-psd-and-abs_jitter-function">By trannoise
<code>psd</code> and <code>abs_jitter</code> function</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dB10(psd(abs_jitter(clip(VT(&quot;/Out1&quot;) 2.60417e-08 0.000400052) &quot;rising&quot; 1.65 ?Tnom (1 / 3.84e+07)) 2.60417e-08 0.000400052 15360 ?windowName &quot;Rectangular&quot; ?smooth 1 ?windowSize 15000 ?detrending &quot;None&quot; ?cohGain 1))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>double-sideband psd</p>
<p><code>abs_jitter</code> <em>Y-Unit</em> default is
<code>rad</code></p>
</blockquote>
<h4 id="comparison">Comparison</h4>
<p><img src="/2023/10/21/phasenoise-jitter/image-20220506225324377.png"
alt="image-20220506225324377" /></p>
<blockquote>
<p><code>PN</code>'s result is same with <code>psd</code>'s</p>
</blockquote>
<h3 id="rms-value">RMS value</h3>
<ul>
<li>build the <code>abs_jitter</code> function with <em>seconds as the Y
axis</em> and add the <code>stddev</code> function to determine the Jee
jitter value</li>
<li>or integrate psd</li>
</ul>
<p>The RMS <span class="math inline">\(x_{\text{RMS}}\)</span> of a
discrete domain signal <span class="math inline">\(x(n)\)</span> is
given by <span class="math display">\[
x_{\text{RMS}}=\sqrt{\frac{1}{N}\sum_{n=0}^{N-1}|x(n)|^2}
\]</span> Inserting Parseval's theorem given by <span
class="math display">\[
\sum_{n=0}^{N-1}|x(n)|^2=\frac{1}{N}\sum_{n=0}^{N-1}|X(k)|^2
\]</span> allows for computing the RMS from the spectrum <span
class="math inline">\(X(k)\)</span> as <span class="math display">\[
x_{\text{RMS}}=\sqrt{\frac{1}{N^2}\sum_{n=0}^{N-1}|X(k)|^2}
\]</span></p>
<h3 id="remarks">Remarks</h3>
<p>Cadence Spectre's <code>PN</code> function may call
<code>abs_jitter</code> and <code>psd</code> function under the
hood.</p>
<h2 id="reference">reference</h2>
<p>Article (11514536) Title: How to obtain a phase noise plot from a
transient noise analysis URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000nb1CEAQ">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000nb1CEAQ</a></p>
<p>Article (20500632) Title: How to simulate Random and Deterministic
Jitters URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009fiXeEAI">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009fiXeEAI</a></p>
<p>Tutorial on Scaling of the Discrete Fourier Transform and the Implied
Physical Units of the Spectra of Time-Discrete Signals Jens Ahrens, Carl
Andersson, Patrik Höstmad, Wolfgang Kropp URL: <a
href="https://appliedacousticschalmers.github.io/scaling-of-the-dft/AES2020_eBrief/">https://appliedacousticschalmers.github.io/scaling-of-the-dft/AES2020_eBrief/</a></p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>clocking</title>
    <url>/2024/05/11/pll-fll/</url>
    <content><![CDATA[<h2 id="bang-bang-phase-detector">Bang-Bang Phase Detector</h2>
<blockquote>
<p>It's <strong>ternary</strong>, because <em>early</em>, <em>late</em>
and <em>no transition</em></p>
</blockquote>
<h3 id="linearing-bb-pd">Linearing BB-PD</h3>
<p>BB Gain is the slope of average BB output <span
class="math inline">\(\mu\)</span>, versus phase offset <span
class="math inline">\(\phi\)</span>, i.e. <span
class="math inline">\(\frac {\partial \mu}{\partial \phi}\)</span>,</p>
<p>BB only produces output for a transition and this de-rates the gain.
Transition density = <em>0.5</em> for random data</p>
<p><span class="math display">\[
K_{BB} = \frac{1}{2}\frac {\partial \mu}{\partial \phi}
\]</span></p>
<p>where <span class="math inline">\(\mu = (1)\times
\mathrm{P}(\text{late}|\phi) + (-1)\times
\mathrm{P}(\text{early}|\phi)\)</span></p>
<p><img src="/2024/05/11/pll-fll/bb-PDF.drawio.svg"
alt="bb-PDF.drawio" /></p>
<blockquote>
<p>Both jitter and amplitude noise distribution are same, just scaled by
slope</p>
</blockquote>
<h3 id="self-noise-term">Self-Noise Term</h3>
<p>One price we pay for <em>BB PD</em> versus <em>linear PD</em> is the
self-noise term. For small phase errors BB output noise is the full
magnitude of the sliced data.</p>
<blockquote>
<p>BB-PD don't have any measure as to how early or how late and the way
that tell loop is locked, is over a long time average, BB-PD have an
equal number of earlies and lates</p>
</blockquote>
<p><span class="math display">\[\begin{align}
\sigma_{BB} &amp;= [E(X^2) - E(X)^2] \cdot \mathrm{P}(\text{trans}) \\
&amp;= [1 - 0]\cdot 0.5 \\
&amp;= 0.5
\end{align}\]</span></p>
<h3 id="reference">reference</h3>
<p>John T. Stonick, ISSCC 2011 TUTORIALS <em>T5: DPLL-Based Clock and
Data Recovery</em></p>
<h2 id="vco-tuning-bandwidth">VCO tuning bandwidth</h2>
<p><em>TODO</em> 📅</p>
<h2 id="narrowband-phase-modulation">narrowband phase modulation</h2>
<p>A sine wave with phase modulation is expressed as <span
class="math display">\[
y(t) = A_0 \sin(2\pi f_0 t + \phi _0 +\phi (t))
\]</span> where <span class="math inline">\(\phi (t)\)</span> is a
time-varying phase modulation function</p>
<p>Assuming a narrowband phase modulation (PM), that is, the absolute
amount of modulated phase is small enough</p>
<blockquote>
<p><em>otherwise the modulation becomes frequency modulation (FM) and
its analysis becomes more complex</em></p>
</blockquote>
<p><span class="math display">\[
y(t) \simeq A_0 \sin(2\pi f_0 t +\phi _0) + A_0 \phi (t)\cos(2\pi f_0 t
+ \phi _0)
\]</span></p>
<blockquote>
<p>Because <span class="math inline">\(\cos \phi(t)\)</span> and <span
class="math inline">\(\sin \phi(t)\)</span> are approximated to <span
class="math inline">\(1\)</span> and <span class="math inline">\(\phi
(t)\)</span>, respectively</p>
</blockquote>
<p>The Fourier transform of <span class="math inline">\(y(t)\)</span> is
<span class="math display">\[
Y(f) = \frac{1}{2}A_0 e^{j\phi _0}\delta(f-f_0)
-\frac{1}{2}A_0e^{-j\phi_0}\delta(f+f_0)+\frac{1}{2}A_0e^{j\phi_0}\Phi(f-f_0)-\frac{1}{2}A_0e^{-j\phi_0}\Phi(f+f_0)
\]</span></p>
<blockquote>
<p>where <span class="math inline">\(\Phi(f)\)</span> is the Fourier
transform pair of <span class="math inline">\(\phi(t)\)</span></p>
</blockquote>
<p>The autocorrelation of <span class="math inline">\(y(t)\)</span>
is</p>
<p><span class="math display">\[\begin{align}
R(\tau) &amp;= E(y(t)y(t+\tau))\\
&amp;= E([A_0\sin(2\pi f_0 t + \phi_0)+A_0\phi(t)\cos(2\pi f_0 t+\phi
_0)]\\
&amp;\cdot [A_0\sin(2\pi f_0 t + \phi_0+2\pi f_0\tau)+A_0\phi(t+\tau
)\cos(2\pi f_0 t+\phi _0+2\pi f_0\tau)]) \\
&amp;=A_0^2 E( \alpha_t^2\cos(2\pi f_0 \tau) + \alpha_t\beta_t\sin(2\pi
f_0\tau)+ \phi(t+\tau)[\alpha_t \beta_t \cos(2\pi f_0 \tau) -
\alpha_t^2\sin(2\pi f_0 \tau)] \\
&amp;+ \phi(t)[\alpha_t \beta_t \cos(2\pi f_0\tau) + \beta_t^2 \sin(2\pi
f_0 \tau)] \\
&amp;+ \phi(t)\phi(t+\tau)[\beta_t^2 \cos(2\pi f_0 \tau)-\alpha_t\beta_t
\sin(2\pi f_0 \tau)]) \\
&amp;= A_0^2E(\alpha_t^2 \cos(2\pi f_0 \tau) +
\phi(t)\phi(t+\tau)\beta_t^2\cos(2\pi f_0 \tau)) \\
&amp;= \frac{1}{2}A_0^2 \cos(2\pi f_0 \tau)(1+E(\phi(t)\phi(t+\tau))) \\
&amp;= \frac{1}{2}A_0^2 \cos(2\pi f_0 \tau)(1+R_{\phi}(\tau))
\end{align}\]</span></p>
<p>Fourier transform of <span class="math inline">\(R(\tau)\)</span> is
<span class="math display">\[
S_y(f) = \frac{1}{4}A_0^2 \delta (f-f_0) + \frac{1}{4}A_0\delta(f+f_0) +
\frac{1}{4}A_0^2S_\phi (f-f_0)+\frac{1}{4}A_0^2S_\phi (f+f_0)
\]</span> <img src="/2024/05/11/pll-fll/image-20240511221119938.png"
alt="image-20240511221119938" /></p>
<h2 id="reference-1">reference</h2>
<p>Walker, Richard. (2003). Designing Bang-Bang PLLs for Clock and Data
Recovery in Serial Data Transmission Systems. [<a
href="https://www.omnisterra.com/walker/pdfs.papers/BBPLL.pdf">pdf</a>]</p>
<p>- Clock and Data Recovery for Serial Data Communications, focusing on
bang-bang CDR design methodology, ISSCC Short Course, February 2002. [<a
href="https://www.omnisterra.com/walker/pdfs.talks/ISSCC2002.pdf">slides</a>]</p>
<p>Bae, Woorham; Jeong, Deog-Kyoon: 'Analysis and Design of CMOS
Clocking Circuits for Low Phase Noise' (Materials, Circuits and Devices,
2020)</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>pole splitting</title>
    <url>/2023/01/03/pole-splitting/</url>
    <content><![CDATA[<h3 id="generic-circuit-in-textbook">Generic circuit in textbook</h3>
<p>In addition to <em>lowering</em> the required capacitor value, Miller
compensation entails a very important property: it moves the output pole
<em>away from the origin</em>. This effect is called <strong>pole
splitting</strong></p>
<p><img src="/2023/01/03/pole-splitting/image-20230103223438823.png"
alt="image-20230103223438823" /></p>
<p>The 1st stage is replaced with Thevenin equivalent circuit , <span
class="math inline">\(V_i \cong V_i \cdot g_{m1}R_{o1}\)</span></p>
<p><span class="math display">\[\begin{align}
\frac{V_i-V_{o1}}{R_{o1}} &amp;= V_{o1}\cdot sC_{o1}+(V_{o1}-V_o)\cdot
sC_c \\
V_{o1} &amp;= \frac{V_i+sR_{o1}C_cV_o}{1+sR_{o1}(C_{o1}+C_c)}
\end{align}\]</span> <span class="math display">\[
(V_{o1}-V_o)sC_c=g_{m2}V_{o1}+V_o(\frac{1}{R_{o2}+sC_L})
\]</span> substitute <span class="math inline">\(V_{o1}\)</span>, we
get</p>
<p><span class="math display">\[\begin{align}
\frac{V_o}{V_i} &amp;=
\frac{(sC_c-g_{m2})R_{o2}}{s^2R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)+s\left\{
R_{o1}C_c\cdot g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c) \right\}
+1} \\
&amp;=
\frac{g_{m2}R_{o2}(s\frac{C_c}{g_{m2}}-1)}{s^2R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)+s\left\{
R_{o1}C_c\cdot g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c) \right\}
+1}
\end{align}\]</span></p>
<p>left hand plane poles</p>
<p><span class="math display">\[\begin{align}
\omega_1 &amp;= \frac{1}{R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c)} \\
\omega_2 &amp;= \frac{R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c)}{R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)}
\end{align}\]</span></p>
<p>and RHP (<em>right</em>-<em>hand plane</em>) zero <span
class="math display">\[
\omega_z=\frac{g_{m2}}{C_c}
\]</span></p>
<h3 id="the-circuit-with-series-switch">The circuit with series
switch</h3>
<p><img src="/2023/01/03/pole-splitting/image-20230103230122637.png"
alt="image-20230103230122637" /></p>
<p>replace <span class="math inline">\(sC_L\)</span> with <span
class="math inline">\(1/(R_{sw}+\frac{1}{sC_L})\)</span> <span
class="math display">\[\begin{align}
\frac{V_{o2}}{V_i} &amp;=
\frac{g_{m2}R_{o2}(s\frac{C_c}{g_{m2}}-1)(1+sR_{sw}C_L)}{s^3R_{o1}R_{o2}R_{sw}C_{o1}C_cC_L+s^2\left\{R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)+
\left[ R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+0)+R_{o1}(C_{o1}+C_c)\right]R_{sw}C_L
\right\}+s\left\{ R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c) +R_{sw}C_L\right\} +1}
\end{align}\]</span> Due to <span class="math display">\[
\frac{V_o}{V_{o2}} =
\frac{\frac{1}{sC_L}}{R_{sw}+\frac{1}{sC_L}}=\frac{1}{1+sR_{sw}C_L}
\]</span> Then <span class="math display">\[\begin{align}
\frac{V_o}{V_i} &amp;= \frac{V_{o2}}{V_i} \cdot \frac{V_o}{V_{o2}} \\
&amp;=
\frac{g_{m2}R_{o2}(s\frac{C_c}{g_{m2}}-1)}{s^3R_{o1}R_{o2}R_{sw}C_{o1}C_cC_L+s^2\left\{R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)+
\left[ R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+0)+R_{o1}(C_{o1}+C_c)\right]R_{sw}C_L
\right\}+s\left\{ R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c) +R_{sw}C_L\right\} +1}
\end{align}\]</span></p>
<h3 id="r_sw-and-r_c"><span class="math inline">\(R_{sw}\)</span> and
<span class="math inline">\(R_c\)</span></h3>
<p><img src="/2023/01/03/pole-splitting/image-20230103232837318.png"
alt="image-20230103232837318" /></p>
<p><span class="math display">\[\begin{align}
\frac{V_{o2}}{V_i}
&amp;=-g_{m2}R_{o2}\frac{sC_c(R_c-1/g_{m2})+1}{(1+sR_{o1}C_{o1})sR_{o2}C_c+sR_{o1}\cdot
g_{m2}R_{o2}C_c+\frac{s(R_{o2}+R_{sw})C_L+1}{sR_{sw}C_L+1}\left[(1+sR_{o1}C_{o1})(1+sR_cC_c)+sR_{o1}C_c
\right]} \\
&amp;=-g_{m2}R_{o2}\frac{sC_c(R_c-1/g_{m2})+1}{s^2R_{o1}R_{o2}C_{o1}C_c+sR_{o2}C_c+sR_{o1}\cdot
g_{m2}R_{o2}C_c+\frac{s(R_{o2}+R_{sw})C_L+1}{sR_{sw}C_L+1}\left[(1+sR_{o1}C_{o1})(1+sR_cC_c)+sR_{o1}C_c
\right]} \\
&amp;=-g_{m2}R_{o2}\frac{\left[ sC_c(R_c-1/g_{m2})+1
\right](sR_{sw}C_L+1)}{s^2R_{o1}R_{o2}C_{o1}C_c(sR_{sw}C_L+1)+sR_{o2}C_c(sR_{sw}C_L+1)+sR_{o1}\cdot
g_{m2}R_{o2}C_c(sR_{sw}C_L+1)+\left[s(R_{o2}+R_{sw})C_L+1\right]\left[(1+sR_{o1}C_{o1})(1+sR_cC_c)+sR_{o1}C_c
\right]}
\end{align}\]</span></p>
<p><span class="math inline">\(s^3\)</span> terms in denominator <span
class="math display">\[
H_3 = s^3\cdot(R_{o1}R_{o2}R_c+R_{o1}R_{o2}R_{sw} +R_{o1}R_cR_{sw})\cdot
C_{o1}C_cC_L
\]</span> <span class="math inline">\(s^2\)</span> terms in denominator
<span class="math display">\[\begin{align}
H_2
&amp;=s^2\cdot(R_{o1}R_{o2}C_{o1}C_c+R_{o1}R_{o2}C_{o1}C_L+R_{o2}R_cC_cC_L+R_{o1}R_{o2}C_cC_L+R_{o1}R_cC_{o1}C_c\\
&amp;+R_{o2}R_{sw}C_cC_L+R_{o1}R_{sw}C_cC_L\cdot
g_{m2}R_{o2}+R_{o1}R_{sw}C_{o1}C_L+R_{sw}R_cC_cC_L+R_{o1}R_{sw}C_cC_L)
\end{align}\]</span></p>
<p><span class="math inline">\(s^1\)</span> term in denominator <span
class="math display">\[
H_1=s(R_{o1}\cdot
g_{m2}R_{o2}C_c+R_{o1}C_{o1}+R_cC_c+R_{o1}C_c+R_{o2}C_c+R_{o2}C_L+R_{sw}C_L)
\]</span> <span class="math inline">\(s^0\)</span> term in denominator
<span class="math display">\[
H_0=1
\]</span> set <span class="math inline">\(R_c=0\)</span> and <span
class="math inline">\(R_{sw}=0\)</span>, the <span
class="math inline">\(H_*\)</span> reduced to <span
class="math display">\[\begin{align}
H_3 &amp;= 0 \\
H_2 &amp;=s^2R_{o1}R_{o2}(C_{o1}C_c+C_{o1}C_L+C_cC_L) \\
H_1&amp;=s(R_{o1}\cdot
g_{m2}R_{o2}C_c+R_{o1}C_{o1}+R_{o1}C_c+R_{o2}C_c+R_{o2}C_L) \\
H_0&amp;=1
\end{align}\]</span> That is <span class="math display">\[
H=s^2R_{o1}R_{o2}(C_{o1}C_c+C_{o1}C_L+C_cC_L)+s(R_{o1}\cdot
g_{m2}R_{o2}C_c+R_{o1}C_{o1}+R_{o1}C_c+R_{o2}C_c+R_{o2}C_L)+1
\]</span></p>
<p>which is same with our previous analysis of <em>Generic circuit in
textbook</em></p>
<p>And we know <span class="math display">\[
\frac{V_o}{V_{o2}}=\frac{1}{1+sR_{sw}C_L}
\]</span> Finally, we get <span
class="math inline">\(\frac{V_o}{V_i}\)</span> <span
class="math display">\[\begin{align}
\frac{V_o}{V_i} &amp;= \frac{V_{o2}}{V_i} \cdot \frac{V_o}{V_{o2}} \\
&amp;= -g_{m2}R_{o2}\frac{\left[ sC_c(R_c-1/g_{m2})+1
\right](sR_{sw}C_L+1)}{H_3+H_2+H_1+1} \cdot \frac{1}{1+sR_{sw}C_L} \\
&amp;= -g_{m2}R_{o2}\frac{ sC_c(R_c-1/g_{m2})+1}{H_3+H_2+H_1+1}
\end{align}\]</span></p>
<p>The loop transfer function is <span class="math display">\[
\frac{V_o}{V_i} =-g_{m1}R_{o1}g_{m2}R_{o2}\frac{
sC_c(R_c-1/g_{m2})+1}{H_3+H_2+H_1+1}
\]</span></p>
<h4 id="vccs-model">vccs model</h4>
<p><img src="/2023/01/03/pole-splitting/image-20230106214027323.png"
alt="image-20230106214027323" /></p>
<h4 id="simplify-the-transfer-function">simplify the transfer
function</h4>
<h5 id="omit-c_o1">omit <span class="math inline">\(C_{o1}\)</span></h5>
<p>We omit <span class="math inline">\(C_{o1}\)</span> in frequency
range of interest</p>
<p><span class="math display">\[\begin{align}
H_3 &amp;= 0 \\
H_2 &amp;=s^2(R_{o2}R_c+R_{o1}R_{o2}+R_{o2}R_{sw}+R_{o1}R_{sw}\cdot
g_{m2}R_{o2}+R_{sw}R_c+R_{o1}R_{sw})\cdot C_cC_L \\
H_1 &amp;=s(R_{o1}\cdot
g_{m2}R_{o2}C_c+R_cC_c+R_{o1}C_c+R_{o2}C_c+R_{o2}C_L+R_{sw}C_L) \\
H_0 &amp;= 1
\end{align}\]</span></p>
<blockquote>
<p>two poles and 1 zero</p>
</blockquote>
<p><img src="/2023/01/03/pole-splitting/image-20230105221058404.png"
alt="image-20230105221058404" /></p>
<h5 id="more-simplification">more simplification</h5>
<p>Then, some terms can be omitted</p>
<p><span class="math display">\[\begin{align}
H_2 &amp;=s^2R_{o1}R_{o2}(1+g_{m2}R_{sw})\cdot C_cC_L \\
H_1 &amp;=sR_{o1}\cdot g_{m2}R_{o2}C_c \\
H_0 &amp;= 1
\end{align}\]</span></p>
<p>The poles can be deduced <span class="math display">\[\begin{align}
\omega_1 &amp;= \frac{1}{R_{o1}\cdot g_{m2}R_{o2}C_c} \\
\omega_2 &amp;= \frac{1}{1+g_{m2}R_{sw}}\cdot \frac{g_{m2}}{C_L} \\
&amp;= \frac{1}{(gm_2^{-1}+R_{sw})C_L}
\end{align}\]</span></p>
<p>The pole <span
class="math inline">\(\omega_2=\frac{1}{gm_2^{-1}C_L}\)</span> is
changed to <span
class="math inline">\(\omega_2=\frac{1}{(gm_2^{-1}+R_{sw})C_L}\)</span></p>
<blockquote>
<p>In order to cancell <span class="math inline">\(\omega_2\)</span>
with <span class="math inline">\(\omega_z\)</span>, <span
class="math inline">\(R_c\)</span> shall be increased</p>
</blockquote>
<p><span class="math display">\[
R_{eq}=g_{m2}^{-1}+R_{sw}
\]</span> <img src="/2023/01/03/pole-splitting/fndRsw.drawio.svg"
alt="fndRsw.drawio.svg" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105221201876.png"
alt="image-20230105221201876" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105220034632.png"
alt="image-20230105220034632" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105220102170.png"
alt="image-20230105220102170" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105220119502.png"
alt="image-20230105220119502" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105221805322.png"
alt="image-20230105221805322" /></p>
<blockquote>
<p><strong>omit <span class="math inline">\(C_{o1}\)</span></strong> is
same with <strong>2nd system</strong> simplification</p>
</blockquote>
<h3 id="non-dominant-pole-in-sansens-book">non-dominant pole in Sansen's
book</h3>
<p><img src="/2023/01/03/pole-splitting/image-20230103231300609.png"
alt="image-20230103231300609" /></p>
<p>Following demonstrate how derive <span
class="math inline">\(f_{nd}\)</span> from Razavi's equation. We copy
<span class="math inline">\(\omega_2\)</span> here <span
class="math display">\[
\omega_2 = \frac{R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c)}{R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)}
\]</span> which can be reduced as below</p>
<p><span class="math display">\[\begin{align}
\omega_2 &amp;= \frac{R_{o1}C_c\cdot
g_{m2}R_{o2}+R_{o2}(C_c+C_L)+R_{o1}(C_{o1}+C_c)}{R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)}
\\
&amp;= \frac{R_{o1}C_c\cdot
g_{m2}R_{o2}}{R_{o1}R_{o2}(C_cC_{o1}+C_LC_{o1}+C_LC_c)} \\
&amp;= \frac{C_c\cdot g_{m2}}{C_cC_{o1}+C_LC_{o1}+C_LC_c} \\
&amp;= \frac{g_{m2}}{C_{o1}+C_L\frac{C_{o1}}{C_c}+C_L} \\
&amp;= \frac{g_{m2}}{C_L\frac{C_{o1}}{C_c}+C_L} \\
&amp;= \frac{g_{m2}}{C_L} \cdot \frac{1}{1+\frac{C_{o1}}{C_c}}
\end{align}\]</span></p>
<p><img src="/2023/01/03/pole-splitting/image-20230129221424763.png"
alt="image-20230129221424763" /></p>
<h3 id="exercise-of-2-stage-opamp">Exercise of 2-stage opamp</h3>
<p><img src="/2023/01/03/pole-splitting/image-20230105001747174.png"
alt="image-20230105001747174" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105001758050.png"
alt="image-20230105001758050" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105001812304.png"
alt="image-20230105001812304" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105001849554.png"
alt="image-20230105001849554" /></p>
<blockquote>
<p><span class="math inline">\(R_{o1}\)</span> and <span
class="math inline">\(R_{o2}\)</span> don't affect stability, if <span
class="math inline">\(f_{nd}&gt;3\text{GBW}\)</span></p>
<p>DC gain: <span
class="math inline">\(g_{m1}g_{m2}R_{o1}R_{o2}\)</span></p>
<p>dominant pole: <span
class="math inline">\(\omega_d=\frac{1}{R_{o1}\cdot
g_{m2}R_{o2}C_c}\)</span></p>
</blockquote>
<p><img src="/2023/01/03/pole-splitting/image-20230105001923985.png"
alt="image-20230105001923985" /></p>
<p><img src="/2023/01/03/pole-splitting/image-20230105002653735.png"
alt="image-20230105002653735" /></p>
<blockquote>
<p><span
class="math inline">\(20log_{10}(1.414^2)=6\text{dB}\)</span></p>
</blockquote>
<h3 id="reference">reference</h3>
<p>Razavi, Behzad. Design of Analog CMOS Integrated Circuits. India:
McGraw-Hill, 2017.</p>
<p>Sansen, Willy M. Analog Design Essentials. Germany: Springer US,
2006.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>plusargs in verilog</title>
    <url>/2022/06/04/plusargs-verilog/</url>
    <content><![CDATA[<p><strong>plusargs</strong> are command-line switches supported by the
simulator. As per SystemVerilog LRM arguments beginning with the
<code>+</code> character will be available using the
<code>$test$plusargs</code> and <code>$value$plusargs</code> <strong>PLI
APIs</strong>.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$test$plusargs (user_string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">$value$plusargs</span> (user_string, variable)</span><br></pre></td></tr></table></figure>
<h4 id="example">Example</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tb.v</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>($test$plusargs(<span class="string">&quot;RUNSIM&quot;</span>)) <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span>(<span class="string">&quot;There is RUNSIM plusargs&quot;</span>);</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span>(<span class="string">&quot;There is NO $test$plusargs&quot;</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">$value$plusargs</span>(<span class="string">&quot;SEED=%d&quot;</span>,a)) <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span>(<span class="string">&quot;SEED=%d&quot;</span>,a);</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span>(<span class="string">&quot;There is NO $value$plusargs&quot;</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>compile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vlib work</span><br><span class="line">$ vlog -sv tb.v</span><br></pre></td></tr></table></figure></li>
<li><p>simulate (<em>QuestaSim</em>)</p>
<ul>
<li><p>with<strong>out</strong> plusargs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vsim work.tb -c -do &quot;run; exit&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># //</span><br><span class="line"># Loading sv_std.std</span><br><span class="line"># Loading work.tb(fast)</span><br><span class="line"># run</span><br><span class="line"># There is NO $test$plusargs</span><br><span class="line"># There is NO $value$plusargs</span><br><span class="line">#  exit</span><br><span class="line"># End time: 13:04:23 on Jun 04,2022, Elapsed time: 0:00:01</span><br><span class="line"># Errors: 0, Warnings: 0</span><br></pre></td></tr></table></figure></li>
<li><p>with plusargs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vsim work.tb -c -do &quot;run; exit&quot; +SEED=31 +RUNSIM</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>+SEED=31 +RUNSIM</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># //</span><br><span class="line"># Loading sv_std.std</span><br><span class="line"># Loading work.tb(fast)</span><br><span class="line"># run</span><br><span class="line"># There is RUNSIM plusargs</span><br><span class="line"># SEED=         31</span><br><span class="line">#  exit</span><br><span class="line"># End time: 13:04:55 on Jun 04,2022, Elapsed time: 0:00:01</span><br><span class="line"># Errors: 0, Warnings: 0</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="reference">reference</h4>
<p>systemverilog-command-line-input URL: <a
href="https://www.chipverify.com/systemverilog/systemverilog-command-line-input">https://www.chipverify.com/systemverilog/systemverilog-command-line-input</a></p>
<p>PLUSARGS IN SYSTEMVERILOG URL:<a
href="https://www.theartofverification.com/plusargs-in-systemverilog/">https://www.theartofverification.com/plusargs-in-systemverilog/</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Power/Ground and I/O Pins</title>
    <url>/2022/03/06/power-ground-io/</url>
    <content><![CDATA[<h4 id="power-ground-pin-information">Power / Ground Pin
Information</h4>
<p>In both digital and analog I/O, power and ground pins appear at the
sub-circuit definiton, allowing user to use the I/O in voltage islands.
They follow certain naming conventions.</p>
<ol type="1">
<li>digital I/O sub-circuit</li>
</ol>
<ul>
<li>VDD: pre-driver core voltage (supplied by PVDD1CDGM)</li>
<li>VSS: pre-driver ground and also global ground (supplied by
PVDD1CDGM)</li>
<li>VDDPST: I/O post-driver voltage, i.e. 1.8V (supplied by PVDD2CDGM or
PVDD2POCM)</li>
<li>VSSPOST: I/O post-driver ground (supplied by PVDD2CDGM or
PVDD2POCM)</li>
<li>POCCTRL: POCCTRL signal (supplied by PVDD2POCM)</li>
</ul>
<ol start="2" type="1">
<li>analog I/O placed in a core voltage domain, the convention is</li>
</ol>
<ul>
<li>TACVDD: analog core voltage (supplied by PVDD3ACM)</li>
<li>TACVSS: analog core ground (supplied by PVDD3ACM)</li>
<li>VSS: global core ground</li>
</ul>
<ol start="3" type="1">
<li>analog I/O placed in an I/O voltage domain, the convention is:</li>
</ol>
<ul>
<li>TAVDD: analog I/O voltage, i.e. 1.8V (supplied by PVDD3AM)</li>
<li>TAVSS: analog I/O ground (supplied by PVDD3AM)</li>
<li>VSS: global core ground</li>
</ul>
<p>Power/Ground <strong>Combo Cells</strong></p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 36%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>power/ground combo pad cell</th>
<th>pins to be connected to bump</th>
<th>to core side pin name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PVDD1CDGM</td>
<td>VDD VSS</td>
<td>VDD VSS</td>
</tr>
<tr class="even">
<td>PVDD2CDGM PVDD2POCM</td>
<td>VDDPST VSSPST</td>
<td>N/A</td>
</tr>
<tr class="odd">
<td>PVDD3AM</td>
<td>TAVDD TAVSS</td>
<td>AVDD AVSS</td>
</tr>
<tr class="even">
<td>PVDD3ACM</td>
<td>TACVDD TACVSS</td>
<td>AVDD AVSS</td>
</tr>
</tbody>
</table>
<h4 id="note-for-the-retention-mode">Note for the retention mode</h4>
<ol type="1">
<li>At initial state, IRTE must be <strong>0</strong> when VDD is
off.</li>
<li>IRTE must be kept &gt;= 10us after VDD turns on again (from the
retention mode to the normal operation mode).</li>
<li>IRTE can be switched only when both VDD and VDDPST are on.</li>
</ol>
<p><img src="/2022/03/06/power-ground-io/rention_seq.drawio.svg"
alt="rention_seq.drawio" /></p>
<p>When the rention function is needed, IRTE signal must come from an
"always-on" core power domain. If you don't need the rention function,
it is required to tie IRTE to ground. In other words, <strong>no matter
the rention feature is needed or not, it is required to have PCBRTE in
each domain</strong>.</p>
<p><img
src="/2022/03/06/power-ground-io/PCBRTE_in_digital_domain.drawio.svg"
alt="PCBRTE_in_digital_domain.drawio" /></p>
<p><strong>Note</strong>: PCBRTE <strong>does not</strong> need PAD
connection.</p>
<h4 id="internal-pins">Internal Pins</h4>
<p>There are 3 internal global pins, i.e. <strong>ESD</strong>,
<strong>POCCTRL</strong>, <strong>RTE</strong>, in all digital domain
cells.</p>
<p>In real application,</p>
<ul>
<li><strong>ESD pin</strong> is an internal signal and
<strong>active</strong> in ESD event happening</li>
<li><strong>POCCTRL</strong> is an internal signal and active in
Power-on-control event.</li>
</ul>
<p>However, these special events (i.e. ESD event and Power-on-control
event) are not modeled in NLDM kit (.lib), only normal function is
covered, so <strong>ESD</strong> and <strong>POCCTRL</strong> pins are
simply defined as ground in NLDM kit (.lib).</p>
<blockquote>
<p>These 3 global pins will be connected automatically after
<strong>cell-to-cell abutting</strong> in physical layout.</p>
</blockquote>
<h4 id="power-up-sequence-in-digital-domain">Power-Up sequence in
Digital Domain</h4>
<p>Power up the I/O power (VDDPST) first, then the core power (VDD)</p>
<p><img src="/2022/03/06/power-ground-io/pocctrl_seq.drawio.svg"
alt="pocctrl_seq.drawio" /></p>
<ol type="1">
<li>PVDDD2POCM cell would generate Power-On-Control signal (POCCTRL) to
have the post-driver NMOS and PMOS off, so that the crowbar current
would not occur in the post-driver fingers when the I/O voltage is on
while the core voltage remains off. As such, I/O cell would be in the
Hi-Z state. when POCCTRL is on, the pll-up/down resistor is disabled and
C is 0.</li>
<li>The POCCTRL signal is transmitted to I/O cells through <strong>cell
abutment</strong>. There is no need to have routing for POCCTTRL nor
give a control signal to the POCCTRL pin any of I/O cells. Note that the
POCCTRL signal would be cut if inserting a power-cut (PRCUT) cell.</li>
</ol>
<p><img
src="/2022/03/06/power-ground-io/power-on-control-ciruit.drawio.svg"
alt="power-on-control-ciruit.drawio" /></p>
<h4 id="power-down-sequence-in-digital-domain">Power-Down sequence in
Digital Domain</h4>
<p>It's the reverse of power-up sequence.</p>
<h4 id="use-model-in-innovus">Use model in Innovus</h4>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> init_gnd_net <span class="string">&quot;vss_core vss DUMMY_ESD DUMMY_POCCTRL&quot;</span></span><br><span class="line"></span><br><span class="line">addInst -moduleBased u_io -ori R270 -physical -status fixed -loc <span class="number">135</span> <span class="number">994</span> -inst u_io/VDDIO_1 -cell PVDD2CDGM_H</span><br><span class="line"></span><br><span class="line">addNet u_io_RTE</span><br><span class="line">attachTerm FILLER_6 RTE u_io_RTE</span><br><span class="line">attachTerm VDDIO_1 RTE u_right_RTE</span><br><span class="line">setAttribute -skip_routing true -net u_io_RTE</span><br><span class="line"></span><br><span class="line">clearGlobalNets</span><br><span class="line">globalNetConnect DUMMY_POCCTRL -type pgpin -pin POCCTRL -singleInstance u_io/VDDDIO_1 -override</span><br><span class="line">globalNetConnect DUMMY_ESD -type pgpin -pin ESD -singleInstance u_io/VDDDIO_1 -override</span><br></pre></td></tr></table></figure>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> pins [get_object_name [get_ports *]]</span><br><span class="line"><span class="keyword">foreach</span> pin <span class="variable">$pins</span> &#123;</span><br><span class="line">	<span class="keyword">set</span> netPtr [dbGetNetByName <span class="variable">$pin</span>]</span><br><span class="line">	<span class="keyword">if</span> &#123; <span class="variable">$netPtr</span> == <span class="string">&quot;0x0&quot;</span> &#125; &#123;</span><br><span class="line">		<span class="keyword">puts</span> <span class="string">&quot;INFO: can&#x27;t find the port: $pin&quot;</span></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		setAttribute -net <span class="variable">$pin</span> -skip_routing true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> net [get_object_name [get_nets -of_objects [get_pins */RTE -hierarchical]]] &#123;</span><br><span class="line">	setAttribute -net <span class="variable">$net</span> -skip_routing true</span><br><span class="line">	dbSet [dbGetNetByName <span class="variable">$net</span>].dontTouch true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Power Spectra and Power Spectral Densities</title>
    <url>/2022/04/18/ps-psd/</url>
    <content><![CDATA[<p>One will see the following phenomena:</p>
<ol type="1">
<li>A power spectrum is equal to the square of the absolute value of
DFT.</li>
<li>The sum of all power spectral lines in a power spectrum is equal to
the power of the input signal.</li>
<li>The integral of a PSD is equal to the power of the input
signal.</li>
</ol>
<blockquote>
<p>power spectrum has units of <span class="math inline">\(V^2\)</span>
and power spectral density has units of <span
class="math inline">\(V^2/Hz\)</span></p>
</blockquote>
<p><strong>Parseval's theorem</strong> is a property of the Discrete
Fourier Transform (DFT) that states: <span class="math display">\[
\sum_{n=0}^{N-1}|x(n)|^2 = \frac{1}{N}\sum_{k=0}^{N-1}|X(k)|^2
\]</span> Multiply both sides of the above by <span
class="math inline">\(1/N\)</span>: <span class="math display">\[
\frac{1}{N}\sum_{n=0}^{N-1}|x(n)|^2 =
\frac{1}{N^2}\sum_{k=0}^{N-1}|X(k)|^2
\]</span> <span class="math inline">\(|x(n)|^2\)</span> is instantaneous
power of a sample of the time signal. So the left side of the equation
is just the <strong>average power</strong> of the signal over the N
samples. <span class="math display">\[
P_{\text{av}} = \frac{1}{N^2}\sum_{k=0}^{N-1}|X(k)|^2\text{,   }V^2
\]</span> For the each DFT bin, we can say: <span
class="math display">\[
P_{\text{bin}}(k) = \frac{1}{N^2}|X(k)|^2\text{,
k=0:N-1,  }V^2/\text{bin}
\]</span> This is the power spectrum of the signal.</p>
<p>Note that <span class="math inline">\(X(k)\)</span> is the
<strong>two-sided spectrum</strong>. If <span
class="math inline">\(x(n)\)</span> is real, then <span
class="math inline">\(X(k)\)</span> is symmetric about <span
class="math inline">\(fs/2\)</span>, with each side containing half of
the power. In that case, we can choose to keep just the
<strong>one-sided spectrum</strong>, and multiply Pbin by 2
(<strong>except DC &amp; Nyquist</strong>):</p>
<p><span class="math display">\[
P_{\text{bin,one-sided}}(k) = \left\{ \begin{array}{cl}
\frac{1}{N^2}|X(0)|^2 &amp; : \ k = 0 \\
\frac{2}{N^2}|X(k)|^2 &amp; : \ 1 \leq k \leq N/2-1 \\
\frac{1}{N^2}|X(N/2)|^2 &amp; : \ k = N/2
\end{array} \right.
\]</span></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">rng default</span><br><span class="line">Fs = <span class="number">1000</span>;</span><br><span class="line">t = <span class="number">0</span>:<span class="number">1</span>/Fs:<span class="number">1</span><span class="number">-1</span>/Fs;</span><br><span class="line">x = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">100</span>*t) + <span class="built_in">randn</span>(<span class="built_in">size</span>(t));</span><br><span class="line">N = <span class="built_in">length</span>(x);</span><br><span class="line">xdft = fft(x);</span><br><span class="line">xsq_sum_avg = sum(x.^<span class="number">2</span>)/N;</span><br><span class="line">specsq_sum_avg = sum(<span class="built_in">abs</span>(xdft).^<span class="number">2</span>)/N^<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>where <code>xsq_sum_avg</code> is same with
<code>specsq_sum_avg</code></p>
<blockquote>
<p>For a discrete-time sequence x(n), the DFT is defined as: <span
class="math display">\[
X(k) = \sum_{n=0}^{N-1}x(n)e^{-j2\pi kn/N}
\]</span> By it definition, the DFT does <strong>NOT</strong> apply to
infinite duration signals.</p>
</blockquote>
<h2 id="scaling-dft-results">scaling DFT results</h2>
<table>
<thead>
<tr class="header">
<th>spectra type</th>
<th>unit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>amplitude spectrum</td>
<td>V</td>
</tr>
<tr class="even">
<td>power spectrum</td>
<td>V^2</td>
</tr>
<tr class="odd">
<td>power spectrum density</td>
<td>V^2/Hz</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a
href="https://appliedacousticschalmers.github.io/scaling-of-the-dft/AES2020_eBrief/">Tutorial
on Scaling of the Discrete Fourier Transform and the Implied Physical
Units of the Spectra of Time-Discrete Signals <em>Jens Ahrens, Carl
Andersson, Patrik Höstmad, Wolfgang Kropp</em></a></p>
</blockquote>
<p>Different scaling is needed to apply for amplitude spectrum, power
spectrum and power spectrum density, which shown as below</p>
<p><img src="/2022/04/18/ps-psd/image-20220427220639646.png"
alt="image-20220427220639646" /></p>
<blockquote>
<p><span class="math inline">\(f_s\)</span> in Eq.(13) is <strong>sample
rate</strong> rather than frequency resolution.</p>
</blockquote>
<p>And Eq.(13) can be expressed as <span class="math display">\[
\text{PSD}(k) =\frac{1}{f_{\text{res}}\cdot
N\sum_{n}w^2(n)}\left|X_{\omega}(k)\right|^2
\]</span> where <span class="math inline">\(f_{\text{res}}\)</span> is
frequency resolution</p>
<p>We define the following two sums for normalization purposes:</p>
<p><span class="math display">\[\begin{align}
S_1 &amp;= \sum_{j=0}^{N-1}w_j \\
S_2 &amp;= \sum_{j=0}^{N-1}w_j^2
\end{align}\]</span></p>
<p>Given Eq.(12) and Eq.(13) <span class="math display">\[\begin{align}
\text{PS(k)} &amp;= \text{PSD(k)} \cdot \frac{f_s
\sum_{n}w^2(n)}{(\sum_{n}\omega(n))^2} \\
&amp;= \text{PSD(k)} \cdot f_{\text{res}} \cdot \frac{N
\sum_{n}w^2(n)}{(\sum_{n}w(n))^2} \\
&amp;= \text{PSD(k)} \cdot f_{\text{res}} \cdot \frac{N S_2}{S_1^2} \\
&amp;= \text{PSD(k)} \cdot f_{\text{res}} \cdot \text{NENBW} \\
&amp;= \text{PSD(k)} \cdot \text{ENBW}
\end{align}\]</span></p>
<p>where <strong>Normalized Equivalent Noise BandWidth</strong> is
defined as <span class="math display">\[
\text{NENBW} =\frac{N S_2}{S_1^2}
\]</span> and <strong>Effective Noise BandWidth</strong> is <span
class="math display">\[
\text{ENBW} =f_{\text{res}} \cdot \frac{N S_2}{S_1^2}
\]</span></p>
<blockquote>
<p>For Rectangular window, <span class="math inline">\(\text{ENBW}
=f_{\text{res}}\)</span></p>
<p>This <em>equivalent noise bandwidth</em> is required when the
resulting spectrum is to be expressed as <em>spectral density (such as
for noise measurements)</em>.</p>
</blockquote>
<p><em>Eq.(13) Example:</em></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Fs = <span class="number">1024</span>; </span><br><span class="line">t  = (<span class="number">0</span>:<span class="number">1</span>/Fs:<span class="number">1</span><span class="number">-1</span>/Fs).&#x27;; </span><br><span class="line">x  = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t*<span class="number">200</span>);</span><br><span class="line">Nx = <span class="built_in">length</span>(x);</span><br><span class="line"><span class="comment">% Window data</span></span><br><span class="line">w = hamming(Nx);	<span class="comment">% hamming window</span></span><br><span class="line">xw = x.*w; </span><br><span class="line"><span class="comment">% Calculate power</span></span><br><span class="line">nfft = Nx; </span><br><span class="line">X = fft(xw,nfft);</span><br><span class="line"></span><br><span class="line">NumUniquePts = nfft/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">Pxx1 = <span class="built_in">abs</span>(X(<span class="number">1</span>:NumUniquePts)).^<span class="number">2</span>/sum(w.^<span class="number">2</span>)/Fs;    <span class="comment">%!!! Eq.(13)</span></span><br><span class="line">Pxx1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>) = Pxx1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)*<span class="number">2</span>;    <span class="comment">% twosided -&gt; onesided</span></span><br><span class="line">Fx1 = (<span class="number">0</span>:NumUniquePts<span class="number">-1</span>)*Fs/nfft; </span><br><span class="line"></span><br><span class="line">[Pxx2,Fx2] = pwelch(x,w,<span class="number">0</span>,nfft,Fs);</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(Fx1,<span class="number">10</span>*<span class="built_in">log10</span>(Pxx1),Fx2,<span class="number">10</span>*<span class="built_in">log10</span>(Pxx2),<span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;PSD via Eq.(13)&#x27;</span>,<span class="string">&#x27;PSD via pwelch&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/18/ps-psd/image-20220514165525958.png"
alt="image-20220514165525958" /></p>
<h2 id="window-effects">window effects</h2>
<p>It is possible to correct both the amplitude and energy content of
the windowed signal to equal the original signal. However, both
corrections cannot be applied simultaneously</p>
<h3 id="amplitude-correction">Amplitude correction</h3>
<p><em>Linear (amplitude) Spectrum</em> <span class="math display">\[
X(k) = \frac{X_{\omega}(k)}{S_1}
\]</span> <em>power spectrum</em> <span class="math display">\[
\text{PS}=\frac{\left| X_{\omega}(k) \right|^2}{S_1^2}
\]</span></p>
<blockquote>
<p>usage: tone amplitude</p>
</blockquote>
<h3 id="power-correction">Power correction</h3>
<p><strong>power spectral density (PSD)</strong> <span
class="math display">\[
\text{PSD} =\frac{\left|X_{\omega}(k)\right|^2}{f_s\cdot S_2}
\]</span></p>
<blockquote>
<p>We have <span class="math inline">\(\text{PSD} =
\frac{\text{PS}}{\text{ENBW}}\)</span>, where <span
class="math inline">\(\text{ENBW}=\frac{N \cdot
S_2}{S_1^2}f_{\text{res}}\)</span></p>
</blockquote>
<p><strong>linear power spectrum</strong> <span class="math display">\[
\text{PS}_L=\frac{|X_{\omega}(k)|^2}{N\cdot S_2}
\]</span></p>
<blockquote>
<p>usage: RMS value, total power <span class="math display">\[
\text{PS}_L(k)=\text{PSD(k)} \cdot f_{\text{res}}
\]</span></p>
</blockquote>
<h3 id="window-correction-factors">Window Correction Factors</h3>
<p>While a window helps reduce leakage (The window reduces the jumps at
the ends of the repeated signal), the window itself distorts the data in
two different ways:</p>
<ul>
<li><p><strong>Amplitude</strong> – The <em>amplitude</em> of the signal
is reduced</p>
<blockquote>
<p>This is due to the fact that the window removes information in the
signal</p>
</blockquote></li>
<li><p><strong>Energy</strong> – The <em>area</em> under the curve, or
energy of the signal, is reduced</p></li>
</ul>
<p><img src="/2022/04/18/ps-psd/rtaImage.png" alt="rtaImage" /></p>
<p><strong>Window correction factors</strong> are used to try and
compensate for the effects of applying a window to data. There are both
amplitude and energy correction factors.</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 43%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th>Window Type</th>
<th>Amplitude Correction (<span class="math inline">\(K_a\)</span>)</th>
<th>Energy Correction (<span class="math inline">\(K_e\)</span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rectangluar</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>hann</td>
<td>1.9922</td>
<td>1.6298</td>
</tr>
<tr class="odd">
<td>blackman</td>
<td>2.3903</td>
<td>1.8155</td>
</tr>
<tr class="even">
<td>kaiser</td>
<td>1.0206</td>
<td>1.0204</td>
</tr>
</tbody>
</table>
<p>Only the Uniform window (rectangular window), which is equivalent to
no window, has the same amplitude and energy correction factors.</p>
<p><span class="math display">\[\begin{align}
X(k) &amp;= \frac{X_\omega(k)}{\sum_n w(n)} \\
&amp;= \frac{N}{\sum_n w(n)} \frac{X_\omega(k)}{N} \\
&amp;= K_a \cdot \frac{X_\omega(k)}{N}
\end{align}\]</span> where <span class="math inline">\(K_a =
\frac{N}{\sum_n \omega(n)}\)</span></p>
<blockquote>
<p>In literature, <strong>Coherent power gain</strong> is defined show
below, which is close related to <span
class="math inline">\(K_a\)</span> <span class="math display">\[
\text{Coherent power gain (dB)} = 20 \; log_{10} \left( \frac{\sum_n
w[n]}{N} \right)
\]</span></p>
</blockquote>
<p><img src="/2022/04/18/ps-psd/amplitude-correction.png"
alt="amplitude-correction" /></p>
<blockquote>
<p>With amplitude correction, by multiplying by two, the <em>peak
value</em> of both the original and corrected spectrum match. However
the energy content is not the same.</p>
<p>The amplitude corrected signal (red) appears to have more energy, or
area under the curve, than the original signal (blue).</p>
</blockquote>
<p><span class="math display">\[\begin{align}
\text{PSD} &amp;=\frac{1}{f_{\text{res}}\cdot
N\sum_{n}w^2(n)}\left|X_{\omega}(K)\right|^2 \\
&amp;= \frac{N}{\sum_{n}w^2(n)}
\frac{\left|X_{\omega}(K)\right|^2}{f_{\text{res}}\cdot N^2} \\
&amp;=\left|K_e \cdot \frac{X_{\omega}(K)}{N}\right|^2 \cdot
\frac{1}{f_{\text{res}}}
\end{align}\]</span></p>
<p>wherer <span class="math inline">\(K_e =
\sqrt{\frac{N}{\sum_{n}\omega^2(n)}}\)</span></p>
<p><img src="/2022/04/18/ps-psd/energey-correction.png"
alt="energey-correction" /></p>
<blockquote>
<p>Multiplying the values in the spectrum by 1.63, rather than 2, makes
the <em>area</em> under the curve the same for both the original signal
(blue) and energy corrected signal (red)</p>
</blockquote>
<p><strong>hanning</strong>'s correction factors:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">256</span>;</span><br><span class="line">w = hanning(N);</span><br><span class="line">Ka = N/sum(w)</span><br><span class="line">Ke = <span class="built_in">sqrt</span>(N/sum(w.^<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ka =</span><br><span class="line"></span><br><span class="line">    1.9922</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ke =</span><br><span class="line"></span><br><span class="line">    1.6298</span><br></pre></td></tr></table></figure>
<h3 id="amplitudepower-correction-example">Amplitude,Power Correction
Example</h3>
<p><img src="/2022/04/18/ps-psd/image-20220518002927545.png"
alt="image-20220518002927545" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 200 Hz, amplitude 1 and 200/3 Hz amplitude 0.3</span></span><br><span class="line">fosc = <span class="number">200</span>;</span><br><span class="line">Fs = <span class="number">8192</span>;</span><br><span class="line">Nx = Fs*<span class="number">4</span>;</span><br><span class="line">tstop = Nx/Fs;</span><br><span class="line">t  = (<span class="number">0</span>:<span class="number">1</span>/Fs:tstop<span class="number">-1</span>/Fs).&#x27;; </span><br><span class="line">x  = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t*fosc) + <span class="number">0.3</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t*fosc/<span class="number">3</span>);</span><br><span class="line">Nx = <span class="built_in">length</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% direct method, time domain</span></span><br><span class="line">P0 = sum(x.^<span class="number">2</span>)/Nx;</span><br><span class="line">xrms0 = <span class="built_in">sqrt</span>(P0);   <span class="comment">% RMS value caculated by time domain</span></span><br><span class="line">fprintf(<span class="string">&quot;xrms0: %.4f\n&quot;</span>, xrms0);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Window data</span></span><br><span class="line">w = hamming(Nx);	<span class="comment">% hamming window</span></span><br><span class="line"><span class="comment">%w = ones(Nx, 1);	% rectangular window</span></span><br><span class="line"></span><br><span class="line">S1= sum(w);</span><br><span class="line">S2 = sum(w.^<span class="number">2</span>);</span><br><span class="line">NENBW = Nx*S2/S1^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">xw = x.*w; </span><br><span class="line">nfft = Nx; </span><br><span class="line">X = fft(xw,nfft);   <span class="comment">% windowed signal fft</span></span><br><span class="line">NumUniquePts = nfft/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">Fx1 = (<span class="number">0</span>:NumUniquePts<span class="number">-1</span>)*Fs/nfft;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% fft - ps -&gt; rms</span></span><br><span class="line">Xmag = <span class="built_in">abs</span>(X);</span><br><span class="line">PS1 = Xmag.^<span class="number">2</span>/S1^<span class="number">2</span>;    <span class="comment">%!!! Eq.(12)</span></span><br><span class="line">PS1 = PS1(<span class="number">1</span>:NumUniquePts);</span><br><span class="line">PS1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>) = PS1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)*<span class="number">2</span>;    <span class="comment">% twosided -&gt; onesided</span></span><br><span class="line">Pmax_fft = <span class="built_in">max</span>(PS1);    <span class="comment">% !!! amplitude OK</span></span><br><span class="line">fprintf(<span class="string">&quot;Pmax_fft: %.4f\n&quot;</span>, Pmax_fft);</span><br><span class="line"></span><br><span class="line"><span class="comment">% linear power spectrum</span></span><br><span class="line">PSL_fft = Xmag.^<span class="number">2</span>/nfft/S2;</span><br><span class="line">PSL_fft = PSL_fft(<span class="number">1</span>:NumUniquePts);</span><br><span class="line">PSL_fft = PSL_fft(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">Ptot_fft1 = sum(PSL_fft);</span><br><span class="line">xrms_PSL = <span class="built_in">sqrt</span>(Ptot_fft1); <span class="comment">% !!! power OK</span></span><br><span class="line">fprintf(<span class="string">&quot;xrms_PSL: %.4f\n&quot;</span>, xrms_PSL);</span><br><span class="line"></span><br><span class="line"><span class="comment">% use psd*fres to calculate total power</span></span><br><span class="line">Pxx1 = <span class="built_in">abs</span>(X(<span class="number">1</span>:NumUniquePts)).^<span class="number">2</span>/sum(w.^<span class="number">2</span>)/Fs;    <span class="comment">%!!! Eq.(13)</span></span><br><span class="line">Pxx1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>) = Pxx1(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>)*<span class="number">2</span>;    <span class="comment">% twosided -&gt; onesided</span></span><br><span class="line">Ptot_fft2 = sum(Pxx1*Fs/nfft);</span><br><span class="line">xrms_psd = <span class="built_in">sqrt</span>(Ptot_fft2);     <span class="comment">% !!! power OK</span></span><br><span class="line">fprintf(<span class="string">&quot;xrms_psd: %.4f\n&quot;</span>, xrms_psd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% pwelch</span></span><br><span class="line">[Pxx2,Fx2] = pwelch(x,w,<span class="number">0</span>,nfft,Fs);</span><br><span class="line">fres = Fx2(<span class="number">2</span>)-Fx2(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">PS2 = Pxx2*fres;</span><br><span class="line">Ptot_pwelch = sum(PS2);</span><br><span class="line">xrms_pwelch = <span class="built_in">sqrt</span>(Ptot_pwelch);    <span class="comment">% !!! amplitude OK</span></span><br><span class="line">fprintf(<span class="string">&quot;xrms_pwelch: %.4f\n&quot;</span>, xrms_pwelch);</span><br><span class="line"></span><br><span class="line"><span class="comment">% PS = PSD * ENBW always hold</span></span><br><span class="line">ENBW = fres * NENBW;</span><br><span class="line">PS2_pwelch = Pxx2*ENBW;</span><br><span class="line">Pmax_pwelch = <span class="built_in">max</span>(PS2_pwelch);  <span class="comment">% !!! amplitude OK</span></span><br><span class="line">fprintf(<span class="string">&quot;Pmax_pwelch: %.4f\n&quot;</span>, Pmax_pwelch);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot psd of two methods</span></span><br><span class="line"><span class="built_in">plot</span>(Fx1,<span class="number">10</span>*<span class="built_in">log10</span>(Pxx1),Fx2,<span class="number">10</span>*<span class="built_in">log10</span>(Pxx2),<span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;PSD via Eq.(13)&#x27;</span>,<span class="string">&#x27;PSD via pwelch&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Freq (Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;dB; V^2/Hz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xrms0: 0.7383</span><br><span class="line">Pmax_fft: 0.5000</span><br><span class="line">xrms_PSL: 0.7382</span><br><span class="line">xrms_psd: 0.7382</span><br><span class="line">xrms_pwelch: 0.7382</span><br><span class="line">Pmax_pwelch: 0.5000</span><br></pre></td></tr></table></figure>
<h2 id="rms">RMS</h2>
<p>We may also want to know for example the RMS value of the signal, in
order to know how much power the signal generates. This can be done
using Parseval’s theorem.</p>
<p>For a <strong>periodic</strong> signal, which has a discrete
spectrum, we obtain its total RMS value by summing the included signals
using <span class="math display">\[
x_{\text{rms}}=\sqrt{\sum R_{xk}^2}
\]</span> Where <span class="math inline">\(R_{xk}\)</span> is the RMS
value of each sinusoid for <span
class="math inline">\(k=1,2,3,...\)</span> The RMS value of a signal
consisting of a number of sinusoids is consequently equal to <strong>the
square root of the sum of the RMS values</strong>.</p>
<p>This result could also be explained by noting that sinusoids of
different frequencies are <strong>orthogonal</strong>, and can therefore
be summed like vectors (using <em>Pythagoras’ theorem</em>)</p>
<p>For a random signal we cannot interpret the spectrum in the same way.
As we have stated earlier, the PSD of a random signal contains all
frequencies in a particular frequency band, which makes it
<em>impossible to add the frequencies up</em>. Instead, as the PSD is a
density function, the correct interpretation is to sum the area under
the PSD in a specific frequency range, which then is the square of the
RMS, i.e., the mean-square value of the signal <span
class="math display">\[
x_{\text{rms}}=\sqrt{\int G_{xx}(f)df}=\sqrt{\text{area under the
curve}}
\]</span> The <strong>linear spectrum</strong>, or <strong>RMS
spectrum</strong>, defined by <span class="math display">\[\begin{align}
X_L(k) &amp;= \sqrt{\text{PSD(k)} \cdot f_{\text{res}}}\\
&amp;=\sqrt{\frac{\left|X_{\omega}(k)\right|^2}{f_{\text{res}}\cdot
N\sum_{n}\omega^2(n)} \cdot f_{\text{res}}} \\
&amp;= \sqrt{\frac{\left|X_{\omega}(k)\right|^2}{N\sum_{n}\omega^2(n)}}
\\
&amp;= \sqrt{\frac{|X_{\omega}(k)|^2}{N\cdot S_2}}
\end{align}\]</span></p>
<p>The corresponding <strong>linear power spectrum</strong> or
<strong>RMS power spectrum</strong> can be defined by <span
class="math display">\[\begin{align}
\text{PS}_L(k)&amp;=X_L(k)^2=\frac{|X_{\omega}(k)|^2}{S_1^2}\frac{S_1^2}{N\cdot
S_2} \\
&amp;=\text{PS}(k) \cdot \frac{S_1^2}{N\cdot S_2}
\end{align}\]</span></p>
<p>So, RMS can be calculated as below <span
class="math display">\[\begin{align}
P_{\text{tot}} &amp;= \sum \text{PS}_L(k) \\
\text{RMS} &amp;= \sqrt{P_{\text{tot}}}
\end{align}\]</span></p>
<h2 id="dft-averaging">DFT averaging</h2>
<p>we use <span class="math inline">\(N= 8*\text{nfft}\)</span> time
samples of <span class="math inline">\(x\)</span> and set the number of
overlapping samples to <span class="math inline">\(\text{nfft}/2 =
512\)</span>. <code>pwelch</code> takes the DFT of <span
class="math inline">\(\text{Navg} = 15\)</span> overlapping segments of
<span class="math inline">\(x\)</span>, each of length <span
class="math inline">\(\text{nfft}\)</span>, then averages the <span
class="math inline">\(|X(k)|^2\)</span> of the DFT’s.</p>
<p>In general, if there are an integer number of segments that cover all
samples of N, we have <span class="math display">\[
N = (N_{\text{avg}}-1)*D + \text{nfft}
\]</span> where <span
class="math inline">\(D=\text{nfft}-\text{noverlap}\)</span>. For our
case, with <span class="math inline">\(D = \text{nfft}/2\)</span> and
<span class="math inline">\(N/\text{nfft} = 8\)</span>, we have <span
class="math display">\[
N_{\text{avg}}=2*N/\text{nfft}-1=15
\]</span> For a given number of time samples N, using overlapping
segments lets us increase <span class="math inline">\(N_{avg}\)</span>
compared with no overlapping. In this case, overlapping of 50% increases
<span class="math inline">\(N_{avg}\)</span> from 8 to 15. Here is the
Matlab code to compute the spectrum:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">nfft= <span class="number">1024</span>;</span><br><span class="line">N= nfft*<span class="number">8</span>;                                <span class="comment">% number of samples in signal</span></span><br><span class="line">n= <span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line">x= A*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*n*Ts) + <span class="number">.1</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);   <span class="comment">% 1 W sinewave + noise</span></span><br><span class="line">noverlap= nfft/<span class="number">2</span>;                         <span class="comment">% number of overlapping time samples</span></span><br><span class="line">window= hanning(nfft);</span><br><span class="line">[pxx,f]= pwelch(x,window,noverlap,nfft,fs);  <span class="comment">% W/Hz  PSD</span></span><br><span class="line">PdB_bin= <span class="number">10</span>*<span class="built_in">log10</span>(pxx*fs/nfft);              <span class="comment">% dBW/bin</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/18/ps-psd/figure%203_99153.png"
alt="figure 3_99153" /></p>
<blockquote>
<p><strong>DFT averaging</strong> reduces the variance <span
class="math inline">\(\sigma^2\)</span> of the noise spectrum by a
factor of <span class="math inline">\(N_{avg}\)</span>, as long as
<code>noverlap</code> is not greater than <code>nfft/2</code></p>
</blockquote>
<p><img src="/2022/04/18/ps-psd/image-20220420013255660.png"
alt="image-20220420013255660" /></p>
<p><img src="/2022/04/18/ps-psd/image-20230526011628682.png"
alt="image-20230526011628682" /></p>
<h2 id="fftshift">fftshift</h2>
<p>The result of <code>fft</code> and its index is shown as below</p>
<p><img src="/2022/04/18/ps-psd/complexDFT_Matlab_index.png"
alt="complexDFT_Matlab_index" /></p>
<p>After <code>fftshift</code></p>
<p><img src="/2022/04/18/ps-psd/FFTshift_Matlab_index_resolved.png"
alt="FFTshift_Matlab_index_resolved" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; fftshift([<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="dft-and-psd-function-in-virtuoso"><code>dft</code> and
<code>psd</code> function in virtuoso</h2>
<ul>
<li><p><code>dft</code> always return</p>
<p><img src="/2022/04/18/ps-psd/image-20230525011604685.png"
alt="image-20230525011604685" /></p></li>
</ul>
<p>To compensate windowing effect, <span
class="math inline">\(W(n)\)</span>, the <code>dft</code> output should
be multiplied by <span class="math inline">\(K_a\)</span>, e.g. 1.9922
for hanning window.</p>
<ul>
<li><code>psd</code> function has taken into account <span
class="math inline">\(K_e\)</span>, postprocessing is
<strong>not</strong> needed</li>
</ul>
<h2 id="reference">reference</h2>
<p><a
href="https://github.com/liangsizhuang/Demonstration-DFT-PS-PSD">Demonstration-DFT-PS-PSD</a></p>
<p><a
href="https://www.mathworks.com/help/signal/ug/power-spectral-density-estimates-using-fft.html">mathworks,
Power Spectral Density Estimates Using FFT</a></p>
<p>Lyons, Richard, “Widowing Functions Improve FFT Results”, EDN, June
1, 1998. <a
href="https://www.edn.com/electronics-news/4383713/Windowing-Functions-Improve-FFT-Results-Part-I">https://www.edn.com/electronics-news/4383713/Windowing-Functions-Improve-FFT-Results-Part-I</a></p>
<p>Rapuano, Sergio, and Harris, Fred J., An Introduction to FFT and Time
Domain Windows, IEEE Instrumentation and Measurement Magazine, December,
2007. <a
href="https://ieeexplore.ieee.org/document/4428580">https://ieeexplore.ieee.org/document/4428580</a></p>
<p><a href="https://www.dsprelated.com/showarticle/1004.php">Neil
Robertson, The Power Spectrum</a></p>
<p><a href="https://www.dsprelated.com/showarticle/1221.php">Neil
Robertson, Use Matlab Function pwelch to Find Power Spectral Density –
or Do It Yourself</a></p>
<p><a href="https://www.dsprelated.com/showarticle/1211.php">Neil
Robertson, Evaluate Window Functions for the Discrete Fourier
Transform</a></p>
<p><a
href="https://www.gaussianwaves.com/2015/11/interpreting-fft-results-complex-dft-frequency-bins-and-fftshift/">Mathuranathan
Viswanathan, Interpret FFT, complex DFT, frequency bins &amp;
FFTShift</a></p>
<p><a href="https://dsp.stackexchange.com/a/47603/59253">robert
bristow-johnson, Does windowing affect Parseval's theorem?</a></p>
<p>Heinzel, Gerhard, A. O. Rüdiger and Roland Schilling. "Spectrum and
spectral density estimation by the Discrete Fourier transform (DFT),
including a comprehensive list of window functions and some new at-top
windows." (2002). URL: <a
href="https://holometer.fnal.gov/GH_FFT.pdf">https://holometer.fnal.gov/GH_FFT.pdf</a></p>
<p>Window Correction Factors URL: <a
href="https://community.sw.siemens.com/s/article/window-correction-factors">https://community.sw.siemens.com/s/article/window-correction-factors</a></p>
<p>Brandt, A, 2011. Noise and vibration analysis: signal analysis and
experimental procedures. John Wiley &amp; Sons</p>
<p>What should be the correct scaling for PSD calculation using fft.
URL:<a
href="https://dsp.stackexchange.com/a/32205">https://dsp.stackexchange.com/a/32205</a></p>
<p>POWER SPECTRAL DENSITY CALCULATION VIA MATLAB Revision C. URL: <a
href="http://www.vibrationdata.com/tutorials_alt/psd_mat.pdf">http://www.vibrationdata.com/tutorials_alt/psd_mat.pdf</a></p>
<p>Jens Ahrens, Carl Andersson, Patrik Höstmad, Wolfgang Kropp,
“Tutorial on Scaling of the Discrete Fourier Transform and the Implied
Physical Units of the Spectra of Time-Discrete Signals” in 148th
Convention of the AES, e-Brief 56, May 2020 [ <a
href="http://www.soundfieldsynthesis.org/wp-content/uploads/pubs/Ahrens_etal_AES2020.pdf">pdf</a>,
<a
href="https://appliedacousticschalmers.github.io/scaling-of-the-dft/AES2020_eBrief/">web</a>
].</p>
<p>Manolakis, D., &amp; Ingle, V. (2011). <em>Applied Digital Signal
Processing: Theory and Practice</em>. Cambridge: Cambridge University
Press. doi:10.1017/CBO9780511835261</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>questasim sim flow</title>
    <url>/2022/02/02/questasim-sim/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vlib work</span><br><span class="line">vlog -f filelist tb.sv</span><br><span class="line"># &quot;-c&quot;: command line mode</span><br><span class="line">vsim -voptargs=+acc -c -do &quot;run 100ns; exit&quot; work.topmodule</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-voptargs=+acc</code>: Add the option
<code>-voptargs=+acc</code> to the <em>vsim</em> command, This enables
full visibility into every aspect of the design.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> topmodule;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>uvm</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; vlog test_pkg.sv tb_top.sv -L $QUESTA_HOME/uvm-1.2</span><br><span class="line">&gt; vsim -c -do &quot;run -all;exit&quot; +UVM_TESTNAME=my_test work.tb_top  -L $QUESTA_HOME/uvm-1.2</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong>:</p>
<p>A Short Intro to ModelSim Verilog Simulator URL: <a
href="https://users.ece.cmu.edu/~jhoe/doku/doku.php?id=a_short_intro_to_modelsim_verilog_simulator">https://users.ece.cmu.edu/~jhoe/doku/doku.php?id=a_short_intro_to_modelsim_verilog_simulator</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Random Signals</title>
    <url>/2023/11/10/random/</url>
    <content><![CDATA[<ul>
<li><p><strong>Mean Function</strong></p>
<p>The <strong>mean function</strong> <span
class="math inline">\(\mu_X(t)\)</span> of a random process <span
class="math inline">\(\{ X(t) \}\)</span> is a function that specifies
the expected value at <em>each time</em> <span
class="math inline">\(t\)</span> <span class="math display">\[
\mu_X(t) \overset{\text{def}}{=} E[X(t)] \tag{1.1}
\]</span> For a discrete-time process, we notate the mean function as
<span class="math display">\[
\mu_X[n] \overset{\text{def}}{=} E[X[n]] \tag{1.2}
\]</span></p></li>
<li><p><strong>Variance Function</strong></p>
<p>The <strong>variance function</strong> <span
class="math inline">\(V(t)\)</span> of a random process <span
class="math inline">\(\{ X(t) \}\)</span> is a function that specifies
the variance of the process at each time <span
class="math inline">\(t\)</span> <span class="math display">\[
V(t) \overset{\text{def}}{=} \text{Var}[X(t)] \tag{1.3}
\]</span> For a discrete-time process, we notate the variance function
as <span class="math display">\[
V[n] \overset{\text{def}}{=} \text{Var}[X[n]] \tag{1.4}
\]</span> <img
src="/2023/11/10/random/unnamed-chunk-184-1-1699676799639-1.png"
alt="unnamed-chunk-184-1-1699676799639-1" /></p></li>
</ul>
<h2 id="autocovariance-function">Autocovariance Function</h2>
<p><span class="math display">\[
C_X(s, t) \overset{\text{def}}{=} \text{Cov}[X(s), X(t)] =
\mathrm{E}[(X(s) - E(X(s)))(X(t) - E(X(t)))]
\]</span></p>
<h2 id="autocorrelation-function">Autocorrelation Function</h2>
<p>The <strong>autocorrelation function</strong> <span
class="math inline">\(R_X(s, t)\)</span> of a random process <span
class="math inline">\(\{ X(t) \}\)</span> is a function of <em>two</em>
times <span class="math inline">\(s\)</span> and <span
class="math inline">\(t\)</span>. It specifies <span
class="math display">\[
R_X(s, t) \overset{\text{def}}{=} E[X(s)X(t)] \tag{1.7}
\]</span></p>
<blockquote>
<p><span class="math display">\[
E[X(s) X(t)] = \text{Cov}[X(s), X(t)] + E[X(s)] E[X(t)]
\]</span></p>
</blockquote>
<p>For stationary process, the autocorrelation function only depends on
the difference between the times <span class="math inline">\(\tau = s -
t\)</span> <span class="math display">\[
R_X(\tau) \overset{\text{def}}{=} C_X(s, t) + \mu_X(s) \mu_X(t) =
C_X(\tau) + \mu_X^2
\]</span></p>
<h2 id="wide-sense-stationary-processes">Wide-Sense Stationary
Processes</h2>
<p>A random process <span class="math inline">\(\{ X(t) \}\)</span> is
wide-sense stationary if its mean and autocovariance function are
invariant under time shifts. That is:</p>
<ol type="1">
<li>The mean function <span class="math inline">\(\mu_X(t)\)</span> is
constant. In this case, we will write the mean function as <span
class="math inline">\(\mu_X(t) \equiv \mu_X\)</span></li>
<li>The autocovariance function <span class="math inline">\(C_X(s,
t)\)</span> only depends on <span class="math inline">\(s-t\)</span>,
the difference between the times. In this case, we will write the
autocovariance function as <span class="math inline">\(C_X(s, t) = C_X(s
- t)\)</span></li>
</ol>
<h2 id="cyclostationary-process">Cyclostationary process</h2>
<p><em>TODO</em> 📅</p>
<h2 id="wiener-khinchin-theorem">Wiener-Khinchin theorem</h2>
<blockquote>
<p>Norbert Wiener proved this theorem for the case of a
<em>deterministic function</em> in 1930; Aleksandr Khinchin later
formulated an analogous result for <em>stationary stochastic
processes</em> and published that probabilistic analogue in 1934. Albert
Einstein explained, without proofs, the idea in a brief two-page memo in
1914</p>
</blockquote>
<p><span class="math inline">\(x(t)\)</span>, Fourier transform over a
limited period of time <span class="math inline">\([-T/2, +T/2]\)</span>
, <span class="math display">\[
X_T(f) = \int_{-T/2}^{T/2}x(t)e^{-j2\pi ft}dt
\]</span></p>
<p>using <em>Parseval's theorem</em> <span class="math display">\[
\int_{-T/2}^{T/2}|x(t)|^2dt = \int_{-T/2}^{T/2}|X_T(f)|^2df
\]</span> So that <span class="math display">\[
\frac{1}{T}\int_{-T/2}^{T/2}|x(t)|^2dt =
\int_{-T/2}^{T/2}\frac{1}{T}|X_T(f)|^2df
\]</span></p>
<blockquote>
<p>where the quantity, <span
class="math inline">\(\frac{1}{T}|X_T(f)|^2\)</span> can be interpreted
as distribution of power in the frequency domain</p>
<p>For each <span class="math inline">\(f\)</span> this quantity is a
random variable, since it is a function of the random process <span
class="math inline">\(x(t)\)</span></p>
</blockquote>
<p>The power spectral density (PSD) <span class="math inline">\(S_x(f
)\)</span> is defined as the limit of the expectation of the expression
above, for large <span class="math inline">\(T\)</span>: <span
class="math display">\[
S_x(f) = \lim _{T\to \infty}\mathrm{E}\left[ \frac{1}{T}|X_T(f)|^2
\right]
\]</span></p>
<p>The <em>Wiener-Khinchin theorem</em> ensures that for well-behaved
<em>wide-sense stationary processes</em> the <strong>limit
exists</strong> and is equal to the Fourier transform of the
autocorrelation <span class="math display">\[\begin{align}
S_x(f) &amp;= \int_{-\infty}^{+\infty}R_x(\tau)e^{-j2\pi f \tau}d\tau \\
R_x(\tau) &amp;= \int_{-\infty}^{+\infty}S_x(f)e^{j2\pi f \tau}df
\end{align}\]</span></p>
<h2 id="spectrum-analysis-of-random-signals">Spectrum Analysis of Random
Signals</h2>
<ul>
<li><p>periodogram analysis</p>
<p>direct Fourier transformation of finite-length segments of the
signal</p></li>
<li><p>Blackman-Tukey method</p>
<p>Fourier transform of the autocorrelation function</p></li>
</ul>
<h2 id="spectrum-analyzer">spectrum analyzer</h2>
<p>We tried to plot a <em>power spectral density</em> together with
something that we want to interpret as a <em>power spectrum</em></p>
<blockquote>
<ul>
<li><em>spectrum</em> of a periodic signal</li>
<li><em>spectral density</em> of a broadband signal such as noise</li>
</ul>
<p>Sine-wave components are located in individual FFT bins, but
broadband signals like noise have their power spread over all FFT
bins!</p>
<p>The <strong>noise floor</strong> depends on the <em>length of the
FFT</em></p>
</blockquote>
<p>[<a
href="http://individual.utoronto.ca/schreier/lectures/2015/1.pdf">http://individual.utoronto.ca/schreier/lectures/2015/1.pdf</a>]</p>
<p><img src="/2023/11/10/random/image-20240522214004545.png"
alt="image-20240522214004545" /></p>
<p>signal tone power <span class="math display">\[
P_{\text{sig}} = 2 \frac{X_{w,sig}^2}{S_1^2}
\]</span></p>
<p>noise power <span class="math display">\[
P_n = \frac{X_{w,n}^2}{S_2}
\]</span></p>
<p>Then, displayed <strong>SNR</strong> is obtained <span
class="math display">\[\begin{align}
\mathrm{SNR} &amp;= 10\log10\left(\frac{X_{w,sig}^2}{X_{w,n}^2}\right)
\\
&amp;= 10\log_{10}\left(\frac{P_{\text{sig}}}{P_n}\right) +
10\log_{10}\left(\frac{S_1^2}{2S_2}\right) \\
&amp;= \mathrm{SNR}&#39;-10\log_{10}\left(\frac{2S_2}{S_1^2}\right) \\
&amp;= \mathrm{SNR}&#39;-10\log_{10}(2\cdot\mathrm{NBW}) \\
\end{align}\]</span></p>
<blockquote>
<p><em>DFT's output</em> <span
class="math inline">\(\mathrm{SNR}\)</span></p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> N=[<span class="number">2</span>^<span class="number">6</span> <span class="number">2</span>^<span class="number">8</span> <span class="number">2</span>^<span class="number">10</span> <span class="number">2</span>^<span class="number">12</span>]</span><br><span class="line">  wd = rectwin(N);</span><br><span class="line">  nbw = enbw(wd)/N;</span><br><span class="line">  snr_shift = <span class="number">10</span>*<span class="built_in">log10</span>(nbw * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">disp</span>(snr_shift);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>output: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-15.0515</span><br><span class="line"></span><br><span class="line">-21.0721</span><br><span class="line"></span><br><span class="line">-27.0927</span><br><span class="line"></span><br><span class="line">-33.1133</span><br></pre></td></tr></table></figure></p>
<p><img src="/2023/11/10/random/image-20240522214340882.png"
alt="image-20240522214340882" /></p>
<blockquote>
<p>The solution to the scaling problem in the case of a PSD obtained
from a sine-wave scaled FFT is similarly simple. All we need do is
provide the value of <strong>NBW</strong></p>
</blockquote>
<blockquote>
<p><em>APPENDIX A - SPECTRAL ESTIMATION - A.2 Scaling and Noise
Bandwidth</em></p>
<p>Pavan, Shanthi, Richard Schreier, and Gabor Temes. (2016) 2016.
Understanding Delta-Sigma Data Converters. 2nd ed. Wiley.</p>
</blockquote>
<ul>
<li>For a filter with infinitely steep roll-off, the noise bandwidth
(<strong>NBW</strong>) is equal to the filter's bandwidth,</li>
<li>while for a filter with a single-pole roll-off, <strong>NBW</strong>
is 2 times the 3-dB bandwidth</li>
</ul>
<h2 id="reference">reference</h2>
<p>Iain Collings. Random Processes [<a
href="https://youtube.com/playlist?list=PLx7-Q20A1VYKRLHUMSt2YOORrVz8iH-Kq&amp;si=cZjlH7zcHcR0zWg6">https://youtube.com/playlist?list=PLx7-Q20A1VYKRLHUMSt2YOORrVz8iH-Kq&amp;si=cZjlH7zcHcR0zWg6</a>]
Spectral content of NRZ test patterns [<a
href="https://www.analog.com/media/en/technical-documentation/tech-articles/hfta110-spectral-content-of-nrz-test-patterns.pdf">https://www.analog.com/media/en/technical-documentation/tech-articles/hfta110-spectral-content-of-nrz-test-patterns.pdf</a>]</p>
<p>NRZ Bandwidth - HF Cutoff vs. SNR [<a
href="https://www.analog.com/media/en/technical-documentation/tech-articles/hfan0901-nrz-bandwidth--hf-cutoff-vs-snr.pdf">https://www.analog.com/media/en/technical-documentation/tech-articles/hfan0901-nrz-bandwidth--hf-cutoff-vs-snr.pdf</a>]</p>
<p>Lab 2: Spectrum analysis [<a
href="https://ece.uccs.edu/~mwickert/ece4670/lecture_notes/Lab2.pdf">https://ece.uccs.edu/~mwickert/ece4670/lecture_notes/Lab2.pdf</a>]</p>
<p>PSD (Power spectral density) explanation. [<a
href="https://dsp.stackexchange.com/a/8151">https://dsp.stackexchange.com/a/8151</a>]</p>
<p>Dennis Sun. STAT 350 2020 Probability and Stochastic Processes for
Electrical Engineers [<a
href="https://dlsun.github.io/Stat350-S20/">https://dlsun.github.io/Stat350-S20/</a>]</p>
<p>Oppenheim, Alan V. and Cram. "Discrete-time signal processing" 3rd
edition. (2011).</p>
<p>Leon W. Couch, II "Digital and Analog Communication Systems", 8th
Ed., Pearson Education-LPE, 2013.</p>
<p>B.P. Lathi, Zhi Ding. "Modern Digital and Analog Communication
Systems", 5th edition, 2019.</p>
<p>Ziemer, Rodger E., and William H. Tranter. <em>Principles of
Communication: Systems, Modulation, and Noise</em>. 5th ed. New York:
Wiley, 2002.</p>
<p>Haykin, Simon. <em>Digital Communication Systems</em>. 1st edition.
Wiley, 2013.</p>
<p>Carlson, A. Bruce, and Paul B. Crilly. <em>Communication Systems: An
Introduction to Signals and Noise in Electrical Communication</em>. 5th
ed. Boston: McGraw-Hill Higher Education, 2010.</p>
]]></content>
      <categories>
        <category>noise</category>
      </categories>
  </entry>
  <entry>
    <title>Cadence&#39;s reg_verifier</title>
    <url>/2022/04/04/reg-verifier/</url>
    <content><![CDATA[<h2 id="generation">Generation</h2>
<p><img src="/2022/04/04/reg-verifier/image-20220404125201390.png"
alt="image-20220404125201390" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">reg_verifier -domain uvmreg -top yapp_router_regs<span class="variable">.xml</span> -dut_name yapp_router_regs -out_file yapp_router_regs -cov -quicktest -pkg yapp_router_reg_pkg</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/04/reg-verifier/image-20220404125541442.png"
alt="image-20220404125541442" /></p>
<p><img src="/2022/04/04/reg-verifier/image-20220404125421201.png"
alt="image-20220404125421201" /></p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>generated file</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>yapp_router_regs_config.dat</td>
<td>Configuration information</td>
</tr>
<tr class="even">
<td>yapp_router_regs_hdlpaths.dat</td>
<td>Path information for backddoor access</td>
</tr>
<tr class="odd">
<td>yapp_router_regs_rdb.sv</td>
<td>Register Model</td>
</tr>
<tr class="even">
<td>cdns_uvmreg_utils_pkg.sv</td>
<td>Cadence utility package</td>
</tr>
<tr class="odd">
<td>quicktest.sv</td>
<td>UVM test to verify model</td>
</tr>
</tbody>
</table>
<h2 id="sanity-check">Sanity Check</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make run_test</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_router_regs_t <span class="keyword">extends</span> cdns_uvm_reg_block;</span><br><span class="line">    uvm_reg_map default_map;</span><br><span class="line">    uvm_reg_map router;</span><br><span class="line">    <span class="keyword">rand</span> yapp_regs_c router_yapp_regs;</span><br><span class="line">    <span class="keyword">rand</span> yapp_mem_c router_yapp_mem;</span><br><span class="line">    <span class="keyword">rand</span> yapp_pkt_mem_c router_yapp_pkt_mem;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build();</span><br><span class="line">        router = create_map(<span class="string">&quot;router&quot;</span>, `UVM_REG_ADDR_WIDTH&#x27;h0, <span class="number">1</span>, UVM_LITTLE_ENDIAN, <span class="number">1</span>);</span><br><span class="line">        default_map = router;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Mapping router map</span></span><br><span class="line">        router<span class="variable">.add_submap</span>(router_yapp_regs<span class="variable">.default_map</span>, `UVM_REG_ADDR_WIDTH&#x27;h1000)</span><br><span class="line">        router<span class="variable">.add_mem</span>(router_yapp_mem, `UVM_REG_ADDR_WIDTH&#x27;h1100);</span><br><span class="line">        router<span class="variable">.add_mem</span>(router_yapp_pkt_mem, `UVM_REG_ADDR_WIDTH&#x27;h1010);</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> qt_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line">    yapp_router_regs_t model;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">        ...</span><br><span class="line">        model<span class="variable">.print</span>();</span><br><span class="line">        model<span class="variable">.default_map</span><span class="variable">.print</span>();</span><br><span class="line">        model<span class="variable">.router_yapp_regs</span><span class="variable">.default_map</span><span class="variable">.print</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><strong>yapp_mem_c</strong> <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_mem_c <span class="keyword">extends</span> uvm_mem;                                                                                                                                                                                                                                </span><br><span class="line">  `uvm_object_utils(yapp_mem_c)                                                                                                       </span><br><span class="line">                                                                                                                               </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">string</span> name=<span class="string">&quot;router_yapp_mem&quot;</span>);                                                                                 </span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, <span class="number">&#x27;h100</span>, <span class="number">8</span>, <span class="string">&quot;RW&quot;</span>, UVM_NO_COVERAGE);                                                                                 </span><br><span class="line">  <span class="keyword">endfunction</span>                                                                                                                            </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure></p>
<p><strong>yapp_pkt_mem_c</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_pkt_mem_c <span class="keyword">extends</span> uvm_mem;                                                                                                                                                                                                                                      </span><br><span class="line">  `uvm_object_utils(yapp_pkt_mem_c)                                                                                                                                                                                            </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">string</span> name=<span class="string">&quot;router_yapp_pkt_mem&quot;</span>);                                                                             </span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, <span class="number">&#x27;h40</span>, <span class="number">8</span>, <span class="string">&quot;RO&quot;</span>, UVM_NO_COVERAGE);                                                                                 </span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><strong>yapp_regs_c</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_regs_c <span class="keyword">extends</span> cdns_uvm_reg_block;</span><br><span class="line">  `uvm_object_utils(yapp_regs_c)</span><br><span class="line">  <span class="keyword">rand</span> addr0_cnt_reg_c addr0_cnt_reg;</span><br><span class="line">  <span class="keyword">rand</span> addr1_cnt_reg_c addr1_cnt_reg;</span><br><span class="line">  <span class="keyword">rand</span> addr2_cnt_reg_c addr2_cnt_reg;</span><br><span class="line">  <span class="keyword">rand</span> illegal_addr_cnt_reg_c addr3_cnt_reg;</span><br><span class="line">  <span class="keyword">rand</span> ctrl_reg_c ctrl_reg;</span><br><span class="line">  <span class="keyword">rand</span> en_reg_c en_reg;</span><br><span class="line">  <span class="keyword">rand</span> mem_size_reg_c mem_size_reg;</span><br><span class="line">  <span class="keyword">rand</span> oversized_pkt_cnt_reg_c oversized_pkt_cnt_reg;</span><br><span class="line">  <span class="keyword">rand</span> parity_err_cnt_reg_c parity_err_cnt_reg; </span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build();</span><br><span class="line">    uvm_reg  reg_set[$];</span><br><span class="line">    default_map = create_map(get_name(), `UVM_REG_ADDR_WIDTH&#x27;h1000, <span class="number">1</span>, UVM_LITTLE_ENDIAN, <span class="number">1</span>);                                         </span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">       uvm_reg_config_ta ta = get_reg_config(<span class="string">&quot;yapp_router_regs.router_yapp_regs&quot;</span>);</span><br><span class="line">       build_uvm_regs(default_map, <span class="keyword">this</span>, <span class="literal">null</span>, ta, reg_se);</span><br><span class="line">    <span class="keyword">end</span>                                                                                                                               </span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(addr0_cnt_reg, reg_set[<span class="number">0</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;addr0_cnt_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(addr1_cnt_reg, reg_set[<span class="number">1</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;addr1_cnt_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(addr2_cnt_reg, reg_set[<span class="number">2</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;addr2_cnt_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(addr3_cnt_reg, reg_set[<span class="number">3</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;addr3_cnt_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(ctrl_reg, reg_set[<span class="number">4</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;ctrl_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(en_reg, reg_set[<span class="number">5</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;en_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(mem_size_reg, reg_set[<span class="number">6</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;mem_size_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(oversized_pkt_cnt_reg, reg_set[<span class="number">7</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;oversized_pkt_cnt_reg register casting error&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">$cast</span>(parity_err_cnt_reg, reg_set[<span class="number">8</span>]))</span><br><span class="line">      `uvm_error(<span class="string">&quot;UVM_REG&quot;</span>, <span class="string">&quot;parity_err_cnt_reg register casting error&quot;</span>)</span><br><span class="line">  <span class="keyword">endfunction</span>   </span><br><span class="line">                                                 </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">string</span> name=<span class="string">&quot;router_yapp_regs&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, UVM_NO_COVERAGE);</span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line"><span class="keyword">endclass</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_reg_map <span class="keyword">extends</span> uvm_object;</span><br><span class="line"><span class="comment">// Function: add_submap</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Add an address map</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Add the specified address map instance to this address map.</span></span><br><span class="line"><span class="comment">// The address map is located at the specified base address.</span></span><br><span class="line"><span class="comment">// The number of consecutive physical addresses occupied by the submap</span></span><br><span class="line"><span class="comment">// depends on the number of bytes in the physical interface</span></span><br><span class="line"><span class="comment">// that corresponds to the submap,</span></span><br><span class="line"><span class="comment">// the number of addresses used in the submap and</span></span><br><span class="line"><span class="comment">// the number of bytes in the</span></span><br><span class="line"><span class="comment">// physical interface corresponding to this address map.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An address map may be added to multiple address maps</span></span><br><span class="line"><span class="comment">// if it is accessible from multiple physical interfaces.</span></span><br><span class="line"><span class="comment">// An address map may only be added to an address map</span></span><br><span class="line"><span class="comment">// in the grand-parent block of the address submap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> add_submap (uvm_reg_map    child_map,</span><br><span class="line">                                       uvm_reg_addr_t offset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function: add_mem</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Add a memory</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Add the specified memory instance to this address map.</span></span><br><span class="line"><span class="comment">// The memory is located at the specified base address and has the</span></span><br><span class="line"><span class="comment">// specified access rights (&quot;RW&quot;, &quot;RO&quot; or &quot;WO&quot;).</span></span><br><span class="line"><span class="comment">// The number of consecutive physical addresses occupied by the memory</span></span><br><span class="line"><span class="comment">// depends on the width and size of the memory and the number of bytes in the</span></span><br><span class="line"><span class="comment">// physical interface corresponding to this address map.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ~unmapped~ is TRUE, the memory does not occupy any</span></span><br><span class="line"><span class="comment">// physical addresses and the base address is ignored.</span></span><br><span class="line"><span class="comment">// Unmapped memories require a user-defined ~frontdoor~ to be specified.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A memory may be added to multiple address maps</span></span><br><span class="line"><span class="comment">// if it is accessible from multiple physical interfaces.</span></span><br><span class="line"><span class="comment">// A memory may only be added to an address map whose parent block</span></span><br><span class="line"><span class="comment">// is the same as the memory&#x27;s parent block.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> add_mem (uvm_mem        mem,</span><br><span class="line">                                    uvm_reg_addr_t offset,</span><br><span class="line">                                    <span class="keyword">string</span>         rights = <span class="string">&quot;RW&quot;</span>,</span><br><span class="line">                                    <span class="keyword">bit</span>            unmapped=<span class="number">0</span>,</span><br><span class="line">                                    uvm_reg_frontdoor frontdoor=<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endclass</span>: uvm_reg_map    </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="register-model-print">register model print</h3>
<blockquote>
<p>// test run_phase</p>
<p><code>model.default_map.print();</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------------------------------            </span><br><span class="line">Name                             Type                     Size  Value                                                                   </span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------            </span><br><span class="line">model                            yapp_router_regs_t       -     @3724                                                                   </span><br><span class="line">  router_yapp_regs               yapp_regs_c              -     @3792                                                                   </span><br><span class="line">    addr0_cnt_reg                addr0_cnt_reg_c          -     @3827                                                                   </span><br><span class="line">      addr0_cnt_reg_fld          uvm_reg_field            ...    RO addr0_cnt_reg[7:0]=8&#x27;h00                                            </span><br><span class="line">    addr1_cnt_reg                addr1_cnt_reg_c          -     @3839                                                                   </span><br><span class="line">      addr1_cnt_reg_fld          uvm_reg_field            ...    RO addr1_cnt_reg[7:0]=8&#x27;h00                                            </span><br><span class="line">    addr2_cnt_reg                addr2_cnt_reg_c          -     @3857                                                                   </span><br><span class="line">      addr2_cnt_reg_fld          uvm_reg_field            ...    RO addr2_cnt_reg[7:0]=8&#x27;h00                                            </span><br><span class="line">    addr3_cnt_reg                illegal_addr_cnt_reg_c   -     @3874                                                                   </span><br><span class="line">      addr3_cnt_reg_fld          uvm_reg_field            ...    RO addr3_cnt_reg[7:0]=8&#x27;h00                                            </span><br><span class="line">    ctrl_reg                     ctrl_reg_c               -     @3891                                                                   </span><br><span class="line">      plen                       uvm_reg_field            ...    RW ctrl_reg[5:0]=6&#x27;h3f                                                 </span><br><span class="line">      rsvd_0                     uvm_reg_field            ...    RW ctrl_reg[7:6]=2&#x27;h0                                                  </span><br><span class="line">    en_reg                       en_reg_c                 -     @3908                                                                   </span><br><span class="line">      router_en                  uvm_reg_field            ...    RW en_reg[0:0]=1&#x27;h1                                                    </span><br><span class="line">      parity_err_cnt_en          uvm_reg_field            ...    RW en_reg[1:1]=1&#x27;h0                                                    </span><br><span class="line">      oversized_pkt_cnt_en       uvm_reg_field            ...    RW en_reg[2:2]=1&#x27;h0                                                    </span><br><span class="line">      rsvd_0                     uvm_reg_field            ...    RW en_reg[3:3]=1&#x27;h0                                                    </span><br><span class="line">      addr0_cnt_en               uvm_reg_field            ...    RW en_reg[4:4]=1&#x27;h0                                                    </span><br><span class="line">      addr1_cnt_en               uvm_reg_field            ...    RW en_reg[5:5]=1&#x27;h0                                                    </span><br><span class="line">      addr2_cnt_en               uvm_reg_field            ...    RW en_reg[6:6]=1&#x27;h0                                                    </span><br><span class="line">      addr3_cnt_en               uvm_reg_field            ...    RW en_reg[7:7]=1&#x27;h0                                                    </span><br><span class="line">    mem_size_reg                 mem_size_reg_c           -     @3928                                                                   </span><br><span class="line">      mem_size_reg_fld           uvm_reg_field            ...    RO mem_size_reg[7:0]=8&#x27;h00                                             </span><br><span class="line">    oversized_pkt_cnt_reg        oversized_pkt_cnt_reg_c  -     @3966                                                                   </span><br><span class="line">      oversized_pkt_cnt_reg_fld  uvm_reg_field            ...    RO oversized_pkt_cnt_reg[7:0]=8&#x27;h00                                    </span><br><span class="line">    parity_err_cnt_reg           parity_err_cnt_reg_c     -     @3983                                                                   </span><br><span class="line">      parity_err_cnt_reg_fld     uvm_reg_field            ...    RO parity_err_cnt_reg[7:0]=8&#x27;h00                                       </span><br><span class="line">  router_yapp_mem                yapp_mem_c               -     @3757                                                                   </span><br><span class="line">    n_bits                       integral                 32    &#x27;d8                                                                     </span><br><span class="line">    size                         integral                 32    &#x27;d256                                                                   </span><br><span class="line">  router_yapp_pkt_mem            yapp_pkt_mem_c           -     @3779                                                                   </span><br><span class="line">    n_bits                       integral                 32    &#x27;d8                                                                     </span><br><span class="line">    size                         integral                 32    &#x27;d64</span><br><span class="line">    router                       uvm_reg_map              0     id=@3737 seqr=HI0.sqr offset=0x0 size=0x1200 baseaddr=0x0               </span><br><span class="line">      router_yapp_regs           uvm_reg_map              0     id=@3816 seqr=HI0.sqr offset=0x1000 size=0x5 baseaddr=0x1000            </span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="address-map-print">address map print</h3>
<blockquote>
<p>// test run_phase</p>
<p><code>model.router_yapp_regs.default_map.print();</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">Name                       Type                     Size  Value</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">router                     uvm_reg_map              -     @3737</span><br><span class="line">  endian                                            ...   UVM_LITTLE_ENDIAN</span><br><span class="line">  effective sequencer      uvm_sequencer            ...   HI0.sqr</span><br><span class="line">  router_yapp_mem          yapp_mem_c               ...   @3757 +&#x27;h1100</span><br><span class="line">  router_yapp_pkt_mem      yapp_pkt_mem_c           ...   @3779 +&#x27;h1010</span><br><span class="line">  router_yapp_regs         uvm_reg_map              -     @3816</span><br><span class="line">    endian                                          ...   UVM_LITTLE_ENDIAN</span><br><span class="line">    effective sequencer    uvm_sequencer            ...   HI0.sqr</span><br><span class="line">    addr0_cnt_reg          addr0_cnt_reg_c          ...   @3827 +&#x27;h1009</span><br><span class="line">    addr1_cnt_reg          addr1_cnt_reg_c          ...   @3839 +&#x27;h100a</span><br><span class="line">    addr2_cnt_reg          addr2_cnt_reg_c          ...   @3857 +&#x27;h100b</span><br><span class="line">    addr3_cnt_reg          illegal_addr_cnt_reg_c   ...   @3874 +&#x27;h1006</span><br><span class="line">    ctrl_reg               ctrl_reg_c               ...   @3891 +&#x27;h1000</span><br><span class="line">    en_reg                 en_reg_c                 ...   @3908 +&#x27;h1001</span><br><span class="line">    mem_size_reg           mem_size_reg_c           ...   @3928 +&#x27;h100d</span><br><span class="line">    oversized_pkt_cnt_reg  oversized_pkt_cnt_reg_c  ...   @3966 +&#x27;h1005</span><br><span class="line">    parity_err_cnt_reg     parity_err_cnt_reg_c     ...   @3983 +&#x27;h1004</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="submap-print">submap print</h3>
<blockquote>
<p>// test run_phase</p>
<p><code>model.router_yapp_regs.default_map.print();</code></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Name                     Type                     Size  Value</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">router_yapp_regs         uvm_reg_map              -     @<span class="number">3814</span></span><br><span class="line">  endian                                          ...   UVM_LITTLE_ENDIAN</span><br><span class="line">  effective sequencer    uvm_sequencer            ...   HI0<span class="variable">.sqr</span></span><br><span class="line">  addr0_cnt_reg          addr0_cnt_reg_c          ...   @<span class="number">3825</span> +<span class="number">&#x27;h1009</span></span><br><span class="line">  addr1_cnt_reg          addr1_cnt_reg_c          ...   @<span class="number">3837</span> +<span class="number">&#x27;h100a</span></span><br><span class="line">  addr2_cnt_reg          addr2_cnt_reg_c          ...   @<span class="number">3855</span> +<span class="number">&#x27;h100b</span></span><br><span class="line">  addr3_cnt_reg          illegal_addr_cnt_reg_c   ...   @<span class="number">3872</span> +<span class="number">&#x27;h1006</span></span><br><span class="line">  ctrl_reg               ctrl_reg_c               ...   @<span class="number">3889</span> +<span class="number">&#x27;h1000</span></span><br><span class="line">  en_reg                 en_reg_c                 ...   @<span class="number">3906</span> +<span class="number">&#x27;h1001</span></span><br><span class="line">  mem_size_reg           mem_size_reg_c           ...   @<span class="number">3926</span> +<span class="number">&#x27;h100d</span></span><br><span class="line">  oversized_pkt_cnt_reg  oversized_pkt_cnt_reg_c  ...   @<span class="number">3964</span> +<span class="number">&#x27;h1005</span></span><br><span class="line">  parity_err_cnt_reg     parity_err_cnt_reg_c     ...   @<span class="number">3981</span> +<span class="number">&#x27;h1004</span></span><br><span class="line">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="cdns_uvmreg_utils_pkg">cdns_uvmreg_utils_pkg</h2>
<h3 id="uvm_reg_field_config_t">uvm_reg_field_config_t</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  &#123;                                                                         </span><br><span class="line">     <span class="keyword">string</span>         name; </span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">unsigned</span>   size; </span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">unsigned</span>   lsb_pos;</span><br><span class="line">     <span class="keyword">string</span>         access;</span><br><span class="line">     <span class="keyword">bit</span>            volatile;</span><br><span class="line">     uvm_reg_data_t reset;</span><br><span class="line">     <span class="keyword">bit</span>            has_reset;</span><br><span class="line">     <span class="keyword">bit</span>            is_rand; </span><br><span class="line">     <span class="keyword">bit</span>            individually_accessible;</span><br><span class="line">   &#125; uvm_reg_field_config_t; </span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_config_t">uvm_reg_config_t</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  &#123;</span><br><span class="line">     <span class="keyword">string</span>          reg_type_name;</span><br><span class="line">     <span class="keyword">string</span>          configUID;</span><br><span class="line">     <span class="keyword">string</span>          name;</span><br><span class="line">     uvm_reg_addr_t  offset;</span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">unsigned</span>    size_bytes;</span><br><span class="line">     <span class="keyword">int</span> <span class="keyword">unsigned</span>    addr_bits;</span><br><span class="line">     <span class="keyword">string</span>          access;</span><br><span class="line">     <span class="keyword">int</span>             is_array;</span><br><span class="line">     <span class="keyword">string</span>          range;</span><br><span class="line">   &#125; uvm_reg_config_t; </span><br></pre></td></tr></table></figure>
<h3 id="uvm_blk_config_t">uvm_blk_config_t</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;                             </span><br><span class="line">     uvm_reg_addr_t   base_addr;</span><br><span class="line">     <span class="keyword">int</span>              n_bytes;</span><br><span class="line">     uvm_endianness_e endianess;</span><br><span class="line">     <span class="keyword">bit</span>              byte_addr_t;</span><br><span class="line">       &#125; uvm_blk_config_t; </span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_field_config_ta">uvm_reg_field_config_ta</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uvm_reg_field_config_t uvm_reg_field_config_ta[];</span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_field_config_tq">uvm_reg_field_config_tq</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uvm_reg_field_config_ta uvm_reg_field_config_tq[<span class="keyword">string</span>];</span><br></pre></td></tr></table></figure>
<h3 id="build_uvm_regs">build_uvm_regs</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> build_uvm_regs(uvm_reg_map map, uvm_reg_block pblock, uvm_reg_file pfile, <span class="keyword">ref</span> uvm_reg_config_t f_props[], <span class="keyword">output</span> uvm_reg out[$]);</span><br><span class="line">   <span class="keyword">foreach</span>(f_props[idx]) <span class="keyword">begin</span>        </span><br><span class="line">      uvm_reg_config_t f= f_props[idx];</span><br><span class="line">      <span class="keyword">if</span>(f<span class="variable">.is_array</span> == <span class="number">0</span>) <span class="keyword">begin</span>                  </span><br><span class="line">         cdns_uvm_reg reg_t;</span><br><span class="line">         uvm_object obj = factory<span class="variable">.create</span>(f<span class="variable">.reg_type_name</span>, pfile!=<span class="literal">null</span> ? pfile<span class="variable">.get_full_name</span>(): <span class="string">&quot;&quot;</span>,f<span class="variable">.name</span>);</span><br><span class="line">         <span class="keyword">assert</span>(<span class="built_in">$cast</span>(reg_t,obj));            </span><br><span class="line">         reg_t<span class="variable">.configure</span>(pblock, pfile, <span class="string">&quot;&quot;</span>);</span><br><span class="line">         reg_t<span class="variable">.setconfigUID</span>(f<span class="variable">.configUID</span>);       </span><br><span class="line">         reg_t<span class="variable">.build</span>();</span><br><span class="line">         <span class="comment">// !!! f.offset !!!</span></span><br><span class="line">         map<span class="variable">.add_reg</span>(reg_t, f<span class="variable">.offset</span>, f<span class="variable">.access</span>);            </span><br><span class="line">         out<span class="variable">.push_back</span>(reg_t);</span><br><span class="line">         <span class="comment">// !!! print the offset</span></span><br><span class="line">          `uvm_info(<span class="string">&quot;[build_uvm_regs]&quot;</span>, <span class="built_in">$sformatf</span>(<span class="string">&quot;### %s offset: %0x&quot;</span>, f<span class="variable">.reg_type_name</span>, f<span class="variable">.offset</span>), UVM_LOW)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (f<span class="variable">.is_array</span> == <span class="number">1</span>) <span class="keyword">begin</span>             </span><br><span class="line">         <span class="keyword">int</span> <span class="keyword">unsigned</span> array_offset;               </span><br><span class="line">         <span class="keyword">string</span> range_str = f<span class="variable">.range</span>;        </span><br><span class="line">         <span class="keyword">int</span> indx, arr_idx = <span class="number">0</span>;                 </span><br><span class="line">         <span class="keyword">int</span> range_arr [];                               </span><br><span class="line">         <span class="keyword">int</span> arr_size = <span class="number">1</span>;                        </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>dynamic array
<ul>
<li>need <code>new[size]</code></li>
</ul></li>
<li>queue
<ul>
<li>DONT need <code>new</code></li>
</ul></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### addr0_cnt_reg_c offset: 9                                 </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### addr1_cnt_reg_c offset: a                                 </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### addr2_cnt_reg_c offset: b                                 </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### illegal_addr_cnt_reg_c offset: 6                          </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### ctrl_reg_c offset: 0                                      </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### en_reg_c offset: 1                                        </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### mem_size_reg_c offset: d                                  </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### oversized_pkt_cnt_reg_c offset: 5                         </span><br><span class="line">UVM_INFO ./cdns_uvmreg_utils_pkg.sv(322) @ 0: reporter [[build_uvm_regs]] ### parity_err_cnt_reg_c offset: 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In submap, offset is <strong>0-based</strong>,
<code>router.add_submap(router_yapp_regs.default_map, ``UVM_REG_ADDR_WIDTH'h1000)</code>
configure base addr for submap</p>
</blockquote>
<h2 id="ip-xact-xml-yapp_router_regs.xml">IP-XACT XML :
yapp_router_regs.xml</h2>
<p><img src="/2022/04/04/reg-verifier/image-20220404194550165.png"
alt="image-20220404194550165" /></p>
<h3 id="memory">memory</h3>
<h4 id="yapp_pkt_mem">yapp_pkt_mem</h4>
<p><img src="/2022/04/04/reg-verifier/image-20220404194628354.png"
alt="image-20220404194628354" /></p>
<h4 id="yapp_mem">yapp_mem</h4>
<p><img src="/2022/04/04/reg-verifier/image-20220404194721416.png"
alt="image-20220404194721416" /></p>
<h3 id="register">register</h3>
<p><img src="/2022/04/04/reg-verifier/image-20220404194941613.png"
alt="image-20220404194941613" /></p>
<h3 id="yapp_regs">yapp_regs</h3>
<h4 id="ctrl_reg">ctrl_reg</h4>
<p><img src="/2022/04/04/reg-verifier/image-20220404195052310.png"
alt="image-20220404195052310" /></p>
<h4 id="en_reg">en_reg</h4>
<p><img src="/2022/04/04/reg-verifier/image-20220404195156776.png"
alt="image-20220404195156776" /></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Relative Sensitivity</title>
    <url>/2023/07/12/relative-sensitivity/</url>
    <content><![CDATA[<p>Assuming Target <span class="math inline">\(T\)</span> ( for example,
the total resistance) is function of <span
class="math inline">\(x_1,x_2,...,x_N\)</span>, then total variation can
be expressed as</p>
<p><span class="math display">\[\begin{align}
dT  &amp;= \sum_{n=1}^N\frac{\partial T}{\partial x_n}dx_n \\
&amp;= \sum_{n=1}^N\frac{\partial T}{\partial x_n}x_n\cdot
\frac{dx_n}{x_n}
\end{align}\]</span></p>
<p>Then, we obtain relative variation <span
class="math display">\[\begin{align}
\frac{dT}{T} &amp;= \sum_{n=1}^N\frac{\partial T}{\partial
x_n}\frac{x_n}{T}\cdot \frac{dx_n}{x_n}  \\
&amp;= \sum_{n=1}^N S_{x_n}^T \cdot \frac{dx_n}{x_n}
\end{align}\]</span></p>
<p>⭐ where <span class="math inline">\(S_{x_n}^T=\frac{\partial
T}{\partial x_n}\frac{x_n}{T}\)</span> is <strong>relative
sensitivity</strong></p>
<blockquote>
<p><strong>relative sensitivity</strong> connect <span
class="math inline">\(\frac{dx_n}{x_n}\)</span> with total relative
variation <span class="math inline">\(\frac{dT}{T}\)</span></p>
</blockquote>
<p>And <span class="math inline">\(dT\)</span> can be expressed as <span
class="math display">\[
dT =\sum_{n=1}^N S_{x_n}^T T\cdot \frac{dx_n}{x_n} = \sum_{n=1}^N
x_n&#39;\cdot \frac{dx_n}{x_n}
\]</span> ⭐ where <span class="math inline">\(x_n&#39;= S_{x_n}^T
T\)</span> is the contribution of <span
class="math inline">\(x_n\)</span> in <span
class="math inline">\(T\)</span></p>
<p>⭐ For parallel or series resistors, it can prove <span
class="math inline">\(\sum_{n=1}^N S_{x_n}^T = 1\)</span> and $ _{n=1}^N
x_n'=T$</p>
<hr />
<p><img src="/2023/07/12/relative-sensitivity/parallel_pgx.drawio.svg"
alt="parallel_pgx.drawio" /></p>
<p>Here <span class="math inline">\(T= R_1 \parallel R_2 =
\frac{R_1R_2}{R_1+R_2}\)</span>, and <span
class="math inline">\(T|_{R_1=8000, R_2=2000} = 1600\)</span></p>
<p>We obtain <em>relative sensitivity:</em> <span
class="math display">\[\begin{align}
S_{R_1}^T &amp; = \frac{R_2}{R_1+R_2} \\
S_{R_2}^T &amp; = \frac{R_1}{R_1+R_2}
\end{align}\]</span></p>
<p>The contribution of <span class="math inline">\(R_1\)</span> and
<span class="math inline">\(R_2\)</span> to <span
class="math inline">\(T\)</span> <span
class="math display">\[\begin{align}
R_1&#39;  &amp;= S_{R_1}^T  T | _{R_1=8000, R_2=2000} = 320 \\
R_2&#39;  &amp;= S_{R_2}^T  T | _{R_1=8000, R_2=2000} = 1280
\end{align}\]</span></p>
<h2 id="scholar">scholar</h2>
<p><strong>Normalized sensitivity</strong> captures <strong>relative
sensitivity</strong></p>
<blockquote>
<p>change in objective per change in design variable</p>
</blockquote>
<p><img src="/2023/07/12/relative-sensitivity/normalized.PNG"
alt="Normalized sensitivity" /></p>
<h2 id="reference">reference</h2>
<p>Olivier de Weck, Karen Willcox. MIT, Gradient Calculation and
Sensitivity Analysis [<a
href="https://ocw.mit.edu/courses/ids-338j-multidisciplinary-system-design-optimization-spring-2010/ce1a087c39ebe629ff93ed57686ada0a_MITESD_77S10_lec09.pdf">pdf</a>]</p>
<p>Karti Mayaram, ECE 521 Fall 2016 Analog Circuit Simulation,
Sensitivity and noise analyses [<a
href="https://web.engr.oregonstate.edu/~karti/ece521/lec16_11_09.pdf">https://web.engr.oregonstate.edu/~karti/ece521/lec16_11_09.pdf</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>What is the proper method to remove old kernels from a Red Hat Enterprise Linux system?</title>
    <url>/2022/05/01/rhel8-old-kernels/</url>
    <content><![CDATA[<p><strong>Red Hat Enterprise Linux 8</strong></p>
<p>The YUM version 4 (based on the upstream <code>DNF</code> project)
method for removing kernels and keeping only the latest version and
running kernel:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum remove --oldinstallonly</span><br></pre></td></tr></table></figure>
<p>From the <code>yum</code> man page:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf [options] remove --oldinstallonly</span><br><span class="line">    Removes old installonly packages, keeping only latest versions and  version  of  running</span><br><span class="line">    kernel.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>network connection using nmcli</title>
    <url>/2022/04/01/rocky-nmcli-network/</url>
    <content><![CDATA[<h4 id="problem">Problem</h4>
<p>There is no network connection and device is not managed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nmcli device status</span><br><span class="line">DEVICE  TYPE      STATE      CONNECTION</span><br><span class="line">eth0    ethernet  unmanaged  --</span><br><span class="line">lo      loopback  unmanaged  --</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/04/01/rocky-nmcli-network/image-20220401011509900.png"
alt="image-20220401011509900" /></p>
<h4 id="solution">solution</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli networking on</span><br></pre></td></tr></table></figure>
<p>Then, <strong>eth0</strong> is connected</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nmcli device status</span><br><span class="line">DEVICE  TYPE      STATE      CONNECTION</span><br><span class="line">eth0    ethernet  connected  Ethernet connection 1</span><br><span class="line">lo      loopback  unmanaged  --</span><br></pre></td></tr></table></figure>
<p><img
src="/2022/04/01/rocky-nmcli-network/image-20220401011543866.png"
alt="image-20220401011543866" /></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Rocky Linux 8 rpm for cadence binary and cdnshelp</title>
    <url>/2022/02/02/rocky8-cadence/</url>
    <content><![CDATA[<p><strong>qt5 and openssl</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install openssl compat-openssl10 qca-qt5-ossl.x86_64 openssl-devel</span><br></pre></td></tr></table></figure>
<p><strong>library preparation for EDA installation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc6, gdb</span><br><span class="line">dc</span><br><span class="line">libncurses5-dev</span><br><span class="line">libncurses5-dev:i386</span><br><span class="line">g++</span><br><span class="line">pstack</span><br><span class="line">libelf1:i386</span><br><span class="line">libgcc-4.8-dev:i386</span><br><span class="line">libstdc++6:i386</span><br><span class="line">gcc-multilib</span><br><span class="line">g++-multilib</span><br><span class="line">libc6-dbg</span><br><span class="line">libc6-dbg:i386</span><br><span class="line">libexpat-dev</span><br><span class="line">libexpat-dev:i386libxss-dev</span><br><span class="line">libxpm4</span><br><span class="line">libxpm4:i386</span><br><span class="line">libmng2</span><br><span class="line">libxss-dev:i386</span><br><span class="line">libxft2</span><br><span class="line">libxft2:i386</span><br><span class="line">libxmu6</span><br><span class="line">libxmu6:i386</span><br><span class="line">libjpeg62-dev</span><br><span class="line">libjpeg62-dev:i386</span><br><span class="line">gnome-core</span><br><span class="line">gnome-core:i386</span><br><span class="line">xfce4</span><br><span class="line">libxml2:i386</span><br><span class="line">libxml2, libXft-dev</span><br><span class="line">libXft-dev:i386</span><br><span class="line">libSM</span><br><span class="line">libSM:i386</span><br><span class="line">libpng3</span><br><span class="line">libpng3:i386</span><br><span class="line">libxi6</span><br><span class="line">libxi6:i386</span><br><span class="line">glibc.i686</span><br><span class="line">libX11.i686</span><br><span class="line">libX11-devel.i686</span><br><span class="line">libX11-devel.x86_64</span><br><span class="line">gcc-c++</span><br><span class="line">compat-readline5</span><br><span class="line">libXext.i686</span><br><span class="line">libXtst.i686</span><br><span class="line">redhat-lsb.i686</span><br><span class="line">libXrender.i686</span><br><span class="line">glibc-devel.i686</span><br><span class="line">zlib.i686</span><br><span class="line">ncompress.x86_64</span><br><span class="line">ksh</span><br><span class="line">openmotif22.i686</span><br><span class="line">openmotif22.x86_64</span><br><span class="line">xterm</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Rocky Linux 8 extend LVM in VMware</title>
    <url>/2022/02/02/rocky8-gparted/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) gparted extend</span><br><span class="line">2)</span><br><span class="line">  lvextend -l +100%FREE /dev/rl/root</span><br><span class="line">3)</span><br><span class="line">  xfs_growfs /dev/mapper/rl-root</span><br><span class="line"></span><br><span class="line">usefull command:</span><br><span class="line">  df -h</span><br><span class="line">  lvdisplay</span><br><span class="line">  fdisk -l</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">https://pocketadmin.tech/en/centos-8-extend-lvm/</span><br><span class="line"></span><br><span class="line">$ sudo lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/rl/swap</span><br><span class="line">  LV Name                swap</span><br><span class="line">  VG Name                rl</span><br><span class="line">  LV UUID                toZKEu-P5oV-6WOV-026Z-eFnI-xaSP-FgEbz5</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time myserver, 2021-12-03 21:28:03 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 2</span><br><span class="line">  LV Size                5.00 GiB</span><br><span class="line">  Current LE             1280</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:1</span><br><span class="line"></span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/rl/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                rl</span><br><span class="line">  LV UUID                S2soRE-umc7-Z6b3-i44x-TiBO-ulnk-ETgEoj</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time myserver, 2021-12-03 21:28:03 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                &lt;194.00 GiB</span><br><span class="line">  Current LE             49663</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>How does UVM&#39;s run_test search testcase ?</title>
    <url>/2022/06/08/run-test/</url>
    <content><![CDATA[<p>It depends on the simulator:</p>
<ul>
<li>QuestaSim, Xcelium: You have to <code>import</code> pkg or
`<code>include</code> file in top testbench</li>
<li>VCS: VCS automatically search testcase in other Compilation
Units</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_pkg.sv</span></span><br><span class="line"><span class="keyword">package</span> sim_pkg;</span><br><span class="line">	<span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line">	<span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> my_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line">		`uvm_component_utils(my_test)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">			<span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">		<span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">			`uvm_info(get_type_name(), <span class="string">&quot;this is run_phase of my_test&quot;</span>, UVM_LOW)</span><br><span class="line">		<span class="keyword">endtask</span> : run_phase</span><br><span class="line">	<span class="keyword">endclass</span> : my_test</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> its_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line">		`uvm_component_utils(its_test)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">			<span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">		<span class="keyword">endfunction</span> : <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">			`uvm_info(get_type_name(), <span class="string">&quot;this is run_phase of its_test&quot;</span>, UVM_LOW)</span><br><span class="line">		<span class="keyword">endtask</span> : run_phase</span><br><span class="line">	<span class="keyword">endclass</span> : its_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">endpackage</span> : sim_pkg</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tb_top.sv</span></span><br><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">	<span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line">	<span class="comment">//import sim_pkg::*;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		run_test();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 78%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th>simulator</th>
<th>cmd</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VCS</td>
<td><code>vcs -sverilog -ntb_opts uvm-1.2 test_pkg.sv tb_top.sv</code><br /><code>./simv +UVM_TESTNAME=my_test</code></td>
<td>✓</td>
</tr>
<tr class="even">
<td>Xcelium</td>
<td><code>xrun -64 -uvmhome CDNS-1.2 test_pkg.sv tb_top.sv +UVM_TESTNAME=my_test</code></td>
<td>✗</td>
</tr>
<tr class="odd">
<td>QuestaSim</td>
<td><code>vlog test_pkg.sv tb_top.sv -L $QUESTA_HOME/uvm-1.2</code><br /><code>vsim -c -do "run -all;exit" +UVM_TESTNAME=my_test work.tb_top -L $QUESTA_HOME/uvm-1.2</code></td>
<td>✗</td>
</tr>
</tbody>
</table>
<p><em>Xcelium log:</em></p>
<blockquote>
<p><code>UVM_WARNING @ 0: reporter [BDTYP] Cannot create a component of type 'my_test' because it is not registered with the factory. UVM_FATAL @ 0: reporter [INVTST] Requested test from command line +UVM_TESTNAME=my_test not found. UVM_INFO /home/EDA/Cadence/XCELIUM2109/tools/methodology/UVM/CDNS-1.2/sv/src/base/uvm_report_catcher.svh(705) @ 0: reporter [UVM/REPORT/CATCHER]</code></p>
</blockquote>
<p><em>QuestaSim log:</em></p>
<blockquote>
<p><code># UVM_INFO verilog_src/questa_uvm_pkg-1.2/src/questa_uvm_pkg.sv(277) @ 0: reporter [Questa UVM] QUESTA_UVM-1.2.3</code>
<code># UVM_INFO verilog_src/questa_uvm_pkg-1.2/src/questa_uvm_pkg.sv(278) @ 0: reporter [Questa UVM]  questa_uvm::init(+struct)</code>
<code># UVM_WARNING @ 0: reporter [BDTYP] Cannot create a component of type 'my_test' because it is not registered with the factory.</code>
<code># UVM_FATAL @ 0: reporter [INVTST] Requested test from command line +UVM_TESTNAME=my_test not found.</code>
<code># UVM_INFO verilog_src/uvm-1.2/src/base/uvm_report_server.svh(847) @ 0: reporter [UVM/REPORT/SERVER]</code></p>
</blockquote>
<p><strong>solution:</strong></p>
<p>uncomment <code>//import sim_pkg::*;</code> in <em>tb_top.sv</em></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Sampling of Continuous Time Signals</title>
    <url>/2022/05/01/sampling-dft/</url>
    <content><![CDATA[<p>The sampling process mathematically in the two stages:</p>
<ul>
<li><p>impulse train modulator <span class="math display">\[
x_s(t)=x_c(t)s(t)
\]</span></p></li>
<li><p>impulse train to a sequence</p></li>
</ul>
<p><img src="/2022/05/01/sampling-dft/image-20230519000700841.png"
alt="image-20230519000700841" /></p>
<h2 id="impulse-train-modulator">impulse train modulator</h2>
<p><img src="/2022/05/01/sampling-dft/image-20230519000740312.png"
alt="image-20230519000740312" /></p>
<blockquote>
<p>Arrows with length proportional to their area.</p>
</blockquote>
<p>The periodic impulse train is <span class="math display">\[
s(t) = \sum_{n=-\infty}^{+\infty}\delta (t-nT)
\]</span> where <span class="math inline">\(\delta (t)\)</span> is the
<strong>unit</strong> impulse function, or Dirac delta function; <span
class="math inline">\(T\)</span> is the <em>sampling period</em>, and
its reciprocal, <span class="math inline">\(f_s=1/T\)</span>, is the
<em>sampling frequency</em>, in samples per second.</p>
<p>The product of <span class="math inline">\(s(t)\)</span> and <span
class="math inline">\(x_c (t)\)</span> is therefore</p>
<p><span class="math display">\[\begin{align}
x_s (t) &amp;= x_c(t)s(t) \\
&amp;= x_c(t) \sum_{n=-\infty}^{+\infty}\delta (t-nT) =
\sum_{n=-\infty}^{+\infty}x_c(t)\delta (t-nT)
\end{align}\]</span></p>
<p>The impulse train sampling <span
class="math inline">\(x_s(t)\)</span> can be expressed as <span
class="math display">\[
x_s(t) = \sum_{n=-\infty}^{+\infty}x_c(nT)\delta (t-nT)
\]</span> i.e., the size (area) of the <em>impulse</em> at sample time
<span class="math inline">\(nT\)</span> is equal to the value of the
continuous-time signal at that time.</p>
<h3 id="x_st-in-frequency-domain"><span
class="math inline">\(x_s(t)\)</span> in Frequency-domain</h3>
<p><span class="math display">\[
X_s(j\Omega) = \frac{1}{T}\sum_{k=-\infty}^{+\infty}X_c(j(\Omega -
k\Omega_s))
\]</span></p>
<blockquote>
<p>The relationship between the Fourier transforms of the input and the
output of the <em>impulse train modulator</em></p>
</blockquote>
<p><img src="/2022/05/01/sampling-dft/image-20230519002317865.png"
alt="image-20230519002317865" /></p>
<h2 id="impulse-train-to-a-sequence">impulse train to a sequence</h2>
<p><img src="/2022/05/01/sampling-dft/image-20230519000938294.png"
alt="image-20230519000938294" /></p>
<blockquote>
<ul>
<li><p>The <span class="math inline">\(x_s(t)\)</span> is, in a sense, a
<em>continuous-time signal (specifically, an impulse train)</em> that is
zero,except at integer multiples of <span
class="math inline">\(T\)</span>.</p></li>
<li><p>The sequence <span class="math inline">\(x[n]\)</span> is indexed
on the integer variable <span class="math inline">\(n\)</span>, which
introduces a <em>time normalization</em>, <span
class="math inline">\(x[n]\)</span> contains <strong>no</strong>
explicit information about the sampling period <span
class="math inline">\(T\)</span></p></li>
<li><p>The samples of <span class="math inline">\(x_c(t)\)</span> are
represented by <em>finite numbers</em> in <span
class="math inline">\(x[n]\)</span> rather than as the <em>areas of
impulses</em> in <span class="math inline">\(x_s(t)\)</span></p></li>
</ul>
</blockquote>
<p>Our eventual objective is to express <span
class="math inline">\(X(e^{j\omega})\)</span>, the <em>discrete-time
Fourier transform (DTFT) of the sequence <span
class="math inline">\(x[n]\)</span></em>, in terms of <span
class="math inline">\(X_s(j\Omega)\)</span> and <span
class="math inline">\(X_c(j\Omega)\)</span>.</p>
<p>Toward this end, let us consider an alternative expression for <span
class="math inline">\(X_s(j\Omega)\)</span>, Applying the
continuous-time Fourier transform to <span class="math inline">\(x_s(t)
= \sum_{n=-\infty}^{+\infty}x_c(nT)\delta (t-nT)\)</span>, we obtain
<span class="math display">\[
X_s(j\Omega) = \sum_{n=-\infty}^{+\infty}x_c(nT)e^{-j\Omega Tn}
\]</span> and <span class="math display">\[
X(e^{j\omega}) =\sum_{n=-\infty}^{+\infty}x[n]e^{-j\omega n}
\]</span> where DTFT is applied</p>
<p>Since <span class="math display">\[
x[n] = x_c(nT)
\]</span> it follows that <span class="math display">\[
X_s(j\Omega) = X(e^{j\omega})|_{\omega=\Omega T} = X(e^{j\Omega T})
\]</span> Consequently, <span class="math display">\[
X(e^{j\Omega T}) =X_s(j\Omega)=
\frac{1}{T}\sum_{k=-\infty}^{+\infty}X_c(j(\Omega - k\Omega_s))
\]</span></p>
<p>or equivalently, <span class="math display">\[
X(e^{j\omega}) = \frac{1}{T}\sum_{k=-\infty}^{+\infty}X_c \left[
j\left(\frac{\omega}{T} - \frac{2\pi k}{T}\right)\right]
\]</span></p>
<blockquote>
<p><span class="math inline">\(\omega\)</span>: radians per sample</p>
<p><span class="math inline">\(\Omega\)</span>: radians per second</p>
</blockquote>
<p>The factor <span class="math inline">\(\frac{1}{T}\)</span> in <span
class="math inline">\(X(e^{j\omega})\)</span> is misleading, actually
<span class="math inline">\(x[n]\)</span> is not scaled by <span
class="math inline">\(\frac{1}{T}\)</span> when taking <span
class="math inline">\(\omega\)</span> variable of integration into
account <span class="math display">\[\begin{align}
x_r[n] &amp;= \frac{1}{2\pi} \int_{2\pi}X(e^{j\omega})e^{j\omega
n}d\omega \\
&amp;= \frac{1}{2\pi}\int_{2\pi}\frac{1}{T}\sum_{k=-\infty}^{+\infty}X_c
\left[ j\left(\frac{\omega}{T} - \frac{2\pi k}{T}\right)\right]
e^{j\omega n}d\omega \\
&amp;\simeq \frac{1}{2\pi}\frac{1}{T}\int_{2\pi}X_c (\frac{\omega}{T} )
e^{j\omega  n} d\omega \\
&amp;=\frac{1}{2\pi} \frac{1}{T}\int_{2\pi} \left[
\int_{\infty}X_c(\Phi)\delta (\Phi - \frac{\omega}{T} )d\Phi
\right]  e^{j\omega  n} d\omega \\
&amp;=\frac{1}{2\pi} \frac{1}{T} \int_{\infty}X_c(\Phi)d\Phi
\int_{2\pi}\delta (\Phi - \frac{\omega}{T} )e^{j\omega  n} d\omega \\
&amp;=\frac{1}{2\pi} \frac{1}{T} \int_{\infty}X_c(\Phi)d\Phi
\int_{2\pi}T\cdot \delta (\Phi T - \omega )e^{j\omega  n} d\omega \\
&amp;=\frac{1}{2\pi} \int_{\infty}X_c(\Phi) e^{j\Phi T n}d\Phi
\end{align}\]</span></p>
<p>That is <span class="math display">\[\begin{align}
x_r[n] &amp;= \frac{1}{2\pi}\int_{2\pi} \frac{1}{T}X_c (\frac{\omega}{T}
) e^{j\omega  n} d\omega \\
&amp;= \frac{1}{2\pi} \int_{\infty}X_c(\Omega) e^{j\Omega T n}d\Omega
\tag{31}
\end{align}\]</span></p>
<blockquote>
<p>assuming Nyquist–Shannon sampling theorem is met</p>
</blockquote>
<p><span class="math display">\[\begin{align}
x_r[n] &amp;= \frac{1}{2\pi} \int_{\infty}X_c(\Omega) e^{j\Omega T
n}d\Omega \\
&amp;= \frac{1}{2\pi} \int_{\infty}X_c(\Omega) e^{j\Omega t}d\Omega \\
&amp;= x_c(t)
\end{align}\]</span></p>
<p>where <span class="math inline">\(t = T n\)</span>, then <span
class="math inline">\(x_r[n] = x_c(nT)\)</span></p>
<hr />
<p>Assuming <span class="math inline">\(x_c(t) = \cos(\omega_0
t)\)</span>, <span class="math inline">\(x_s(t)=
\sum_{n=-\infty}^{\infty}x_c(nT)\delta(t-nT)\)</span> and <span
class="math inline">\(x[n]=x_c(nT)\)</span>, that is <span
class="math display">\[\begin{align}
x_c(t) &amp; = \cos(\omega_0 t) \\
x_s(t) &amp;= \sum_{n=-\infty}^{\infty}\cos(\omega_0 nT)\delta(t-nT) \\
x[n] &amp;= \cos(\omega_0 nT)
\end{align}\]</span></p>
<ul>
<li><p><span class="math inline">\(X_c(j\Omega)\)</span>, the Fourier
Transform of <span class="math inline">\(x_c(t)\)</span> <span
class="math display">\[
X_c(j\Omega) = \pi[\delta(\Omega - \Omega_0) + \delta(\Omega +
\Omega_0)]
\]</span></p></li>
<li><p><span class="math inline">\(X(e^{j\omega})\)</span>​, the the
discrete-time Fourier transform (DTFT) of the sequence <span
class="math inline">\(x[n]\)</span> <span class="math display">\[
X(e^{j\omega}) =\sum_{k=-\infty}^{+\infty}\pi[\delta(\omega -
\omega_0-2\pi k) + \delta(\omega + \omega_0-2\pi k)]
\]</span></p></li>
<li><p><span class="math inline">\(X_s(j\Omega)\)</span>, the Fourier
Transform of <span class="math inline">\(x_s(t)\)</span> <span
class="math display">\[
X_s(j\Omega)= \frac{1}{T}\sum_{k=-\infty}^{+\infty}\pi[\delta(\Omega -
\Omega_0-k\Omega_s) + \delta(\Omega + \Omega_0-k\Omega_s)]
\]</span></p></li>
</ul>
<p>Express <span class="math inline">\(X(e^{j\omega})\)</span> in terms
of <span class="math inline">\(X_s(j\Omega)\)</span> and <span
class="math inline">\(X_c(j\Omega)\)</span> <span
class="math display">\[
X(e^{j\omega}) =
\frac{1}{T}\sum_{k=-\infty}^{+\infty}\pi[\delta(\frac{\omega}{T} -
\Omega_0-k\Omega_s) + \delta(\frac{\omega}{T} + \Omega_0-k\Omega_s)]
\]</span> Inverse <span class="math inline">\(X(e^{j\omega})\)</span>
<span class="math display">\[\begin{align}
x_r[n] &amp;= \frac{1}{2\pi} \int_{2\pi}X(e^{j\omega}) e^{j\omega n}
d\omega \\
&amp;= \frac{1}{2\pi}\int_{2\pi} \pi[\delta(\frac{\omega}{T} - \Omega_0)
+ \delta(\frac{\omega}{T} + \Omega_0)]e^{j\omega n} d\frac{\omega}{T} \\
&amp;= \frac{1}{2\pi}\int_{2\pi} \pi[\delta(\frac{\omega}{T} -
\Omega_0)e^{j\omega_0 n} + \delta(\frac{\omega}{T} +
\Omega_0)e^{-j\omega_0 n}] d\frac{\omega}{T} \\
&amp;= \frac{1}{2}[ e^{j\omega_0 n}\int_{2\pi} [\delta(\frac{\omega}{T}
- \Omega_0)d\frac{\omega}{T} + e^{-j\omega_0 n}\int_{2\pi}
[\delta(\frac{\omega}{T} + \Omega_0)d\frac{\omega}{T}] \\
&amp;= \frac{1}{2}[ e^{j\omega_0 n} + e^{-j\omega_0 n} ] \\
&amp;= \cos(\omega_0 n)
\end{align}\]</span></p>
<p>or follow EQ.(31)</p>
<p><span class="math display">\[\begin{align}
x_r[n] &amp;= \frac{1}{2\pi} \int_{\infty}X_c(\Omega) e^{j\Omega T
n}d\Omega \\
&amp;= \frac{1}{2\pi} \int_{\infty} \pi[\delta(\Omega - \Omega_0) +
\delta(\Omega + \Omega_0)]e^{j\Omega T n}d\Omega \\
&amp;= \frac{1}{2}(e^{j\Omega_0 T n}+e^{-j\Omega_0 T n}) \\
&amp;= \cos(\omega_0 n)
\end{align}\]</span></p>
<p>where <span class="math inline">\(\omega_0 = \Omega_0 T\)</span></p>
<hr />
<h2 id="impulse-invariance">Impulse Invariance</h2>
<p><span class="math display">\[
h[n] = Th_c(nT)
\]</span></p>
<p>When <span class="math inline">\(h[n]\)</span> and <span
class="math inline">\(h_c(t)\)</span> are related through the above
equation, i.e., the impulse response of the discrete-time system is a
<em>scaled</em>, <em>sampled</em> version of <span
class="math inline">\(h_c(t)\)</span>, the <em>discrete-time system</em>
is said to be an <strong>impulse-invariant</strong> version of the
<em>continuous-time system</em>.</p>
<p>we have <span class="math display">\[
H(e^{j\omega}) = H_c\left(j\frac{\omega}{T}\right)
\]</span></p>
<h2 id="application---transfer-function">Application - Transfer
function</h2>
<h3 id="sampled-impulse-response">sampled impulse response</h3>
<p>The below equation demonstrates how to obtain <strong>continuous
Fourier Transform</strong> from <strong>DTFT</strong> . <span
class="math display">\[
X_c(\omega) = T \cdot X(\omega)
\]</span></p>
<blockquote>
<p><span class="math inline">\(T\)</span> is sample period, follow
previous equation</p>
</blockquote>
<h3 id="useful-functions">useful functions</h3>
<ul>
<li><p>using <code>fft</code></p>
<p>The outputs of the DFT are <strong>samples</strong> of the
DTFT</p></li>
<li><p>using <code>freqz</code></p>
<p>modeling as <strong>FIR filter</strong>, and the impulse response
sequence of an FIR filter is the same as the sequence of filter
coefficients, we can express the frequency response in terms of either
the filter coefficients or the impulse response</p>
<blockquote>
<p><code>fft</code> is used in <code>freqz</code> internally</p>
</blockquote></li>
</ul>
<h3 id="practical-example">Practical Example</h3>
<p><strong>Question</strong>:</p>
<p>​ How to obtain continuous system transfer function from sampled
impulse</p>
<p><strong>Answer</strong>:</p>
<p>​ using above mentioned functions</p>
<hr />
<blockquote>
<p>First order lowpass filter with 3-dB frequency
<strong>1Hz</strong></p>
</blockquote>
<p><img src="/2022/05/01/sampling-dft/image-20220501020004068.png"
alt="image-20220501020004068" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% continuous system</span></span><br><span class="line">s = tf(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">h = <span class="number">2</span>*<span class="built_in">pi</span>/(<span class="number">2</span>*<span class="built_in">pi</span>+s);</span><br><span class="line">[mag, phs, wout] = bode(h);</span><br><span class="line">fct = wout(:)/<span class="number">2</span>/<span class="built_in">pi</span>;</span><br><span class="line">Hct_dB = <span class="number">20</span>*<span class="built_in">log10</span>(mag(:));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fstep = <span class="number">0.01</span>;           <span class="comment">% freq resolution</span></span><br><span class="line">fnyqst = <span class="number">100</span>;</span><br><span class="line">Ts = <span class="number">1</span>/(<span class="number">2</span>*fnyqst);</span><br><span class="line">Fs = <span class="number">1</span>/Ts;              <span class="comment">% sampling freq</span></span><br><span class="line">Ns = <span class="built_in">ceil</span>(Fs/fstep);    <span class="comment">% samping points</span></span><br><span class="line">fstep = Fs/Ns;          <span class="comment">% update fstep</span></span><br><span class="line">t = (<span class="number">0</span>:Ns<span class="number">-1</span>)*Ts;        <span class="comment">% sampling time points</span></span><br><span class="line"></span><br><span class="line">y = impulse(h, t);      <span class="comment">% impulse resp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% modelling as discrete system</span></span><br><span class="line">Y = fft(y);                 <span class="comment">% dft</span></span><br><span class="line">Hfft = Y * Ts;              <span class="comment">% !!! multiply Ts</span></span><br><span class="line">Hfft_dB = <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(Hfft(<span class="number">1</span>:Ns/<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">ffft = (<span class="number">1</span>:Ns/<span class="number">2</span>+<span class="number">1</span>)*fstep - fstep;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Hfir, ffir] = freqz(y, <span class="number">1</span>, [], <span class="number">1</span>/Ts);   <span class="comment">% modelling as FIR</span></span><br><span class="line">Hfir = Hfir * Ts;           <span class="comment">% !!! multiply Ts</span></span><br><span class="line">Hfir_dB = <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(Hfir));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">semilogx(fct, Hct_dB, <span class="string">&#x27;k&#x27;</span>, ffft, Hfft_dB, <span class="string">&#x27;r.-&#x27;</span>, ffir, Hfir_dB, <span class="string">&#x27;b--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;bode(s)&#x27;</span>, <span class="string">&#x27;fft&#x27;</span>, <span class="string">&#x27;FIR model&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Freq(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;dB&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1e-2</span> <span class="number">1e2</span>]);</span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&#x27;frequency response of different methods&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="gotcha">Gotcha</h2>
<p>A remarkable fact of linear systems is that the <strong>complex
exponentials</strong> are <strong>eigenfunctions</strong> of a linear
system, as the system output to these inputs equals the input multiplied
by a constant factor.</p>
<ul>
<li>Both amplitude and phase may change</li>
<li>but the frequency does not change</li>
</ul>
<blockquote>
<p>For an input <span class="math inline">\(x(t)\)</span>, we can
determine the output through the use of the convolution integral, so
that with <span class="math inline">\(x(t) = e^{st}\)</span> <span
class="math display">\[\begin{align}
y(t) &amp;= \int_{-\infty}^{+\infty}h(\tau)x(t-\tau)d\tau \\
&amp;= \int_{-\infty}^{+\infty} h(\tau) e^{s(t-\tau)}d\tau \\
&amp;= e^{st}\int_{-\infty}^{+\infty} h(\tau) e^{-s\tau}d\tau \\
&amp;= e^{st}H(s)
\end{align}\]</span></p>
</blockquote>
<p>Take the input signal to be a complex exponential of the form <span
class="math inline">\(x(t)=Ae^{j\phi}e^{j\omega t}\)</span></p>
<p><span class="math display">\[\begin{align}
y(t) &amp;= h(t)*x(t) \\
&amp;= H(j\omega)Ae^{j\phi}e^{j\omega t}
\end{align}\]</span></p>
<p>The frequency response at <span
class="math inline">\(-\omega\)</span> is the <strong>complex
conjugate</strong> of the frequency response at <span
class="math inline">\(+\omega\)</span>, given <span
class="math inline">\(h(t)\)</span> is real</p>
<p><span class="math display">\[\begin{align}
H^*(t) &amp;= \left(\int_{-\infty}^{+\infty}h(t)e^{-j\omega
t}dt\right)^* \\
&amp;= \int_{-\infty}^{+\infty}h^*(t)e^{+j\omega t}dt \\
&amp;= \int_{-\infty}^{+\infty}h(t)e^{-j(-\omega t)}dt \\
&amp;= H(-j\omega)
\end{align}\]</span></p>
<p>The <strong>real cosine signal</strong> is actually composed of two
<strong>complex exponential signals</strong>: one with positive
frequency and the other with negative <span class="math display">\[
cos(\omega t + \phi) = \frac{e^{j(\omega t + \phi)} + e^{-j(\omega t +
\phi)}}{2}
\]</span></p>
<p>The sinusoidal response is the sum of the complex-exponential
response at the positive frequency <span
class="math inline">\(\omega\)</span> and the response at the
corresponding negative frequency <span
class="math inline">\(-\omega\)</span> because of LTI systems's
superposition property</p>
<ul>
<li><p>input: <span class="math display">\[\begin{align}
x(t) &amp;= A cos(\omega t + \phi) \\
&amp;= \frac{1}{2}Ae^{\phi}e^{\omega t} +
\frac{1}{2}Ae^{-\phi}e^{-\omega t}
\end{align}\]</span></p></li>
<li><p>output with <span
class="math inline">\(H(j\omega)=Ge^{j\theta}\)</span>: <span
class="math display">\[\begin{align}
y(t) &amp;= H(j\omega)\frac{1}{2}Ae^{\phi}e^{\omega t}
+  H(-j\omega)\frac{1}{2}Ae^{-\phi}e^{-\omega t} \\
&amp;= Ge^{j\theta}\frac{1}{2}Ae^{\phi}e^{\omega t} +
Ge^{-j\theta}\frac{1}{2}Ae^{-\phi}e^{-\omega t} \\
&amp;= GAcos(\omega t + \phi + \theta)
\end{align}\]</span></p></li>
</ul>
<p>Its phase shift is <span class="math inline">\(\theta\)</span> and
gain is <span class="math inline">\(G\)</span>, which is same with <span
class="math inline">\(H(j\omega)\)</span>.</p>
<h2 id="reference">reference</h2>
<p>James H. McClellan, Ronald Schafer, and Mark Yoder. 2015. DSP First
(2nd. ed.). Prentice Hall Press, USA.</p>
<p><a href="https://www.mathworks.com/help/matlab/ref/fft.html">fft -
https://www.mathworks.com/help/matlab/ref/fft.html</a></p>
<p><a href="https://www.mathworks.com/help/signal/ref/freqz.html">freqz
- https://www.mathworks.com/help/signal/ref/freqz.html</a></p>
<p><a
href="https://www.cs.ccu.edu.tw/~wtchu/courses/2012s_DSP/Lectures/Lecture%2026%20Frequency%20Response.pdf">Wei-Ta
Chu, 2012s_DSP - Lecture 26 Frequency Response</a></p>
<p>Relationship between continuous-time and discrete-time Fourier
transforms URL: <a
href="https://blogs.mathworks.com/steve/2010/01/18/relationship-between-continuous-time-and-discrete-time-fourier-transforms/">https://blogs.mathworks.com/steve/2010/01/18/relationship-between-continuous-time-and-discrete-time-fourier-transforms/</a></p>
<p>Oppenheim, Alan V. and Cram. “Discrete-time signal processing : Alan
V. Oppenheim, 3rd edition.” (2011).</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Understanding the save parameter in spectre</title>
    <url>/2022/09/23/save-parameter-spectre/</url>
    <content><![CDATA[<p><strong>none</strong>:</p>
<p>​ Does not save any data (currently does save one node chosen at
random)</p>
<p><strong>selected</strong>:</p>
<p>​ Saves only signals specified with save statements. The default
setting.</p>
<p><strong>lvlpub</strong>:</p>
<pre><code>Saves all signals that are normally useful up to nestlvl deep in the subcircuit hierarchy. This option is equivalent to allpub for subcircuits.</code></pre>
<p><strong>lvl</strong>:</p>
<p>​ Saves all signals up to nestlvl deep in the subcircuit hierarchy.
This option is relevant for subcircuits.</p>
<p><strong>allpub</strong>:</p>
<p>​ Saves only signals that are normally useful.</p>
<p><strong>all</strong>:</p>
<p>​ Saves all signals.</p>
<blockquote>
<p>Signals that are "normally useful" include the shared node voltages
and currents through voltage sources and iprobes, and exclude the
internal nodes on devices (the internal collector, base, emitter on a
BJT, the internal drain, source on a FET, and so on). It also excludes
currents through inductors, controlled sources, transmission lines,
transformers, etc.</p>
<p>If you use <strong>lvl</strong> or <strong>all</strong> instead of
<strong>lvlpub</strong> or <strong>allpub</strong>, you will also get
internal node voltages and currents through other components that happen
to compute current.</p>
<p>Thus, using <strong>*pub</strong> excludes internal nodes on devices
(the internal collector, base, emitter on a BJT, the internal drain and
source on a FET, etc). It also excludes the currents through inductors,
controlled sources, transmission lines, transformers, etc.</p>
</blockquote>
<blockquote>
<p><strong>nestlvl</strong></p>
<p>This variable is used to save groups of signals as results and when
signals are saved in subcircuits. The nestlvl parameter also specifies
how many levels deep into the subcircuit hierarchy you want to save
signals.</p>
</blockquote>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>Time-Domain Channel Simulation</title>
    <url>/2023/09/23/sbr-der/</url>
    <content><![CDATA[<p>Three fast time-domain system simulation techniques:</p>
<ul>
<li><strong>single-bit response method</strong></li>
<li><strong>double-edge response method</strong></li>
<li><strong>multiple-edge response method</strong></li>
</ul>
<h2 id="single-bit-response-sbr-method">Single-Bit Response (SBR)
Method</h2>
<p>To avoid spurious glitches between consecutive ones, rising and
falling edge responses shall be <strong>symmetric</strong>. This is the
limitation of SBR method.</p>
<p>Let <span class="math inline">\(p(t)\)</span> be the SBR of the
channel, <span class="math inline">\(t_s\)</span> be the data sampling
phase, <span class="math inline">\(T\)</span> be the bit time, <span
class="math inline">\(N_c\)</span> is the number of UI in stored pulse
response and <span class="math inline">\(b_m\)</span> be the <span
class="math inline">\(m\)</span>th transmitted symbol. The voltage seen
by the receiver's data sampler at the <span
class="math inline">\(m\)</span>th data sample is determined by <span
class="math display">\[
y_m = \sum_{k=m-N_c+1}^{m}b_kp(t_s+(m-k)T)
\]</span> where <span class="math inline">\(b_k \in [0, 1]\)</span> and
<span class="math inline">\(p(t) \ge 0\)</span></p>
<p>We always prepend <span class="math inline">\(Nc-1\)</span> 0s in
random bit stream for consistency.</p>
<p><img src="/2023/09/23/sbr-der/image-20220429112902281.png"
alt="image-20220429112902281" /></p>
<p>For computation convenient, the pulse need to be positive. For
differential signal and amplitude <span
class="math inline">\(V_{peak}\)</span>, the peak to peak is <span
class="math inline">\(-V_{peak}\)</span> to <span
class="math inline">\(+V_{peak}\)</span>. After pulse added by <span
class="math inline">\(V_{peak}\)</span>, peak to peak is <span
class="math inline">\(0\)</span> to <span
class="math inline">\(+2V_{peak}\)</span>.</p>
<p><img src="/2023/09/23/sbr-der/image-20220429154336080.png"
alt="image-20220429154336080" /></p>
<p><img src="/2023/09/23/sbr-der/image-20220429154423247.png"
alt="image-20220429154423247" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">yy_sum = <span class="built_in">zeros</span>(OSR*Ns, Ns);</span><br><span class="line"><span class="keyword">for</span> idxBit = <span class="number">1</span>:Ns</span><br><span class="line">    bs_split = <span class="built_in">zeros</span>(<span class="number">1</span>, Ns+Nc<span class="number">-1</span>);</span><br><span class="line">    bs_split(idxBit) = bs(idxBit);</span><br><span class="line">    yy = <span class="built_in">zeros</span>(OSR, Ns);</span><br><span class="line">    <span class="keyword">for</span> ii = Nc:Nc+Ns<span class="number">-1</span></span><br><span class="line">        bb = bs_split(ii:<span class="number">-1</span>:ii-Nc+<span class="number">1</span>);</span><br><span class="line">        yy(:,ii-Nc+<span class="number">1</span>) = sum(bb.*yrps, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    yy_cont2 = <span class="built_in">reshape</span>(yy, [], <span class="number">1</span>);</span><br><span class="line">    h = <span class="built_in">plot</span>(yy_cont2);</span><br><span class="line">    h.Annotation.LegendInformation.IconDisplayStyle = <span class="string">&#x27;off&#x27;</span>;</span><br><span class="line">    yy_sum(:, idxBit) = yy_cont2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">yy_sum = sum(yy_sum, <span class="number">2</span>);    <span class="comment">% merge</span></span><br><span class="line"><span class="built_in">plot</span>(yy_sum, <span class="string">&#x27;k--&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(yy_cont, <span class="string">&#x27;m-.&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;syn&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;merge all single bit&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\times Ts)&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The pulse response contain rising and falling edge. The <strong>1 bit
</strong> first rise from -1 to 1, then fall to -1; The <strong>0
bit</strong> just do nothing for synthesized waveform with the help of
falling edge of <strong>1 bit</strong>.</p>
<p>The DC shift help deal with continuous <strong>0 bits</strong>.</p>
</blockquote>
<p><img src="/2023/09/23/sbr-der/image-20220429174330324.png"
alt="image-20220429174330324" /></p>
<h3 id="another-sbr-example">another SBR example</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">21</span>);</span><br><span class="line">n = [<span class="number">1</span>:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% post cursor</span></span><br><span class="line"><span class="keyword">for</span> m = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">    A(m, <span class="number">11</span>+n(m)) = <span class="number">0.5</span>;</span><br><span class="line">    A(m, <span class="number">11</span>-n(m)) = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% one</span></span><br><span class="line"><span class="keyword">for</span> m = <span class="number">4</span>:<span class="number">10</span></span><br><span class="line">    A(m, <span class="number">11</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% h0 or main cursor</span></span><br><span class="line">h0 = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">21</span>);</span><br><span class="line">h0(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">0.5</span>;</span><br><span class="line">h0(<span class="number">1</span>, <span class="number">21</span>) = <span class="number">0.5</span>;</span><br><span class="line">out = h0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    out = conv(out, A(m, :), <span class="string">&quot;full&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stem(out)</span><br></pre></td></tr></table></figure>
<p><img
src="/2023/09/23/sbr-der/143512636-0878e0fd-fe87-414c-9c73-52577eeb7593.jpg"
alt="143512636-0878e0fd-fe87-414c-9c73-52577eeb7593" /></p>
<p><img
src="/2023/09/23/sbr-der/143512677-ccefdf22-4e30-4e72-9220-bbe667671e79.png"
alt="143512677-ccefdf22-4e30-4e72-9220-bbe667671e79" /></p>
<h2 id="double-edge-response-der-method">Double-Edge Response (DER)
Method</h2>
<p>To handle the more general cases, with <strong>asymmetric rising and
falling edges</strong>, the system response can be constructed in terms
of <strong>edge transitions instead of bit responses</strong>.</p>
<p>The DER method decomposes the input data pattern, in terms of
<strong>rising and falling edge transitions</strong>. The system
response can be calculated by <em>superimposing the shifted versions of
the rising and falling edge responses</em> : <span
class="math display">\[
y_m = \sum_{k=m-N_c+1}^{m}(b_k-b_{k-1})s_k(t_s+(m-k)T) + y_{int}
\]</span> where</p>
<p><span class="math display">\[\begin{align}
s_i(t) &amp;= r(t) -V_{low} \quad \text{if} \: (b_i\gt b_{i-1}) \\
&amp;= V_{high}-f(t) \quad \text{otherwise}
\end{align}\]</span></p>
<p><span class="math inline">\(r(t)\)</span> and <span
class="math inline">\(f(t)\)</span> are the rising and falling edge
responses,respectively. <span class="math inline">\(V_{high}\)</span>
and <span class="math inline">\(V_{low}\)</span> are the steady state DC
levels, in response to a constant stream of ones and zeros,
respectively. <span class="math inline">\(y_{int}\)</span> is the
initial DC state (either <span class="math inline">\(V_{high}\)</span>
or <span class="math inline">\(V_{low}\)</span> ).</p>
<p>We always prepend <span class="math inline">\(Nc\)</span> 0s in
random bit stream for consistency.</p>
<p><img src="/2023/09/23/sbr-der/image-20220429191941805.png"
alt="image-20220429191941805" /></p>
<p><img src="/2023/09/23/sbr-der/der.drawio.svg" alt="der.drawio" /></p>
<p><img src="/2023/09/23/sbr-der/image-20220430010336977.png"
alt="image-20220430010336977" /></p>
<p><img src="/2023/09/23/sbr-der/image-20220430013715680.png"
alt="image-20220430013715680" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(yrc);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(yfc);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;rising&#x27;</span>, <span class="string">&#x27;falling&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\times Ts)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;step response&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">stem(bs, <span class="string">&#x27;k&#x27;</span>); grid on;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">stem((idxPreRspStart:idxPreRspEnd), bs(idxPreRspStart:idxPreRspEnd), <span class="string">&quot;filled&quot;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">stem(idxPreRspStart, bs(idxPreRspStart), <span class="string">&#x27;go&#x27;</span>);</span><br><span class="line">stem(idxCurData, bs(idxCurData), <span class="string">&quot;filled&quot;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">stem((idxPreRspStart:idxPreRspEnd)+<span class="number">0.5</span>, <span class="number">0.1</span>.*bd(idxPreRspStart:idxPreRspEnd), <span class="string">&#x27;bd-.&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;Nc bits&#x27;</span>, <span class="string">&#x27;y_&#123;int&#125;&#x27;</span>, <span class="string">&#x27;Current bit&#x27;</span>, <span class="string">&#x27;Edge Transitions&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\times UI)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;input stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">yy_cont = <span class="built_in">reshape</span>(yy, [], <span class="number">1</span>);   <span class="comment">% continuous version</span></span><br><span class="line"><span class="built_in">plot</span>(yy_cont); grid on;</span><br><span class="line">title(<span class="string">&#x27;continuous yout&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\times Ts)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> idx = idxPreRspStart+<span class="number">1</span>-Nc:idxCurData+<span class="number">32</span>-Nc</span><br><span class="line">    ys = yy(:, idx);</span><br><span class="line">    tt = ((idx<span class="number">-1</span>)*OSR+<span class="number">1</span>:idx*OSR);</span><br><span class="line">    h = <span class="built_in">plot</span>(tt(:), ys(:), <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">    h.Annotation.LegendInformation.IconDisplayStyle = <span class="string">&#x27;off&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(yy_cont, <span class="string">&#x27;m--&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;syn&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\times Ts)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;synthesize with step response&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<h2 id="reference">Reference</h2>
<p>Oh, Kyung Suk Dan, and Xing Chao Chuck Yuan. High-Speed Signaling:
Jitter Modeling, Analysis, and Budgeting. Prentice Hall, 2011.</p>
<p>Ren, Jihong and Kyung Suk Oh. “Multiple Edge Responses for Fast and
Accurate System Simulations.” <em>IEEE Transactions on Advanced
Packaging</em> 31 (2008): 741-748.</p>
<p>Shi, Rui. “Off-chip wire distribution and signal analysis.”
(2008).</p>
<p>X. Chu, W. Guo, J. Wang, F. Wu, Y. Luo and Y. Li, "Fast and Accurate
Estimation of Statistical Eye Diagram for Nonlinear High-Speed Links,"
in IEEE Transactions on Very Large Scale Integration (VLSI) Systems,
vol. 29, no. 7, pp. 1370-1378, July 2021, doi:
10.1109/TVLSI.2021.3082208.</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>switched-capacitor circuit in signal detection circuit</title>
    <url>/2022/02/15/sc_sigdet/</url>
    <content><![CDATA[<p><img src="/2022/02/15/sc_sigdet/sc_sigdet.drawio.svg"
alt="sc_sigdet.drawio" /></p>
<p><strong>phase I</strong></p>
<p><span class="math display">\[\begin{align}
Q_a &amp;= (V_{a0} - 0.5*(V_{ip} + V_{im}))*C + (V_{a0} - V_{th})*C \\
Q_b &amp;= (V_{b0} - 0.5*(V_{ip} + V_{im}))*C + V_{b0}*C
\end{align}\]</span></p>
<p><strong>Phase II</strong></p>
<p><span class="math display">\[\begin{align}
Q_a &amp;= (V_{a} - V_{ip})*C + (V_{a} - V_{b})*0.5C \\
Q_b &amp;= (V_{b} - V_{im})*C + (V_{b} - V_{a})*0.5C
\end{align}\]</span></p>
<p><strong>With the law of charge conservation, we get</strong></p>
<p><span class="math display">\[\begin{equation}
V_a - V_b = (V_{a0} - V_{b0}) + 0.5*(V_{ip} - V_{im} - V_{th})
\end{equation}\]</span></p>
<p><strong>REF:</strong></p>
<p>D. A. Yokoyama-Martin et al., "A Multi-Standard Low Power 1.5-3.125
Gb/s Serial Transceiver in 90nm CMOS," IEEE Custom Integrated Circuits
Conference 2006, 2006, pp. 401-404, doi: 10.1109/CICC.2006.320970.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Scattering parameters</title>
    <url>/2023/09/29/scattering/</url>
    <content><![CDATA[<h2 id="rational-fit">Rational Fit</h2>
<h3 id="matlabrationalfit">Matlab/rationalfit</h3>
<p>To resolve the convergence problem of s-parameter in Spectre
simulator - <code>rationalfit</code> and write Verilog-A</p>
<p><img src="/2023/09/29/scattering/image-20220630224525565.png"
alt="image-20220630224525565" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">filename  = <span class="string">&#x27;touchstone/ISI.S4P&#x27;</span>;</span><br><span class="line">s4p = read(rfdata.data, filename);</span><br><span class="line">sdd_params = s2sdd(s2p.S_Parameters, <span class="number">2</span>);</span><br><span class="line">sdd21 = <span class="built_in">squeeze</span>(sdd_params(<span class="number">2</span>, <span class="number">1</span>, :));   <span class="comment">% s21</span></span><br><span class="line">freq = s4p.Freq;</span><br><span class="line"></span><br><span class="line"><span class="comment">% rational fitting</span></span><br><span class="line">weight = <span class="built_in">ones</span>(<span class="built_in">size</span>(sdd21));</span><br><span class="line">weight(<span class="built_in">floor</span>(<span class="keyword">end</span>*<span class="number">3</span>/<span class="number">4</span>):<span class="keyword">end</span>) = <span class="number">0.2</span>;</span><br><span class="line">weight(<span class="number">2</span>:<span class="number">10</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[hfit, errb] = rationalfit(freq, sdd21, <span class="string">&#x27;IterationLimit&#x27;</span>, [<span class="number">4</span>, <span class="number">16</span>], <span class="string">&#x27;Delayfactor&#x27;</span>, <span class="number">0.98</span>, ...</span><br><span class="line">    <span class="string">&#x27;Weight&#x27;</span>, weight, <span class="string">&#x27;Tolerance&#x27;</span>, <span class="number">-38</span>, <span class="string">&#x27;NPoles&#x27;</span>, <span class="number">32</span>);</span><br><span class="line">[sdd21_fit, ff] = freqresp(hfit, freq);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(freq/<span class="number">1e9</span>, db(sdd21), <span class="string">&#x27;b-&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(ff/<span class="number">1e9</span>, db(sdd21_fit), <span class="string">&#x27;r-&#x27;</span>); <span class="built_in">hold</span> off; grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sdd21&#x27;</span>, <span class="string">&#x27;sdd21\_fit&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Freq (GHz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;magnitude (dB)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ts = <span class="number">1e-12</span>;</span><br><span class="line">n = <span class="number">2</span>^<span class="number">18</span>;</span><br><span class="line">trise = <span class="number">4e-14</span>;</span><br><span class="line">[yout, tout] = stepresp(hfit, ts, n, trise);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(tout*<span class="number">1e12</span>, yout, <span class="string">&#x27;b-&#x27;</span>); grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ps)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;V&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Step Response&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% write verilog-A</span></span><br><span class="line">writeva(hfit, <span class="string">&#x27;channel_32poles.va&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="z0">Z0</h2>
<blockquote>
<p>Remember, S-parameters <strong>don't mean much</strong> unless you
know the value of the <strong>reference impedance </strong>(it's
frequently called Z0).</p>
</blockquote>
<p>simulator will read sp file's <strong>Z0</strong> parameter</p>
<p><img src="/2023/09/29/scattering/image-20220430214052538.png"
alt="image-20220430214052538" /></p>
<p><img src="/2023/09/29/scattering/image-20220430214136970.png"
alt="image-20220430214136970" /></p>
<p><img src="/2023/09/29/scattering/image-20220430214419283.png"
alt="image-20220430214419283" /></p>
<blockquote>
<p>The default <strong>Z0</strong> exported by EMX is
<strong>50</strong></p>
</blockquote>
<h2 id="reference">reference</h2>
<p><a
href="https://www.microwaves101.com/encyclopedias/s-parameters">microwaves101,
S-parameters
(https://www.microwaves101.com/encyclopedias/s-parameters)</a></p>
<p>Pupalaikis, P. (2020). <em>S-Parameters for Signal Integrity</em>.
Cambridge: Cambridge University Press. doi:10.1017/9781108784863</p>
<p>Coelho, C. P., Phillips, J. R., &amp; Silveira, L. M. (n.d.). Robust
rational function approximation algorithm for model generation.
Proceedings 1999 Design Automation Conference (Cat. No. 99CH36361).
doi:10.1109/dac.1999.781313</p>
<p>Cadence IEEE IMS 2023, Introducing the Spectre S-Parameter Quality
Checker and Rational Fit Model Generator [<a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009lplhEAA">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009lplhEAA</a>]</p>
<p>The Complex Art Of Handling S-Parameters: The importance of
extraction and fitting to circuit simulation involving S-parameters [<a
href="https://semiengineering.com/the-complex-art-of-handling-s-parameters/">https://semiengineering.com/the-complex-art-of-handling-s-parameters</a>]</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>Sign-Sign LMS Adaptation algorithm in FFE and DFE</title>
    <url>/2022/03/02/sign-sign-LMS/</url>
    <content><![CDATA[<h4 id="adaptive-equalizing-link-architecture">Adaptive equalizing link
architecture</h4>
<p><img src="/2022/03/02/sign-sign-LMS/image-20220302213259394.png"
alt="image-20220302213259394" /></p>
<p>dLev: desired signal level</p>
<p>y<sub>n</sub>: received signal at time n</p>
<p>er<sub>n</sub>: the error slicer sample, i.e. sign(dLev -
y<sub>n</sub>)</p>
<p>d<sub>n-k</sub>: the data slicer sample at time n-k</p>
<h4 id="least-mean-square-algorithm-lms">Least Mean Square Algorithm
(LMS)</h4>
<p>Loss function or cost function: <span
class="math display">\[\begin{align}
e_n^2 &amp;= (dLev - y_n)^2
\end{align}\]</span></p>
<p>Transmitter and channel response: <span
class="math display">\[\begin{align}
ytx_n &amp;= \sum_{0}^{k}\omega_n^k\ast dtx_{n-k} \\
y_n &amp;= f_{ch}(ytx_n)
\end{align}\]</span> <span class="math inline">\(ytx_n\)</span> is
output of transmitter at time n; <span
class="math inline">\(f_{ch}\)</span> is channel response, for
simplicity, scaling factor <span class="math inline">\(\alpha\)</span>,
(<span class="math inline">\(\alpha &gt; 0\)</span>) is enough.</p>
<p>Update function (i.e. Gradient descent): <span
class="math display">\[\begin{align}
\omega_{n+1}^k = \omega_{n}^k - \frac{\eta}{2}\ast\frac{\partial
e_n^2}{\partial \omega_{n}^k} \\
\omega_{n+1}^k = \omega_{n}^k + \eta \ast e_n \ast\frac{\partial
y_n}{\partial \omega_{n}^k}
\end{align}\]</span> <span class="math inline">\(\eta\)</span> is
learning rate or the rate of update, which is greater than zero.</p>
<h4 id="sign-sign-lms-sslms">Sign-Sign LMS (SSLMS)</h4>
<p><strong>Why Sign-Sign LMS</strong></p>
<p>$ (dLev - y_n)$ and <span class="math inline">\(\frac{\partial
y_n}{\partial \omega_{n}^k}\)</span> is hard to get in circuit, where
the actual analog value should be obtained.</p>
<p><img src="/2022/03/02/sign-sign-LMS/image-20220302231044136.png"
alt="image-20220302231044136" /></p>
<p>In <strong>SSLMS algorithm</strong>, only the polarities of samples
are used since it is easy to detect by simple comparators. Moreover,
recovered data by hard decision is employed instead of <span
class="math inline">\(y_n\)</span> for more simplicity.</p>
<p>The update function can be written as,</p>
<p><span class="math display">\[\begin{align}
\omega_{n+1}^k &amp;= \omega_{n}^k + \eta \ast Sign(e_n) \ast
Sign(\frac{\partial y_n}{\partial \omega_{n}^k}) \\
\omega_{n+1}^k &amp;= \omega_{n}^k + \eta \ast Sign(e_n) \ast \alpha
\ast Sign(\frac{\partial ytx_n}{\partial \omega_{n}^k}) \\
\omega_{n+1}^k &amp;= \omega_{n}^k + \eta \ast Sign(er_n) \ast
Sign(d_{n-k})
\end{align}\]</span></p>
<p>SSLMS algorithm useful for DFE adaptation.</p>
<h4 id="reference">Reference</h4>
<p>T11: Basics of Equalization Techniques: Channels, Equalization, and
Circuits, 2022 IEEE International Solid-State Circuits Conference</p>
<p>V. Stojanovic et al., "Autonomous dual-mode (PAM2/4) serial link
transceiver with adaptive equalization and data recovery," in IEEE
Journal of Solid-State Circuits, vol. 40, no. 4, pp. 1012-1026, April
2005, doi: 10.1109/JSSC.2004.842863.</p>
<p>Jinhyung Lee, Design of High-Speed Receiver for Video Interface with
Adaptive Equalization; Phd thesis, August 2019. <a
href="http://dcollection.snu.ac.kr/common/orgView/000000157003">thesis
link</a></p>
<p>Paulo S. R. Diniz, Adaptive Filtering: Algorithms and Practical
Implementation, 5th edition</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>signed and unsigned arithmetic in Verilog</title>
    <url>/2022/05/07/signed-verilog/</url>
    <content><![CDATA[<p>With <strong>implict sign extension</strong>, the implementation of
<strong>signed</strong> arithmetic is <strong>DIFFERENT</strong> from
that of <strong>unsigned</strong>. Otherwise, their implementations are
same.</p>
<p>The implementations manifest the RTL's behaviour correctly</p>
<h2 id="add-without-implicit-sign-extension">add without implicit sign
extension</h2>
<h3 id="unsigned">unsigned</h3>
<h4 id="rtl">rtl</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP (</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] data0</span><br><span class="line">	,<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] data1</span><br><span class="line">	,<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">assign</span> result = data0 + data1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/07/signed-verilog/image-20220507114215200.png"
alt="image-20220507114215200" /></p>
<h4 id="synthesized-netlist">synthesized netlist</h4>
<p><img src="/2022/05/07/signed-verilog/image-20220507114307439.png"
alt="image-20220507114307439" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Created by: Synopsys DC Ultra(TM) in wire load mode</span></span><br><span class="line"><span class="comment">// Version   : S-2021.06-SP5</span></span><br><span class="line"><span class="comment">// Date      : Sat May  7 11:43:27 2022</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TOP ( data0, data1, result );</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data0;</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data1;</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] result;</span><br><span class="line">  <span class="keyword">wire</span>   n4, n5, n6;</span><br><span class="line"></span><br><span class="line">  an02d0 U6 ( <span class="variable">.A1</span>(data0[<span class="number">0</span>]), <span class="variable">.A2</span>(data1[<span class="number">0</span>]), <span class="variable">.Z</span>(n5) );</span><br><span class="line">  nr02d0 U7 ( <span class="variable">.A1</span>(data0[<span class="number">0</span>]), <span class="variable">.A2</span>(data1[<span class="number">0</span>]), <span class="variable">.ZN</span>(n4) );</span><br><span class="line">  nr02d0 U8 ( <span class="variable">.A1</span>(n5), <span class="variable">.A2</span>(n4), <span class="variable">.ZN</span>(result[<span class="number">0</span>]) );</span><br><span class="line">  ad01d0 U9 ( <span class="variable">.A</span>(data1[<span class="number">1</span>]), <span class="variable">.B</span>(data0[<span class="number">1</span>]), <span class="variable">.CI</span>(n5), <span class="variable">.CO</span>(n6), <span class="variable">.S</span>(result[<span class="number">1</span>]) );</span><br><span class="line">  xr03d1 U10 ( <span class="variable">.A1</span>(n6), <span class="variable">.A2</span>(data0[<span class="number">2</span>]), <span class="variable">.A3</span>(data1[<span class="number">2</span>]), <span class="variable">.Z</span>(result[<span class="number">2</span>]) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>vcs compile with <code>-v /path/to/lib.v</code></p>
</blockquote>
<h3 id="signed">signed</h3>
<h4 id="rtl-1">rtl</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP (</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">2</span>:<span class="number">0</span>] data0</span><br><span class="line">	,<span class="keyword">input</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">2</span>:<span class="number">0</span>] data1</span><br><span class="line">	,<span class="keyword">output</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">2</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">assign</span> result = data0 + data1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/07/signed-verilog/image-20220507114654777.png"
alt="image-20220507114654777" /></p>
<h4 id="synthesized-netlist-1">synthesized netlist</h4>
<p><img src="/2022/05/07/signed-verilog/image-20220507114844111.png"
alt="image-20220507114844111" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Created by: Synopsys DC Ultra(TM) in wire load mode</span></span><br><span class="line"><span class="comment">// Version   : S-2021.06-SP5</span></span><br><span class="line"><span class="comment">// Date      : Sat May  7 11:48:54 2022</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TOP ( data0, data1, result );</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data0;</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data1;</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] result;</span><br><span class="line">  <span class="keyword">wire</span>   n4, n5, n6;</span><br><span class="line"></span><br><span class="line">  an02d0 U6 ( <span class="variable">.A1</span>(data0[<span class="number">0</span>]), <span class="variable">.A2</span>(data1[<span class="number">0</span>]), <span class="variable">.Z</span>(n5) );</span><br><span class="line">  nr02d0 U7 ( <span class="variable">.A1</span>(data0[<span class="number">0</span>]), <span class="variable">.A2</span>(data1[<span class="number">0</span>]), <span class="variable">.ZN</span>(n4) );</span><br><span class="line">  nr02d0 U8 ( <span class="variable">.A1</span>(n5), <span class="variable">.A2</span>(n4), <span class="variable">.ZN</span>(result[<span class="number">0</span>]) );</span><br><span class="line">  ad01d0 U9 ( <span class="variable">.A</span>(data1[<span class="number">1</span>]), <span class="variable">.B</span>(data0[<span class="number">1</span>]), <span class="variable">.CI</span>(n5), <span class="variable">.CO</span>(n6), <span class="variable">.S</span>(result[<span class="number">1</span>]) );</span><br><span class="line">  xr03d1 U10 ( <span class="variable">.A1</span>(n6), <span class="variable">.A2</span>(data0[<span class="number">2</span>]), <span class="variable">.A3</span>(data1[<span class="number">2</span>]), <span class="variable">.Z</span>(result[<span class="number">2</span>]) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="add-with-implicit-sign-extension">add WITH implicit sign
extension</h2>
<h3 id="unsigned-with-0-extension">unsigned with 0 extension</h3>
<h4 id="rtl-2">rtl</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] data0		<span class="comment">// 3 bit unsigned</span></span><br><span class="line">    ,<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] data1		<span class="comment">// 2 bit unsigned</span></span><br><span class="line">    ,<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] result	<span class="comment">// 3 bit unsigned</span></span><br><span class="line">);</span><br><span class="line">	<span class="keyword">assign</span> result = data0 + data1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/07/signed-verilog/image-20220507121521303.png"
alt="image-20220507121521303" /></p>
<h4 id="synthesized-netlist-2">synthesized netlist</h4>
<p><img src="/2022/05/07/signed-verilog/image-20220507121622001.png"
alt="image-20220507121622001" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Created by: Synopsys DC Ultra(TM) in wire load mode</span></span><br><span class="line"><span class="comment">// Version   : S-2021.06-SP5</span></span><br><span class="line"><span class="comment">// Date      : Sat May  7 12:15:58 2022</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TOP ( data0, data1, result );</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data0;</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] data1;</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] result;</span><br><span class="line">  <span class="keyword">wire</span>   n4, n5, n6;</span><br><span class="line"></span><br><span class="line">  an02d0 U6 ( <span class="variable">.A1</span>(data1[<span class="number">0</span>]), <span class="variable">.A2</span>(data0[<span class="number">0</span>]), <span class="variable">.Z</span>(n6) );</span><br><span class="line">  ad01d0 U7 ( <span class="variable">.A</span>(data1[<span class="number">1</span>]), <span class="variable">.B</span>(data0[<span class="number">1</span>]), <span class="variable">.CI</span>(n6), <span class="variable">.CO</span>(n4), <span class="variable">.S</span>(result[<span class="number">1</span>]) );</span><br><span class="line">  xr02d1 U8 ( <span class="variable">.A1</span>(data0[<span class="number">2</span>]), <span class="variable">.A2</span>(n4), <span class="variable">.Z</span>(result[<span class="number">2</span>]) );</span><br><span class="line">  nr02d0 U9 ( <span class="variable">.A1</span>(data1[<span class="number">0</span>]), <span class="variable">.A2</span>(data0[<span class="number">0</span>]), <span class="variable">.ZN</span>(n5) );</span><br><span class="line">  nr02d0 U10 ( <span class="variable">.A1</span>(n6), <span class="variable">.A2</span>(n5), <span class="variable">.ZN</span>(result[<span class="number">0</span>]) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="signed-with-implicit-sign-extension">signed with implicit sign
extension</h3>
<h4 id="rtl-3">rtl</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP (</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">2</span>:<span class="number">0</span>] data0</span><br><span class="line">	,<span class="keyword">input</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">1</span>:<span class="number">0</span>] data1</span><br><span class="line">	,<span class="keyword">output</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">2</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">assign</span> result = data0 + data1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/07/signed-verilog/image-20220507122053948.png"
alt="image-20220507122053948" /></p>
<h4 id="synthesized-netlist-3">synthesized netlist</h4>
<p><img src="/2022/05/07/signed-verilog/image-20220507122217830.png"
alt="image-20220507122217830" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Created by: Synopsys DC Ultra(TM) in wire load mode</span></span><br><span class="line"><span class="comment">// Version   : S-2021.06-SP5</span></span><br><span class="line"><span class="comment">// Date      : Sat May  7 12:21:51 2022</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TOP ( data0, data1, result );</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data0;</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] data1;</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] result;</span><br><span class="line">  <span class="keyword">wire</span>   n6, n7, n8, n9, n10;</span><br><span class="line"></span><br><span class="line">  nd02d0 U9 ( <span class="variable">.A1</span>(data1[<span class="number">0</span>]), <span class="variable">.A2</span>(data0[<span class="number">0</span>]), <span class="variable">.ZN</span>(n10) );</span><br><span class="line">  inv0d0 U10 ( <span class="variable">.I</span>(n10), <span class="variable">.ZN</span>(n9) );</span><br><span class="line">  nr02d0 U11 ( <span class="variable">.A1</span>(data0[<span class="number">1</span>]), <span class="variable">.A2</span>(data1[<span class="number">1</span>]), <span class="variable">.ZN</span>(n7) );</span><br><span class="line">  aor221d1 U12 ( <span class="variable">.B1</span>(n9), <span class="variable">.B2</span>(data1[<span class="number">1</span>]), <span class="variable">.C1</span>(n10), <span class="variable">.C2</span>(data0[<span class="number">1</span>]), <span class="variable">.A</span>(n7), <span class="variable">.Z</span>(</span><br><span class="line">        n6) );</span><br><span class="line">  xn02d1 U13 ( <span class="variable">.A1</span>(data0[<span class="number">2</span>]), <span class="variable">.A2</span>(n6), <span class="variable">.ZN</span>(result[<span class="number">2</span>]) );</span><br><span class="line">  ora21d1 U14 ( <span class="variable">.B1</span>(data1[<span class="number">0</span>]), <span class="variable">.B2</span>(data0[<span class="number">0</span>]), <span class="variable">.A</span>(n10), <span class="variable">.Z</span>(result[<span class="number">0</span>]) );</span><br><span class="line">  aor21d1 U15 ( <span class="variable">.B1</span>(data1[<span class="number">1</span>]), <span class="variable">.B2</span>(data0[<span class="number">1</span>]), <span class="variable">.A</span>(n7), <span class="variable">.Z</span>(n8) );</span><br><span class="line">  mx02d0 U16 ( <span class="variable">.I0</span>(n10), <span class="variable">.I1</span>(n9), <span class="variable">.S</span>(n8), <span class="variable">.Z</span>(result[<span class="number">1</span>]) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>DSPF Options</title>
    <url>/2023/04/22/spectre-case/</url>
    <content><![CDATA[<h3 id="case-sensitivity">Case Sensitivity</h3>
<table>
<thead>
<tr class="header">
<th><strong>netlist format</strong></th>
<th><strong>default option</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Spectre netlist</td>
<td><em>case sensitive</em></td>
</tr>
<tr class="even">
<td>dspf format</td>
<td><em>case insensitive</em></td>
</tr>
</tbody>
</table>
<blockquote>
<p>For a <strong>dspf format</strong>, it will be treated as a <em>spice
netlist format</em>, which is <em>by default case insensitive</em></p>
</blockquote>
<p>Pay attention to <em>VerilogIn</em> block, which may contain upper
case / lower case net name, e.g NET1 and net1.</p>
<p>The extracted DSPF using extraction tool also contain NET1 and net1,
which <strong>shall not</strong> be shorted together.</p>
<p><img src="/2023/04/22/spectre-case/image-20230422225227022.png"
alt="image-20230422225227022" /></p>
<h3 id="port-order">Port Order</h3>
<blockquote>
<p>If you use <code>.dspf_include</code>, the following rules apply:</p>
<ul>
<li>The subcircuit description is taken from the DSPF file even if the
same subcircuit description is available in the schematic netlist.</li>
<li>Depending on the <code>port_order</code> option, the port order of
the subcircuit definition is taken from the pre-layout schematic netlist
or from the DSPF file subcircuit definition, as shown below.
<ul>
<li><code>port_order=sch</code> – (Default). The port order is taken
from schematic subcircuit definition. The same port number and names are
required. If the schematic subcircuit definition is not available, a
warning is issued in the log file, and DSPF port order is used.</li>
<li><code>port_order=spf</code> – The port order is taken from the DSPF
subcircuit definition.</li>
</ul></li>
</ul>
</blockquote>
<p><strong>SPICE_SUBCKT_FILE</strong> of StarRC</p>
<p>The StarRC tool reads the files specified by the
<em>SPICE_SUBCKT_FILE</em> command to obtain <strong>port ordering
information</strong>. The files control the port ordering of the top
cell as well. The port order and the port list members read from the
<strong>.subckt</strong> for a skip cell are preserved in the output
netlist.</p>
<blockquote>
<p>The file usually is the <em>cdl netlist</em> of extracted cell, this
way, port order is not problem</p>
</blockquote>
<p><strong>CDF termOrder</strong></p>
<p><img src="/2023/04/22/spectre-case/image-20230423005204734.png"
alt="image-20230423005204734" /></p>
<h4 id="dspf-same-order">DSPF same order</h4>
<p><strong>DSPF</strong></p>
<p><img src="/2023/04/22/spectre-case/image-20230423005700599.png"
alt="image-20230423005700599" /></p>
<p><strong>input.scs</strong></p>
<p><img src="/2023/04/22/spectre-case/image-20230423005754571.png"
alt="image-20230423005754571" /></p>
<p><img src="/2023/04/22/spectre-case/image-20230423010050512.png"
alt="image-20230423010050512" /></p>
<h4 id="different-order">different order</h4>
<p>manual change DSPF's pin order shown as below</p>
<p><img src="/2023/04/22/spectre-case/image-20230423010229253.png"
alt="image-20230423010229253" /></p>
<h4 id="port_ordersch">port_order=sch</h4>
<p><em>dspf port is mapping to schematic by name</em>, and the
simulation result is right</p>
<p><img src="/2023/04/22/spectre-case/image-20230423011926424.png"
alt="image-20230423011926424" /></p>
<h5 id="port_orderspf">port_order=spf</h5>
<p>dspf pin order is retained, and <strong>no mapping</strong> between
spectre netlist and dspf.</p>
<p>The simulation result is wrong</p>
<p><img src="/2023/04/22/spectre-case/image-20230423012443314.png"
alt="image-20230423012443314" /></p>
<blockquote>
<p>bus_delim="_ &lt;&gt;"</p>
<p>The way this works is that the first part of <em>bus_delim</em> is
the "schematic" delimiter (i.e. what's in the spectre netlist), and the
other part is the DSPF delimiter</p>
</blockquote>
<h3 id="reference">reference</h3>
<p>Article (20502176) Title: How does Spectre understand case-sensitive
net names when using various post-layout netlists such as dspf,
av_extracted view, or smart view? URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009fthoEAA">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009fthoEAA</a></p>
<p>spf in cadence <a
href="https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/31326/spf-in-cadence/1342278#1342278">https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/31326/spf-in-cadence/1342278#1342278</a></p>
<p>Spectre Tech Tips: Using DSPF Post-Layout Netlists in Spectre Circuit
Simulator - Analog/Custom Design - Cadence Blogs - Cadence Community <a
href="https://shar.es/afO6e1">https://shar.es/afO6e1</a></p>
<p>StarRC™ User Guide and Command Reference Version O-2018.06, June
2018</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>Single-Pole Filter and Complex Conjugate Pole pair in Event-Driven PWL model</title>
    <url>/2022/03/09/spf-complex-pwl/</url>
    <content><![CDATA[<p><strong>Real number modeling</strong> of analog circuits in hardware
description languages (HDLs) has become more common as a part of
mixed-signal SoC validation. <strong>Piecewise linear (PWL)</strong>
waveform approximation represent analog signals and <strong>dynamically
schedule the events</strong> for approximating the signal waveform to
PWL segments with a well controlled error bound.</p>
<p><img src="/2022/03/09/spf-complex-pwl/image-20220310000010013.png"
alt="image-20220310000010013" /></p>
<p>Definition of a piecewise liner (PWL) waveform using struct in
Systemverilog</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">real</span> y; <span class="comment">// signal offset</span></span><br><span class="line">    <span class="keyword">real</span> slope; <span class="comment">// signal slope</span></span><br><span class="line">    <span class="keyword">real</span> t0;	<span class="comment">// time offset</span></span><br><span class="line">&#125; pwl; <span class="comment">// pwl datatype</span></span><br></pre></td></tr></table></figure>
<h4 id="when-to-update-piecewise-model">When to update piecewise
model</h4>
<ol type="1">
<li>model parameter update once new input come in</li>
<li>error is greater than user-define tolerance <span
class="math inline">\(e_{tol}\)</span>, trigger by <span
class="math inline">\(\Delta T\)</span></li>
</ol>
<p><img src="/2022/03/09/spf-complex-pwl/tolerance_error.drawio.svg"
alt="tolerance_error.drawio" /></p>
<h4 id="dynamic-time-step-control">Dynamic Time Step Control</h4>
<p>When approximating a function <span
class="math inline">\(y(t)\)</span> to a <strong>piecewise linear
segment</strong> for the interval <span class="math inline">\(t_0 \le
t_0 + \Delta t\)</span>, the approximation error <span
class="math inline">\(err\)</span> is bounded by <span
class="math display">\[
\left| err \right| \le \frac{1}{8}\cdot \Delta t^2 \cdot \max(\left|
\ddot{y(t)} \right|)
\]</span> Using Rolle's theorem for the interval <span
class="math inline">\(t_0 \le t_0 + \Delta t\)</span>, the needed time
step <span class="math inline">\(\Delta t\)</span> is givend by <span
class="math display">\[
\Delta t(t=t_0) = \sqrt{\frac{8\cdot e_{tol}}{\max(\left| \ddot{y(t)}
\right|)}}
\]</span></p>
<h4 id="single-pole-filter-model">Single-Pole Filter Model</h4>
<p>The <strong>ramp</strong> input <span
class="math inline">\(X(s)\)</span>, the single pole system Laplace
s-domain <span class="math inline">\(H(s)\)</span> and the output
response <span class="math inline">\(Y(s)\)</span>, <span
class="math display">\[\begin{align}
X(s) &amp;= \frac{a}{s} +\frac{b}{s^2} \\
H(s) &amp;= \frac{Y(s)}{X(s)} = \frac{1}{1+\frac{s}{\omega_{1}}} \\
Y(s) &amp;= X(s) \cdot H(s)
\end{align}\]</span></p>
<p>Time domain of ramp input shown as below <span
class="math display">\[
x(t) = a +b \cdot t
\]</span></p>
<ol type="1">
<li>The output transfer function <span
class="math display">\[\begin{align}
Y(s) &amp;= X(s) \cdot H(s) \\
&amp;= \frac{\omega_1}{\omega_1+s}\cdot X
\end{align}\]</span> <span class="math display">\[
Y\omega_1 + sY = \omega_1 X
\]</span></li>
<li>its differential equation <span class="math display">\[
y(t) \cdot \omega_1+\frac{d y(t)}{dt} = \omega_1 \cdot x(t)
\]</span></li>
<li>Laplace transfrom two side of the above equation, <span
class="math inline">\(y_0\)</span> is initial conditon of output, <span
class="math inline">\(x_0=0\)</span> <span class="math display">\[
Y\omega_1 + sY-y_0 = \omega_1 \cdot X
\]</span> Solving <span class="math inline">\(Y(s)\)</span> <span
class="math display">\[\begin{align}
Y &amp;= \frac{y_0}{\omega_1+s}+\frac{\omega_1}{\omega_1+s}\cdot X \\
&amp;= \frac{y_0}{\omega_1+s}+\frac{\omega_1}{\omega_1+s}\cdot
(\frac{a}{s}+\frac{b}{s^2}) \\
&amp;= \frac{y_0}{\omega_1+s}+\frac{\omega_1}{\omega_1+s}\cdot
\frac{a}{s}+\frac{\omega_1}{\omega_1+s}\cdot\frac{b}{s^2}
\end{align}\]</span></li>
<li>inverse Laplace transform <span class="math display">\[
y(t) = y_0e^{-\omega_1t}+(a-a\cdot e^{-\omega_1t})+(b\cdot
t-\frac{b}{\omega_1}+\frac{b}{\omega_1}\cdot e^{-\omega_1 t})
\]</span></li>
</ol>
<blockquote>
<p>step-1 transfer function in Laplace s-domain, which
<strong>don't</strong> initial conditon and is only steady response.</p>
<p>step-2 differential equation</p>
<p>step-3 Laplace transform of <span
class="math inline">\(Y(s)\)</span>, (the initial conditon of input
<span class="math inline">\(X(s)\)</span> is zero, that of <span
class="math inline">\(Y(s)\)</span> is explicit)</p>
<p>step-4 inverse Laplace transform, with the help of Laplace transform
table or matlab <code>syms</code> and <code>ilaplace</code> function</p>
</blockquote>
<p><span class="math inline">\(y(t)\)</span> has a continuous second
derivative <span class="math inline">\(\ddot{y(t)}\)</span> <span
class="math display">\[
\ddot{y(t)} =(-a+\frac{b}{\omega_1}+y_0)\cdot \omega_1^2\cdot
e^{-\omega_1t}
\]</span> It's obvious <span class="math inline">\(\left| \ddot{y(t)}
\right|\)</span> is a decaying function and thus the maximum value is
<span class="math inline">\(\left| \ddot{y(t_0)} \right|\)</span> for
the interval <span class="math inline">\(t_0 \le t_0 + \Delta
t\)</span>. The time step <span class="math inline">\(\Delta t\)</span>
for the error tolerance <span class="math inline">\(e_{tol}\)</span>:
<span class="math display">\[
\Delta t(t=t_0) = \sqrt{\frac{8\cdot e_{tol}}{\left| \ddot{y(t_0)}
\right|}}
\]</span></p>
<h4 id="complex-conjugate-pole-pair">Complex Conjugate Pole pair</h4>
<p><span class="math display">\[
H(s) = \frac{r}{s+\omega_p} + \frac{r^*}{s+\omega_p^*}
\]</span></p>
<p>where <span class="math inline">\(\omega_p\)</span> and <span
class="math inline">\(r\)</span> are complex numbers, <span
class="math inline">\(r=r_r+jr_i\)</span>, <span
class="math inline">\(\omega_p=\omega_{pr}+j\omega_{pi}\)</span></p>
<p>Follow the procedure as above single pole <span
class="math display">\[
\frac{Y(s)}{X(s)} = \frac{s\cdot r_{cs}+e}{s^2+s\cdot \omega_{p\_cs}+f}
\]</span> where <span class="math inline">\(r_{cs}=r+r^*\)</span>, <span
class="math inline">\(\omega_{p\_cs}=\omega_p+\omega_p^*\)</span> and
<span class="math inline">\(e=r\omega_p^*+r^*\omega_p\)</span>, <span
class="math inline">\(f=\omega_p\omega_p^*\)</span> implies <span
class="math display">\[
s^2Y(s)+s\omega_{p\_cs}Y(s)+fY(s)=(s\cdot r_{cs}+e)X(s)
\]</span> or a differential equation <span class="math display">\[
\frac{d^2y(t)}{dt^2}+\omega_{p\_cs}\frac{dy(t)}{dt}+fy(t)=r_{cs}\frac{dx(t)}{dt}+e\cdot
x(t)
\]</span> Taking Laplace transform with initial conditions <span
class="math inline">\(y_0\)</span>, <span
class="math inline">\(\dot{y_0}\)</span> and <span
class="math inline">\(x_0=0\)</span>, <span class="math display">\[
s^2-sy_0-\dot{y_0}+\omega_{p\_cs}(sY(s)-y_0)+f\cdot y(t) = r_{cs}\cdot
(sX(s)-0)+e\cdot X(s)
\]</span> Solving for <span class="math inline">\(Y(s)\)</span> <span
class="math display">\[
Y(s)=\frac{s\cdot
y_0+\dot{y_0}+\omega_{p\_cs}y_0}{s^2+s\cdot{\omega_{p\_cs}}+f}+\frac{s\cdot{r_{cs}}+e}{s^2+s\cdot{\omega_{p\_cs}}+f}X(s)
\]</span> With an ramp input, height <span
class="math inline">\(a\)</span>, slope <span
class="math inline">\(b\)</span>, i.e. <span
class="math inline">\(X(s)=\frac{a}{s}+\frac{b}{s^2}\)</span> <span
class="math display">\[
Y(s)=\frac{s\cdot
y_0+\dot{y_0}+\omega_{p\_cs}y_0}{s^2+s\cdot{\omega_{p\_cs}}+f}+\frac{s\cdot{r_{cs}}+e}{s^2+s\cdot{\omega_{p\_cs}}+f}(\frac{a}{s}+\frac{b}{s^2})
\]</span> After inverse Laplace transform, we can get total response
<span class="math display">\[
y(t)=e^{-\omega_{pr}t}\cdot \left[ y_0\cdot
\cos(\omega_{pi}t)+\frac{\dot{y_0}+y_0\omega_{pr}}{\omega_{pi}}\sin(\omega_{pi}t)+D\cdot
\cos(\omega_{pi}t)+\frac{C-D\cdot{\omega_{pr}}}{\omega_{pi}}\sin(\omega_{pi}t)
\right]+B+A\cdot{t}
\]</span> where <span class="math display">\[\begin{align}
A &amp;= \frac{e\cdot{b}}{f} \\
B &amp;= \frac{r_{cs}\cdot{b}+a\cdot{e}-A\cdot{\omega_{p\_{cs}}}}{f} \\
C &amp;= a\cdot{r_{cs}}-A-B\cdot{\omega_{p\_cs}} \\
D &amp;= -B
\end{align}\]</span></p>
<p>As a double check, note that at <span
class="math inline">\(t=0\)</span>, <span class="math display">\[
y(0)=\left[ y_0 + D \right]+B=y_0
\]</span></p>
<p>To derive derivative, we first assume <span class="math display">\[
y_0\cdot
\cos(\omega_{pi}t)+\frac{\dot{y_0}+y_0\omega_{pr}}{\omega_{pi}}\sin(\omega_{pi}t)+D\cdot
\cos(\omega_{pi}t)+\frac{C-D\cdot{\omega_{pr}}}{\omega_{pi}}\sin(\omega_{pi}t)
= \alpha \cdot{\cos(\omega_{pi}t+\phi)}
\]</span> The above equation implies <span
class="math display">\[\begin{align}
y_0+D &amp;= \alpha\cdot{\cos(\phi)} \\
\frac{\dot{y_0}+y_0\omega_{pr}}{\omega_{pi}}+\frac{C-D\cdot{\omega_{pr}}}{\omega_{pi}}
&amp;= -\alpha\cdot{\sin(\phi)}
\end{align}\]</span> Then <span class="math display">\[
\alpha^2=(y_0+D)^2+\left(\frac{\dot{y_0}+y_0\omega_{pr}}{\omega_{pi}}+\frac{C-D\cdot{\omega_{pr}}}{\omega_{pi}}
\right)^2
\]</span> And <span class="math inline">\(\alpha\)</span> can be used to
estimate time step size. The total response is <span
class="math display">\[
y(t)=e^{-\omega_{pr}t}\cdot \alpha
\cdot{\cos(\omega_{pi}t+\phi)}+B+A\cdot{t}
\]</span> It's second derivative is <span class="math display">\[
\ddot{y(t)} = \alpha\left[
(\omega_{pr}^2-\omega_{pi}^2)e^{-\omega_{pr}t}\cos(\omega_{pi}t+\phi)+2\cdot
\omega_{pr}\omega_{pi}e^{-\omega_{pr}t}\sin(\omega_{pi}t+\phi) \right]
\]</span> Absolute value <span class="math display">\[
\left| \ddot{y(t)} \right| = \left| \alpha \right| \left|
(\omega_{pr}^2-\omega_{pi}^2)e^{-\omega_{pr}t}\cos(\omega_{pi}t+\phi)+2\cdot
\omega_{pr}\omega_{pi}e^{-\omega_{pr}t}\sin(\omega_{pi}t+\phi) \right|
\]</span> Define new function <span
class="math inline">\(g_0(t)\)</span> <span class="math display">\[
g_0(t) = \left| \alpha \right| \left|
(\omega_{pr}^2-\omega_{pi}^2)e^{-\omega_{pr}t}\cos(\omega_{pi}t+\phi)
\right|+2\cdot |\alpha| \left|
\omega_{pr}\omega_{pi}e^{-\omega_{pr}t}\sin(\omega_{pi}t+\phi) \right|
\]</span> another new funtion <span
class="math inline">\(g_1(t)\)</span>, by equating <span
class="math inline">\(\sin(\omega_{pi}t+\phi)\)</span> and <span
class="math inline">\(\cos(\omega_{pi}t+\phi)\)</span> to one <span
class="math display">\[
g_1(t) = \left| \alpha \right| \left|
(\omega_{pr}^2-\omega_{pi}^2)e^{-\omega_{pr}t} \right|+2\cdot |\alpha|
\left| \omega_{pr}\omega_{pi}e^{-\omega_{pr}t} \right|
\]</span></p>
<p>By triangular inequality, <span class="math inline">\(g_0(t)\)</span>
is the upper bound of <span class="math inline">\(\left| \ddot{y(t)}
\right|\)</span>, and <span class="math inline">\(g_1(t)\)</span> is the
upper bound of <span class="math inline">\(g_0(t)\)</span></p>
<p>Because <span class="math inline">\(g_1(t)\)</span> is a decaying
exponential function, Therefore, a conservative time step can be
obtained, for inteval <span class="math inline">\(t_0 \le t_0 + \Delta
t\)</span>, <span class="math display">\[
\Delta t(t=t_0) = \sqrt{\frac{8\cdot e_{tol}}{\left| g_1(t_0) \right|}}
\]</span></p>
<h4 id="one-fixed-time-step-systemverilog-model-example">One Fixed-time
step SystemVerilog model example</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line"><span class="keyword">timeprecision</span> <span class="number">1</span>fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> #<span class="number">0</span><span class="variable">.1</span> <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    Ir4 = (Vm - Vout) / R4;</span><br><span class="line">    Ir3 = (Vcp - Vm) / R3;</span><br><span class="line">    Ir2 = (Vcp - Vz) / R2;</span><br><span class="line"></span><br><span class="line">    Vout = Vout + Ir4 * <span class="number">0</span><span class="variable">.1</span> * (<span class="number">1</span>e-<span class="number">9</span>) / C4;</span><br><span class="line">    Vm = Vm + (Ir3 - Ir4) * <span class="number">0</span><span class="variable">.1</span> * (<span class="number">1</span>e-<span class="number">9</span>) / C3;</span><br><span class="line">    Vz = Vz + Ir2 * <span class="number">0</span><span class="variable">.1</span> * (<span class="number">1</span>e-<span class="number">9</span>) / C2;</span><br><span class="line">    Vcp = Vcp + (Icp - Ir2 - Ir3) * <span class="number">0</span><span class="variable">.1</span> * (<span class="number">1</span>e-<span class="number">9</span>) / C1;</span><br><span class="line">    last_time = <span class="built_in">$realtime</span>;</span><br><span class="line">    #<span class="number">0</span><span class="variable">.1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="acknowledgement">Acknowledgement</h4>
<p>My colleague, Zhang Wenpian help me a lot in understanding this
modeling method. Lots of content here are copied from Zhang's note.</p>
<h4 id="reference">Reference</h4>
<p>B. C. Lim and M. Horowitz, "Error Control and Limit Cycle Elimination
in Event-Driven Piecewise Linear Analog Functional Models," in IEEE
Transactions on Circuits and Systems I: Regular Papers, vol. 63, no. 1,
pp. 23-33, Jan. 2016, doi: 10.1109/TCSI.2015.2512699.</p>
<p>S. Liao and M. Horowitz, "A Verilog piecewise-linear analog behavior
model for mixed-signal validation," Proceedings of the IEEE 2013 Custom
Integrated Circuits Conference, 2013, pp. 1-5, doi:
10.1109/CICC.2013.6658461.</p>
<p><a href="https://github.com/StanfordVLSI/DaVE">StanfordVLSI/DaVE -
tools regarding on analog modeling,validation, and generation</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>maximum oscillation frequency of multi-paths ring oscillator</title>
    <url>/2022/03/20/spro-mpro/</url>
    <content><![CDATA[<p>A conventional inverter-based ring oscillator consists of a single
loop of an <strong>odd</strong> number of inverters. While compact, easy
to design and tunable over a wide frequency range, this oscillator
suffers from several limitations.</p>
<ul>
<li>it is not possible to increase the number of phases while
maintaining the same oscillation frequency since the frequency is
inversely proportional to the number of inverters in the loop. In other
words, the time resolution of the oscillator is limited to one inverter
delay and cannot be improved below this limit.</li>
<li>the number of phases that can be obtained from this oscillator is
limited to <strong>odd</strong> values. Otherwise, if an even number of
inverters is used, the circuit remains in <em>a latched state</em> and
does not oscillate.</li>
</ul>
<p>To overcome the limitations of conventional ring oscillators,
multi-paths ring oscillator (MPRO) is proposed. Each phase can be driven
by two or more inverters, or <em>multi-paths</em> instead of having each
phase in oscillator driven by a single inverter, or <em>single
path</em>.</p>
<p>One thing that makes the MPRO design problem even more complicated is
its property of having <strong>multiple possible oscillation
modes</strong>. Without a clear understanding of what makes one of these
modes dominant, it is very likely that a designer might end-up having an
oscillator that can start-up each time in a different oscillation mode
depending on the <em>initial state of the oscillator</em>.</p>
<p><img src="/2022/03/20/spro-mpro/image-20220320155440541.png"
alt="image-20220320155440541" /></p>
<p>In practive, the oscillator starts first from a linear mode of
operation where all the buffers are indeed acting as linear
transconductors. All oscillation modes that have mode gains, <span
class="math inline">\(a_n\)</span>, lower than the actual dc gain of the
inverter, <span class="math inline">\(a_0\)</span>, start to grow.
<em>As the oscillation amplitude grows, the effective gain of the
inverter drops due to nonlinearity</em>. Consequently, modes with higher
mode gain die out and only the mode that requires the minimum gain
continues to oscillate and hence is the dominant mode.</p>
<blockquote>
<p>The dominant mode is dependent only on the relative sizing vector</p>
</blockquote>
<h4 id="maximum-oscillation-frequency">maximum oscillation
frequency</h4>
<p>The oscillation frequency of the dominant mode of any MPRO having any
arbitrary coupling structure and number of phases is <span
class="math display">\[
f_{n^*} = \frac {1}{2\pi}\frac {(a_0-1) \cdot \sum_{i=1}^{N}x_isin\left
( \frac {2\pi n^*(i-1)}{N} \right)}{(a_0\tau _p - \tau _o)\cdot
\sum_{i=1}^{N}-x_icos\left( \frac{2\pi n^*(i-1)}{N}+(\tau _o - \tau _p)
\right)}
\]</span> <img src="/2022/03/20/spro-mpro/image-20220320172952925.png"
alt="image-20220320172952925" /></p>
<p>A <strong>linear increase</strong> in the maximum possible normalized
oscillation frequency as the number of stages increases <em>provided
that the dc gain of the buffer sufficient to provide the required
amplification</em></p>
<p><img src="/2022/03/20/spro-mpro/image-20220320170324494.png"
alt="image-20220320170324494" /></p>
<p><img src="/2022/03/20/spro-mpro/image-20220320170523390.png"
alt="image-20220320170523390" /></p>
<blockquote>
<p>assuming unlimited dc gain and zero mode gain margins</p>
</blockquote>
<h4 id="mode-stability">mode stability</h4>
<p>A common problem in MPRO design is the stability of the dominant
oscillation mode. Mode stability refers to whether the MPRO always
oscillates at the same mode regardless of the initial conditions of the
oscillator. This problem is especially pronounced for MPROs with a large
number of phases. This is due to the existence of many modes and the
very small differences in the value of the mode gain of adjacent modes
if the MPRO is not well designed.</p>
<blockquote>
<p>In general, when the mode gain difference between two modes is small,
the oscillator can operate in either one depending on initial
conditions.</p>
</blockquote>
<h4 id="coupling-configurations-and-simulation-results">coupling
configurations and simulation results</h4>
<p><img src="/2022/03/20/spro-mpro/image-20220320165217231.png"
alt="image-20220320165217231" /></p>
<h4 id="reference">reference</h4>
<p>Abou-El-Sonoun, A. A. (2012). High Frequency Multiphase Clock
Generation Using Multipath Oscillators and Applications. <em>UCLA</em>.
ProQuest ID: AbouElSonoun_ucla_0031D_10684. Merritt ID:
ark:/13030/m57p9288. Retrieved from
https://escholarship.org/uc/item/75g8j8jt</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>How to squash all git commits into one?</title>
    <url>/2023/08/10/squash-all-commits/</url>
    <content><![CDATA[<p><a
href="https://stackoverflow.com/a/9254257/8037585">https://stackoverflow.com/a/9254257/8037585</a></p>
<p>As of <a
href="https://github.com/git/git/blob/master/Documentation/RelNotes/1.6.2.txt#L118">git
1.6.2</a>, you can use <code>git rebase --root -i</code></p>
<p>For each commit except the first, change <code>pick</code> to
<code>squash</code>.</p>
<p>this works find, but I had to do a forced push. be careful!
<code>git push -f</code></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Signal and System insight</title>
    <url>/2024/05/02/ss-insight/</url>
    <content><![CDATA[<h2 id="nrz-bandwidth">NRZ Bandwidth</h2>
<p><img src="/2024/05/02/ss-insight/image-20240607221359970.png"
alt="image-20240607221359970" /></p>
<blockquote>
<p>Maxim Integrated,NRZ Bandwidth - HF Cutoff vs. SNR [<a
href="https://pdfserv.maximintegrated.com/en/an/AN870.pdf">https://pdfserv.maximintegrated.com/en/an/AN870.pdf</a>]</p>
</blockquote>
<h2 id="t_r"><span class="math inline">\(0.35/T_r\)</span></h2>
<p><img src="/2024/05/02/ss-insight/image-20240607222440796.png"
alt="image-20240607222440796" /></p>
<h2 id="system-type">System Type</h2>
<blockquote>
<p>Control of Steady-State Error to Polynomial Inputs: System Type</p>
</blockquote>
<p><img src="/2024/05/02/ss-insight/image-20240502232125317.png"
alt="image-20240502232125317" /></p>
<p>control systems are assigned a <strong>type</strong> number according
to the maximum degree of the input polynominal for which the
steady-state error is a <em>finite constant</em>. i.e.</p>
<blockquote>
<ul>
<li>Type 0: Finite error to a step (position error)</li>
<li>Type 1: Finite error to a ramp (velocity error)</li>
<li>Type 2: Finite error to a parabola (acceleration error)</li>
</ul>
</blockquote>
<p>The open-loop transfer function can be expressed as <span
class="math display">\[
T(s) = \frac{K_n(s)}{s^n}
\]</span></p>
<p>where we collect all the terms except the pole (<span
class="math inline">\(s\)</span>) at eh origin into <span
class="math inline">\(K_n(s)\)</span>,</p>
<p>The polynomial inputs, <span
class="math inline">\(r(t)=\frac{t^k}{k!} u(t)\)</span>, whose transform
is <span class="math display">\[
R(s) = \frac{1}{s^{k+1}}
\]</span></p>
<p>Then the equaion for the error is simply <span
class="math display">\[
E(s) = \frac{1}{1+T(s)}R(s)
\]</span></p>
<p>Apllication of the <em>Final Value Theorem</em> to the error formula
gives the result</p>
<p><span class="math display">\[\begin{align}
\lim _{t\to \infty} e(t) &amp;= e_{ss} = \lim _{s\to 0} sE(s) \\
&amp;= \lim _{s\to 0} s\frac{1}{1+\frac{K_n(s)}{s^n}}\frac{1}{s^{k+1}}
\\
&amp;= \lim _{s\to 0} \frac{s^n}{s^n + K_n(0)}\frac{1}{s^k}
\end{align}\]</span></p>
<ul>
<li>if <span class="math inline">\(n &gt; k\)</span>, <span
class="math inline">\(e=0\)</span></li>
<li>if <span class="math inline">\(n &lt; k\)</span>, <span
class="math inline">\(e\to \infty\)</span></li>
<li>if <span class="math inline">\(n=k\)</span>
<ul>
<li><span class="math inline">\(e_{ss} = \frac{1}{1+K_0}\)</span> if
<span class="math inline">\(n=k=0\)</span></li>
<li><span class="math inline">\(e_{ss} = \frac{1}{K_n}\)</span> if <span
class="math inline">\(n=k \neq 0\)</span></li>
</ul></li>
</ul>
<h2 id="pid">PID</h2>
<p><em>TODO</em> 📅</p>
<ul>
<li>a Proportional term to close the feedback loop</li>
<li>an Integral term to assure zero error to constant reference and
disturbance inputs</li>
<li>a Derivative term to improve (or realize!) stability and good
dynamic response</li>
</ul>
<h2 id="nyquist-criterion">Nyquist Criterion</h2>
<p><em>TODO</em> 📅</p>
<h2 id="group-delay">group delay</h2>
<p><em>TODO</em> 📅</p>
<h2 id="conversion-between-the-s--and-z-domains">Conversion Between the
<span class="math inline">\(s\)</span>- and <span
class="math inline">\(z\)</span>-Domains</h2>
<p><img src="/2024/05/02/ss-insight/image-20240429220303281.png"
alt="image-20240429220303281" /></p>
<p><img src="/2024/05/02/ss-insight/image-20240429215455332.png"
alt="image-20240429215455332" /></p>
<blockquote>
<p>Staszewski, Robert Bogdan, and Poras T. Balsara. All-digital
frequency synthesizer in deep-submicron CMOS. John Wiley &amp; Sons,
2006.</p>
</blockquote>
<h2 id="spectral-content-of-nrz">Spectral content of NRZ</h2>
<p><img src="/2024/05/02/ss-insight/image-20231111100420675.png"
alt="image-20231111100420675" /></p>
<p><img src="/2024/05/02/ss-insight/image-20231111101322771.png"
alt="image-20231111101322771" /></p>
<p><img src="/2024/05/02/ss-insight/image-20231110224237933.png"
alt="image-20231110224237933" /></p>
<blockquote>
<p>Lecture 26 Autocorrelation Functions of Random Binary Processes [<a
href="https://bpb-us-w2.wpmucdn.com/sites.gatech.edu/dist/a/578/files/2003/12/ECE3075A-26.pdf">https://bpb-us-w2.wpmucdn.com/sites.gatech.edu/dist/a/578/files/2003/12/ECE3075A-26.pdf</a>]</p>
<p>Lecture 32 Correlation Functions &amp; Power Density Spectrum,
Cross-spectral Density [<a
href="https://bpb-us-w2.wpmucdn.com/sites.gatech.edu/dist/a/578/files/2003/12/ECE3075A-32.pdf">https://bpb-us-w2.wpmucdn.com/sites.gatech.edu/dist/a/578/files/2003/12/ECE3075A-32.pdf</a>]</p>
</blockquote>
<h2 id="sinusoidal-steady-state-and-frequency-response">sinusoidal
steady-state and frequency response</h2>
<p><img src="/2024/05/02/ss-insight/image-20231104104933781.png"
alt="image-20231104104933781" /></p>
<p><img src="/2024/05/02/ss-insight/image-20231104104946203.png"
alt="image-20231104104946203" /></p>
<p><img src="/2024/05/02/ss-insight/image-20231104105056345.png"
alt="image-20231104105056345" /></p>
<p><img src="/2024/05/02/ss-insight/image-20231104105139814.png"
alt="image-20231104105139814" /></p>
<p><img src="/2024/05/02/ss-insight/image-20231104105223549.png"
alt="image-20231104105223549" /></p>
<p>Due to KCL and <span class="math inline">\(u(t)=e^{j\omega
t}\)</span> and <span class="math inline">\(y(t)=H(j\omega)e^{j\omega
t}\)</span>, we have ODE:</p>
<p><span class="math display">\[\begin{align}
\frac{u(t) - y(t)}{R} = C \frac{dy(t)}{dt} \\
e^{j\omega t} - H(j\omega) e^{j\omega t} = H(j\omega)\cdot j\omega
e^{j\omega t} \\
\end{align}\]</span></p>
<p><span class="math inline">\(H(j\omega)\)</span> is obtained as below
<span class="math display">\[
H(j\omega) = \frac{1}{1+j\omega}
\]</span></p>
<p><img src="/2024/05/02/ss-insight/image-20231104135855739.png"
alt="image-20231104135855739" /></p>
<h2 id="initial-value-theorem-final-value-theorem">Initial Value Theorem
&amp; Final Value Theorem</h2>
<p>Two valuable <em>Laplace transform</em> theorem</p>
<ul>
<li><p>Initial Value Theorem, which states that it is always possible to
determine the <strong>initial value</strong> of the time function <span
class="math inline">\(f(t)\)</span> from its Laplace transform <span
class="math display">\[
\lim _{s\to \infty}sF(s) = f(0^+)
\]</span></p></li>
<li><p>Final Value Theorem allows us to compute the <strong>constant
steady-state value</strong> of a time function given its Laplace
transform <span class="math display">\[
\lim _{s\to 0}sF(s) = f(\infty)
\]</span></p>
<blockquote>
<p>If <span class="math inline">\(f(t)\)</span> is step response, then
<span class="math inline">\(f(0^+) = H(\infty)\)</span> and <span
class="math inline">\(f(\infty) = H(0)\)</span>, where <span
class="math inline">\(H(s)\)</span> is transfer function</p>
</blockquote></li>
</ul>
<h2 id="butterworth-filter">Butterworth filter</h2>
<blockquote>
<p>function varargout = butter(n, Wn, varargin)</p>
<p>% BUTTER Butterworth digital and analog filter design.</p>
<p>% [B,A] = BUTTER(N,Wn) designs an Nth order lowpass digital</p>
<p>% Butterworth filter and returns the filter coefficients in
length</p>
<p>% N+1 vectors B (numerator) and A (denominator). The coefficients</p>
<p>% are listed in descending powers of z. The cutoff frequency</p>
<p>% Wn must be <strong>0.0 &lt; Wn &lt; 1.0</strong>, with 1.0
corresponding to</p>
<p>% half the sample rate.</p>
</blockquote>
<p><span class="math display">\[
w_n = \frac{f_c}{0.5f_s}
\]</span></p>
<p>where <span class="math inline">\(f_c\)</span> is cutoff frequency,
<span class="math inline">\(f_s\)</span> is sampling frequency</p>
<p><span class="math display">\[
\Phi = \omega T_s \text { ,}\Phi \in [0,2\pi]
\]</span></p>
<p>Find the relationship between <span
class="math inline">\(\omega_n\)</span> and </p>
<p><span class="math display">\[\begin{align}
\Phi &amp;= 2\pi f_c \frac{1}{f_s}  \\
&amp;=\pi \frac{f_c}{0.5f_s} \\
&amp;= \pi \omega _n
\end{align}\]</span></p>
<p>Given <span class="math inline">\(f_c\)</span> is 300 Hz and <span
class="math inline">\(f_s\)</span> is 1000 Hz, we get <span
class="math display">\[
\omega_n = \frac{f_c}{0.5*f_s} = 0.6
\]</span> and in <code>rad/sample</code> unit, cutoff frequency is <span
class="math display">\[
\Phi = \pi * \omega_n = 0.6 \pi \text {, unit: rad/sample}
\]</span></p>
<h3 id="z-transform">Z-transform</h3>
<p><span class="math display">\[
z= e^{-j\Phi}
\]</span></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fc = <span class="number">300</span>;</span><br><span class="line">fs = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">[b,a] = butter(<span class="number">6</span>,fc/(fs/<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;The numerator b is:\n &#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;%g &#x27;</span>, b);</span><br><span class="line">fprintf(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;The denominator a is:\n &#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;%g &#x27;</span>, a);</span><br><span class="line">fprintf(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">freqz(b, a);</span><br><span class="line">ylim([<span class="number">-400</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The numerator (<code>b</code>) and denominator (<code>a</code>)
depend on the cutoff frequency and the order; the cutoff frequency is
denominated with <span class="math inline">\(\omega_n\)</span> . Just
multiply the <span class="math inline">\(\pi\)</span>, we get the
Z-transform <span class="math inline">\(\Phi\)</span> rad/sample, which
is the plot of <code>freqz(b, a)</code></p>
</blockquote>
<p><img src="/2024/05/02/ss-insight/image-20220407100948965.png"
alt="image-20220407100948965" /></p>
<h3 id="transfer-function-with-sample-information">Transfer function
with sample information</h3>
<p><span class="math display">\[
z = e^{-j\omega T_s}
\]</span></p>
<p><img src="/2024/05/02/ss-insight/image-20220407103451265.png"
alt="image-20220407103451265" /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">figure(<span class="number">2</span>)</span><br><span class="line">ylim([-<span class="number">400</span>, <span class="number">100</span>])</span><br><span class="line">[h,f] = freqz(b,a,[],fs);</span><br><span class="line">hdb20 = <span class="number">20</span>*log10(abs(h));</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(f, hdb20, &#x27;b&#x27;)</span><br><span class="line">ylim([-<span class="number">400</span>, <span class="number">100</span>])</span><br><span class="line">title(&#x27;DTFT <span class="keyword">with</span> freqz <span class="keyword">and</span> sample rate&#x27;)</span><br><span class="line">xlabel(&#x27;Frequency (Hz)&#x27;)</span><br><span class="line">ylabel(&#x27;Mag (dB)&#x27;)</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sys = tf(b, a, <span class="number">1</span>/fs);</span><br><span class="line">[mag, phs, wout] = bode(sys);</span><br><span class="line">wout = wout(:);</span><br><span class="line">whz = wout/<span class="number">2</span>/pi;</span><br><span class="line">hdb = <span class="number">20</span>*log10(mag(:));</span><br><span class="line">plot(whz, hdb, &#x27;r-o&#x27;);</span><br><span class="line">ylim([-<span class="number">400</span>, <span class="number">100</span>])</span><br><span class="line">title(&#x27;DTFT <span class="keyword">with</span> bode <span class="keyword">and</span> sample period&#x27;)</span><br><span class="line">xlabel(&#x27;Frequency (Hz)&#x27;)</span><br><span class="line">ylabel(&#x27;Mag (dB)&#x27;)</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">plot(f, hdb20,&#x27;b&#x27;, whz, hdb, &#x27;ro&#x27;);</span><br><span class="line">legend(&#x27;freqz&#x27;, &#x27;bode&#x27;)</span><br><span class="line">ylim([-<span class="number">400</span>, <span class="number">100</span>])</span><br><span class="line">title(&#x27;overlay <span class="keyword">and</span> comparision&#x27;)</span><br><span class="line">xlabel(&#x27;Frequency (Hz)&#x27;)</span><br><span class="line">ylabel(&#x27;Mag (dB)&#x27;)</span><br><span class="line">grid on;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="time-domain-from-frequency-domain">Time Domain from Frequency
Domain</h3>
<p>Assume input is <strong>sampled by</strong> <span
class="math inline">\(f_s\)</span></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">figure(<span class="number">3</span>)</span><br><span class="line">% <span class="keyword">assume</span> x is sampled by fs</span><br><span class="line">x = <span class="keyword">rand</span>(<span class="number">1</span>, <span class="number">50</span>);</span><br><span class="line">y = filter(b, a, x);</span><br><span class="line">xt = (<span class="number">1</span>:<span class="number">50</span>);</span><br><span class="line">plot(xt, x, &#x27;-s&#x27;, xt, y, &#x27;-o&#x27;)</span><br><span class="line">legend(&#x27;<span class="keyword">input</span>&#x27;, &#x27;<span class="keyword">output</span>&#x27;)</span><br><span class="line">xlabel(&#x27;Sample&#x27;)</span><br><span class="line">ylabel(&#x27;mag&#x27;)</span><br><span class="line">title(&#x27;filter in Time domain&#x27;)</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/05/02/ss-insight/image-20220407113330972.png"
alt="image-20220407113330972" /></p>
<h2 id="bilinear-transformation">Bilinear Transformation</h2>
<p><strong>Bilinear Transformation</strong>, also known as
<strong>Bilinear Approximation</strong>, an algebraic transformation
between the variables <span class="math inline">\(s\)</span> and <span
class="math inline">\(z\)</span> that maps the entire <span
class="math inline">\(j\Omega\)</span>-axis in the <span
class="math inline">\(s\)</span>-plane to <em>one revolution of the unit
circle</em> in the <span class="math inline">\(z\)</span>-plane.</p>
<p>That is, with this approach, <span class="math inline">\(-\infty \le
\Omega \le +\infty\)</span> maps onto <span class="math inline">\(-\pi
\le \omega \le +\pi\)</span>, the transformation between the
continuous-time and discrete-time frequency variables is necessarily
<strong>nonlinear</strong>.</p>
<p>With <span class="math inline">\(H_c(s)\)</span> denoting the
continuous-time system function and <span
class="math inline">\(H(z)\)</span> the discrete-time system function,
the bilinear transformation corresponds to replacing <span
class="math inline">\(s\)</span> by <span class="math display">\[
s=\frac{2}{T_d}\left( \frac{1-z^{-1}}{1+z^{-1}} \right)
\]</span></p>
<p>that is, <span class="math display">\[
H(z) = H_c\left( \frac{2}{T_d}\left( \frac{1-z^{-1}}{1+z^{-1}} \right)
\right)
\]</span></p>
<h2 id="different-variants-of-the-psd-definition">Different Variants of
the PSD Definition</h2>
<p>In the practice of engineering, it has become customary to use
slightly different variants of the PSD definition, depending on the
particular application or research field.</p>
<ul>
<li><p><strong>Two-Sided PSD</strong>, <span
class="math inline">\(S_x(f)\)</span></p>
<p>this is a synonym of the PSD defined as the Fourier Transform of the
<strong>autocorrelation</strong>.</p></li>
<li><p><strong>One-Sided PSD</strong>, <span
class="math inline">\(S&#39;_x(f)\)</span></p>
<p>this is a variant derived from the <em>two-sided PSD</em> by
considering only the <em>positive frequency</em> semi-axis.</p>
<p>To <strong>conserve the total power</strong>, the value of the
one-sided PSD is <strong>twice</strong> that of the two-sided PSD <span
class="math display">\[
S&#39;_x(f) = \left\{ \begin{array}{cl}
0 &amp; : \ f \geq 0 \\
S_x(f) &amp; : \ f = 0 \\
2S_x(f) &amp; : \ f \gt 0
\end{array} \right.
\]</span></p></li>
</ul>
<p><img src="/2024/05/02/ss-insight/image-20230603185546658.png"
alt="image-20230603185546658" /></p>
<blockquote>
<p>Note that the one-sided PSD definition makes sense only if the
two-sided is an even function of <span
class="math inline">\(f\)</span></p>
</blockquote>
<p>If <span class="math inline">\(S&#39;_x(f)\)</span> is even
symmetrical around a positive frequency <span
class="math inline">\(f_0\)</span>, then two additional definitions can
be adopted:</p>
<ul>
<li><p><strong>Single-Sideband PSD</strong>, <span
class="math inline">\(S_{SSB,x}(f)\)</span></p>
<p>This is obtained from <span
class="math inline">\(S&#39;_x(f)\)</span> by moving the origin of the
frequency axis to <span class="math inline">\(f_0\)</span> <span
class="math display">\[
S_{SSB,x}(f) =S&#39;_x(f+f_0)
\]</span> This concept is particularly useful for describing phase or
amplitude modulation schemes in wireless communications, where <span
class="math inline">\(f_0\)</span> is the carrier frequency.</p>
<blockquote>
<p>Note that there is no difference in the values of the one-sided
versus the SSB PSD; it is just a pure translation on the frequency
axis.</p>
</blockquote></li>
<li><p><strong>Double-Sideband PSD</strong>, <span
class="math inline">\(S_{DSB,x}(f)\)</span></p>
<p>this is a variant of the SSB PSD obtained by considering only the
positive frequency semi-axis.</p>
<p>As in the case of the one-sided PSD, to conserve total power, the
value of the DSB PSD is twice that of the SSB <span
class="math display">\[
S_{DSB,x}(f) = \left\{ \begin{array}{cl}
0 &amp; : \ f \geq 0 \\
S_{SSB,x}(f) &amp; : \ f = 0 \\
2S_{SSB,x}(f) &amp; : \ f \gt 0
\end{array} \right.
\]</span></p></li>
</ul>
<p><img src="/2024/05/02/ss-insight/image-20230603222054506.png"
alt="image-20230603222054506" /></p>
<blockquote>
<p>Note that the DSB definition makes sense only if the SSB PSD is even
symmetrical around zero</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Stephen P. Boyd. EE102 Lecture 10 Sinusoidal steady-state and
frequency response [<a
href="https://web.stanford.edu/~boyd/ee102/freq.pdf">https://web.stanford.edu/~boyd/ee102/freq.pdf</a>]</p>
<p><em>Gene F. Franklin, J. David Powell, and Abbas Emami-Naeini. 2018.
Feedback Control of Dynamic Systems (8th Edition) (8th. ed.).
Pearson.</em></p>
<p>Inter-Symbol Interference (or Leaky Bits) [<a
href="http://blog.teledynelecroy.com/2018/06/inter-symbol-interference-or-leaky-bits.html">http://blog.teledynelecroy.com/2018/06/inter-symbol-interference-or-leaky-bits.html</a>]</p>
<p>[AN001] Designing from zero an IIR filter in Verilog using biquad
structure and bilinear discretization. URL:[<a
href="https://www.controlpaths.com/articles/an001_designing_iir_biquad_filter_bilinear/">https://www.controlpaths.com/articles/an001_designing_iir_biquad_filter_bilinear/</a>]</p>
<p>Frequency warping using the bilinear transform. URL:[<a
href="https://www.controlpaths.com/2022/05/09/frequency-warping-using-the-bilinear-transform/">https://www.controlpaths.com/2022/05/09/frequency-warping-using-the-bilinear-transform/</a>]</p>
<p>Digital control loops. Theoretical approach. URL:[<a
href="https://www.controlpaths.com/2022/02/28/digital-control-loops-theoretical-approach/">https://www.controlpaths.com/2022/02/28/digital-control-loops-theoretical-approach/</a>]</p>
<p>Simulation of DSP algorithms in Verilog. URL:[<a
href="https://www.controlpaths.com/2023/05/20/simulation-of-dsp-algorithms-in-verilog/">https://www.controlpaths.com/2023/05/20/simulation-of-dsp-algorithms-in-verilog/</a>]</p>
<p>Implementing a digital biquad filter in Verilog. URL:[<a
href="https://www.controlpaths.com/2021/04/19/implementing-a-digital-biquad-filter-in-verilog/">https://www.controlpaths.com/2021/04/19/implementing-a-digital-biquad-filter-in-verilog/</a>]</p>
<p>Implementing a FIR filter using folding. URL:[<a
href="https://www.controlpaths.com/2021/05/17/implementing-a-fir-filter-using-folding/">https://www.controlpaths.com/2021/05/17/implementing-a-fir-filter-using-folding/</a>]</p>
<p>Oppenheim, Alan V. and Cram. “Discrete-time signal processing : Alan
V. Oppenheim, 3rd edition.” (2011).</p>
<p>Extras: PID Compensator with Bilinear Approximation URL:[<a
href="https://ctms.engin.umich.edu/CTMS/index.php?aux=Extras_PIDbilin">https://ctms.engin.umich.edu/CTMS/index.php?aux=Extras_PIDbilin</a>]</p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>sub-binary radix DAC</title>
    <url>/2022/03/19/sub-binary-radix-DAC/</url>
    <content><![CDATA[<p><strong>reference</strong>:</p>
<p>Roermund, Arthur &amp; Hegt, Hans &amp; Harpe, Pieter. (2010). Smart
AD and DA Conversion. 10.1007/978-90-481-9042-3.</p>
<p>M. Pastre and M. Kayal, "High-precision DAC based on a
self-calibrated sub-binary radix converter," 2004 IEEE International
Symposium on Circuits and Systems (IEEE Cat. No.04CH37512), 2004, pp.
I-I, doi: 10.1109/ISCAS.2004.1328201.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>SystemVerilog iff</title>
    <url>/2022/06/21/sv-iff/</url>
    <content><![CDATA[<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">@(<span class="keyword">posedge</span> clk <span class="keyword">iff</span>(vld));</span><br><span class="line">do_something;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">	@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    <span class="keyword">if</span>(vld) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">do_something;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>iff</code> is more efficient than <code>if</code> because the
expression is recalculated when <code>vld</code> transition rather than
<code>clk</code>.</p>
</blockquote>
<p>One example, detecting the negative edge of
<code>rtr_io.cb.frameo_n[da]</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wait</span>(rtr_io<span class="variable">.cb</span><span class="variable">.frameo_n</span>[da] !== <span class="number">0</span>);</span><br><span class="line">@(rtr_io<span class="variable">.cb</span> <span class="keyword">iff</span>(rtr_io<span class="variable">.cb</span><span class="variable">.frameo_n</span>[da] === <span class="number">0</span> )); </span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;[DEBUG HGUO] %0t, rtr_io.cb.frameo_n[da] negedge&quot;</span>, <span class="built_in">$realtime</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/21/sv-iff/image-20220621182019927.png"
alt="image-20220621182019927" /></p>
<p><code>[DEBUG HGUO] 6887250.0ns, rtr_io.cb.frameo_n[da] negedge</code></p>
<p><strong>reference</strong></p>
<p>system verilog中的iff, URL: <a
href="https://www.francisz.cn/2019/07/18/sv-iff/">https://www.francisz.cn/2019/07/18/sv-iff/</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Metastability and Synchronizer</title>
    <url>/2023/08/10/synchronizer-metastability/</url>
    <content><![CDATA[<h2 id="sequentail-logic-deal">Sequentail logic deal</h2>
<p>We guarantee setup &amp; hold time / minimum clock width, FF
guarantees propagation delay (clock -&gt; q delay)</p>
<p>We can not keep our part of the deal because asynchronous signal may
change in the setup/hold window</p>
<p>FF enters a metastable state, as a result it does not guarantee
propagation delay</p>
<h2 id="what-is-a-metastable-flip-flop">What is a metastable flip
flop?</h2>
<blockquote>
<p>Non-Regenerative flipflop: <strong>NOT</strong> suitable for
synchronization</p>
</blockquote>
<blockquote>
<p>Regenerative flipflop: Feedback loop must be isolated</p>
</blockquote>
<h2 id="probability-of-entering-a-metastable-state">Probability of
entering a metastable state</h2>
<h2
id="metastability-resolution-time-constant-tau-of-flip-flops">Metastability
resolution time constant (<span class="math inline">\(\tau\)</span>) of
flip-flops</h2>
<p><span class="math display">\[
T_W = T_0 \cdot e^{-t_r/\tau}
\]</span></p>
<ul>
<li><p><span class="math inline">\(T_W\)</span>: metastability window
width for a given <span class="math inline">\(t_r\)</span> (<span
class="math inline">\(|T_{clk}-T_d| - T_{meta}\)</span>) where <span
class="math inline">\(T_{meta}\)</span> is the data failing point (<span
class="math inline">\(t_r=\infty\)</span>)</p></li>
<li><p><span class="math inline">\(T_0\)</span>: metastability window
width at zero resolution time</p></li>
<li><p><span class="math inline">\(t_r\)</span>: resolution time (clock
to output delay)</p></li>
<li><p><span class="math inline">\(\tau\)</span>: resolution time
constant</p></li>
</ul>
<h2 id="recovering-from-a-metastable-state">Recovering from a metastable
state</h2>
<h3 id="in-a-latch">in a latch</h3>
<h3 id="in-a-flipflop">in a flipflop</h3>
<h2 id="probability-of-failure">Probability of failure</h2>
<h2 id="techniques-to-improve-mtbf">Techniques to improve MTBF</h2>
<h2 id="data-flip-flops-vs.-synchronizer-flip-flops">Data Flip-Flops Vs.
Synchronizer Flip-Flops</h2>
<p><img
src="/2023/08/10/synchronizer-metastability/image-20230704230313635.png"
alt="image-20230704230313635" /></p>
<h2 id="reference">reference</h2>
<p>Chen, Doris T., Deshanand P. Singh, Jeffrey Chromczak, David M.
Lewis, Ryan Fung, David Neto and Vaughn Betz. “A comprehensive approach
to modeling, characterizing and optimizing for metastability in FPGAs.”
Symposium on Field Programmable Gate Arrays (2010).</p>
<p>Jerome Cox. Synchronizers And Data Flip-Flops are Different [<a
href="https://ee.usc.edu/async2015/web/wp-content/uploads/2015/03/S1_P4_ASYNC2015IndustrialPaperDFF.pdf">https://ee.usc.edu/async2015/web/wp-content/uploads/2015/03/S1_P4_ASYNC2015IndustrialPaperDFF.pdf</a>]</p>
<p>J. U. Horstmann, H. W. Eichel and R. L. Coates, "Metastability
behavior of CMOS ASIC flip-flops in theory and test," in IEEE Journal of
Solid-State Circuits, vol. 24, no. 1, pp. 146-157, Feb. 1989, doi:
10.1109/4.16314.</p>
<p>Steve Golson. Synchronization and Metastability [<a
href="https://trilobyte.com/pdf/golson_snug14.pdf">https://trilobyte.com/pdf/golson_snug14.pdf</a>]</p>
<p>J. Reiher, M. R. Greenstreet and I. W. Jones, "Explaining
Metastability in Real Synchronizers," 2018 24th IEEE International
Symposium on Asynchronous Circuits and Systems (ASYNC), Vienna, Austria,
2018, pp. 59-67, doi: 10.1109/ASYNC.2018.00024.</p>
<p>A. Cantoni, J. Walker and T. -D. Tomlin, "Characterization of a
Flip-Flop Metastability Measurement Method," in IEEE Transactions on
Circuits and Systems I: Regular Papers, vol. 54, no. 5, pp. 1032-1040,
May 2007, doi: 10.1109/TCSI.2007.895514.</p>
<p>S. Yang, I. W. Jones and M. R. Greenstreet, "Synchronizer Performance
in Deep Sub-Micron Technology," 2011 17th IEEE International Symposium
on Asynchronous Circuits and Systems, Ithaca, NY, USA, 2011, pp. 33-42,
doi: 10.1109/ASYNC.2011.19.</p>
<p>Max Maxfield. Meandering Musings on Metastability [<a
href="https://www.eejournal.com/article/meandering-musings-on-metastability/">https://www.eejournal.com/article/meandering-musings-on-metastability/</a>]</p>
<p>R. Ginosar, "Metastability and Synchronizers: A Tutorial," in IEEE
Design &amp; Test of Computers, vol. 28, no. 5, pp. 23-35, Sept.-Oct.
2011, doi: 10.1109/MDT.2011.113. [<a
href="https://webee.technion.ac.il/~ran/papers/Metastability-and-Synchronizers.IEEEDToct2011.pdf">https://webee.technion.ac.il/~ran/papers/Metastability-and-Synchronizers.IEEEDToct2011.pdf</a>]</p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Real Modeling with SystemVerilog using Cadence EE_pkg 101</title>
    <url>/2022/03/16/sv-rnm-101/</url>
    <content><![CDATA[<h2 id="what-is-real-number-modeling">What Is Real Number Modeling?</h2>
<ul>
<li>model analog blocks operation as signal flow model</li>
<li>only the digital solver is used for high-speed simulation
<ul>
<li>Event-driven</li>
<li>No convergence issues, because no analog solver is used</li>
</ul></li>
<li>Five different language standards support real number modeling:
<ul>
<li><strong>wreal</strong> (wired-real) ports in Verilog-AMS</li>
<li><strong>real</strong> data type in VHDL</li>
<li><strong>real</strong> data type in Verilog</li>
<li><strong>real</strong> variables and <strong>nettypes</strong> in
SystemVerilog (SV)</li>
<li><strong>real</strong> types in e</li>
</ul></li>
</ul>
<h2 id="benefits-of-rnm">Benefits of RNM</h2>
<ul>
<li>Most analog circuits that need to be modeled for MS verification at
the SoC level can be described in terms of real-valued voltages or
currents</li>
<li>RNM is a mixed approach, borrowing concepts from both continuous and
discrete domains
<ul>
<li>The values are floating-point (real) number.</li>
<li>Time is discrete; the real signals change values based on discrete
events</li>
</ul></li>
<li>Applicability of RNM is bounded primarily by
<strong>signal-flow</strong> model style</li>
<li>Migrating analog behavior from the analog domain to the event or
pseudo-analog domain can bring huge benefits without sacrificing too
much accuracy</li>
<li>Simulation is executed by a digital simulation engine without need
for the analog solver</li>
<li>Hence real-number modeling enables very high performance simulation
of mixed-signal systems</li>
</ul>
<h2 id="limitations-of-rnm">Limitations of RNM</h2>
<ul>
<li>connecting <strong>real</strong> or <strong>wreal</strong> signals
to electrical signals requires careful consideration
<ul>
<li>Too conservative an approach can lead to large numbers of
timepoints</li>
<li>Too liberal an approach can lead to losing signal accuracy</li>
</ul></li>
<li>Time accuracy limited by the discrete sampling approach and the
`<code>timescale</code> setting - no continuous signals anymore</li>
<li>Limited capability for combination of signals by wiring outputs
together
<ul>
<li>Requires assumptions about impedances to do simple merging</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>SystemVerilog clocking block</title>
    <url>/2022/02/07/systemverilog-clocking-block/</url>
    <content><![CDATA[<blockquote>
<p>Assignment at &lt;interface&gt;.&lt;clocking block&gt;.&lt;output
signal&gt; (i.e. synchronous) do <strong>NOT</strong> change
&lt;interface&gt;.&lt;output signal&gt; until active clock edge.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router_io.sv</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> router_io(<span class="keyword">input</span> <span class="keyword">bit</span> clock);</span><br><span class="line">  <span class="keyword">logic</span>    reset_n;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  din;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  frame_n;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  valid_n;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  dout;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  valido_n;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  busy_n;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>]  frameo_n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">clocking</span> cb @(<span class="keyword">posedge</span> clock);</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">1</span>ns <span class="keyword">output</span> #<span class="number">1</span>ns;</span><br><span class="line">    <span class="keyword">output</span> reset_n;</span><br><span class="line">    <span class="keyword">output</span> din;</span><br><span class="line">    <span class="keyword">output</span> frame_n;</span><br><span class="line">    <span class="keyword">output</span> valid_n;</span><br><span class="line">    <span class="keyword">input</span>  dout;</span><br><span class="line">    <span class="keyword">input</span>  valido_n;</span><br><span class="line">    <span class="keyword">input</span>  frameo_n;</span><br><span class="line">    <span class="keyword">input</span>  busy_n;</span><br><span class="line">  <span class="keyword">endclocking</span>: cb</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `reset_n` can be either a synchronous or an asynchronous signal</span></span><br><span class="line">  <span class="keyword">modport</span> TB(<span class="keyword">clocking</span> cb, <span class="keyword">output</span> reset_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endinterface</span>: router_io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>All interface signals are asynchronous and without a direction
spection (i.e. input, output, inout).</p>
<ul>
<li>The direction can only be specified in <code>clocking</code> block
for <strong>synchronous signals</strong></li>
<li>or a <code>modport</code> for <strong>asynchronous
signals</strong></li>
</ul>
<p>All directions for the signals in the clocking block must be with
respect to the test program;</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.sv</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(router_io<span class="variable">.TB</span> rtr_io);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    reset();</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">task</span> reset();</span><br><span class="line">    rtr_io<span class="variable">.reset_n</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    rtr_io<span class="variable">.cb</span><span class="variable">.frame_n</span> &lt;= &#x27;<span class="number">1</span>;</span><br><span class="line">    rtr_io<span class="variable">.cb</span><span class="variable">.valid_n</span> &lt;= &#x27;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(<span class="number">2</span>) @rtr_io<span class="variable">.cb</span>;</span><br><span class="line">    rtr_io<span class="variable">.cb</span><span class="variable">.reset_n</span> &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(<span class="number">15</span>) @(rtr_io<span class="variable">.cb</span>);</span><br><span class="line">  <span class="keyword">endtask</span>: reset</span><br><span class="line"></span><br><span class="line"><span class="keyword">endprogram</span>: test</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router_test_top.sv</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> router_test_top;</span><br><span class="line">  <span class="keyword">parameter</span> simulation_cycle = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bit</span> SystemClock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  router_io top_io(SystemClock);</span><br><span class="line">  test t(top_io);</span><br><span class="line"></span><br><span class="line">  router dut(</span><br><span class="line">    <span class="variable">.reset_n</span>  (top_io<span class="variable">.reset_n</span>),</span><br><span class="line">    <span class="variable">.clock</span>    (top_io<span class="variable">.clock</span>),</span><br><span class="line">    <span class="variable">.din</span>    (top_io<span class="variable">.din</span>),</span><br><span class="line">    <span class="variable">.frame_n</span>  (top_io<span class="variable">.frame_n</span>),</span><br><span class="line">    <span class="variable">.valid_n</span>  (top_io<span class="variable">.valid_n</span>),</span><br><span class="line">    <span class="variable">.dout</span>    (top_io<span class="variable">.dout</span>),</span><br><span class="line">    <span class="variable">.valido_n</span>  (top_io<span class="variable">.valido_n</span>),</span><br><span class="line">    <span class="variable">.busy_n</span>    (top_io<span class="variable">.busy_n</span>),</span><br><span class="line">    <span class="variable">.frameo_n</span>  (top_io<span class="variable">.frameo_n</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">1</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    $fsdbDumpvars;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="variable">#(simulation_cycle/2)</span> SystemClock = ~SystemClock;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>compile</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vcs -sverilog -full64 -kdb -debug_access+all router_test_top.sv test.sv router_io</span><br><span class="line">.sv ../../rtl/router.v</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file with `<code>timescale</code> must be placed in the first, which
is <code>router_test_top.sv</code> in above example</p>
</blockquote>
<h3 id="clocking.output">clocking.output</h3>
<p><img
src="/2022/02/07/systemverilog-clocking-block/image-20220621005749074.png"
alt="image-20220621005749074" /></p>
<blockquote>
<p>systemverilog don't pass clocking.output to interface's until current
or next active edge and after output-skew</p>
</blockquote>
<h3 id="clocking.input">clocking.input</h3>
<p><img
src="/2022/02/07/systemverilog-clocking-block/image-20220621010546293.png"
alt="image-20220621010546293" /></p>
<blockquote>
<p>Systemverilog <strong>automatically</strong> update clocking.input
signal from interface's value, input-skew before active edge</p>
</blockquote>
<h3 id="gotcha">Gotcha</h3>
<p>An <code>interface</code> must be compiled separately like a
<code>module</code> and CANNOT `<code>include</code> inside a
<code>package</code> or ohter <code>module</code></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>temperature sensor</title>
    <url>/2022/08/11/t-sensor/</url>
    <content><![CDATA[<p>Due to the fact that <em>long-term drift</em> of temperature sensors
and bandgap references caused by package-induced stress is lower with
PNP BJTs than with NPN BJTs, <strong>PNP</strong> BJTs have been used
traditionally for temperature sensor design in CMOS</p>
<h3 id="v_be-curvature"><span class="math inline">\(V_{BE}\)</span>
curvature</h3>
<p>Though it is assumed that <span class="math inline">\(V_{BE}\)</span>
is a linear function of temperature for first oder analysis.</p>
<p>In practice, <span class="math inline">\(V_{BE}\)</span> is
<em>slightly nonlinear</em>, the magnitude of this nonlinearity is
referred to as <strong>curvature</strong>.</p>
<p><strong>curvature</strong> depends on the temperature dependency of
the <em>saturation current</em> (<span
class="math inline">\(I_s\)</span>), and on that of the <em>collector
current</em> (<span class="math inline">\(I_c\)</span>), it can be
written as <span class="math display">\[
V_{curv}(T)=\frac{k}{q}(\eta-\delta)(T-T_r-T\cdot \ln(\frac{T}{T_r}))
\]</span> where <span class="math inline">\(\eta\)</span> = a constant
depending on the doping level, CMOS substrate pnp transistors have a
typically value of <span class="math inline">\(\eta \cong 4\)</span></p>
<p><span class="math inline">\(\delta\)</span> = order of the
<em>temperature dependence of collector current</em> (<span
class="math inline">\(I_c\)</span>)</p>
<blockquote>
<p>PTAT <span class="math inline">\(I_c\)</span> help reduce <span
class="math inline">\(V_{curv}(T)\)</span>, <span
class="math inline">\(\delta=1\)</span></p>
</blockquote>
<p>Although the temperature dependence of the bias current <span
class="math inline">\(I_b\)</span> doesn’t impact the accuracy of <span
class="math inline">\(V_{BE}\)</span>, it does impact the systematic
nonlinearity or curvature of <span
class="math inline">\(V_{BE}\)</span>, and hence the sensor's
<em>systematic error</em>. <strong>The curvature in <span
class="math inline">\(V_{BE}\)</span> can be reduced by using a PTAT
bias current</strong>.</p>
<p><img src="/2022/08/11/t-sensor/image-20221106010909644.png"
alt="image-20221106010909644" /></p>
<h3 id="ptat-bias-current-generation">PTAT bias current generation</h3>
<p><img src="/2022/08/11/t-sensor/image-20221023150817411.png"
alt="image-20221023150817411" /> <span class="math display">\[
I_{bias} = \frac{0.7}{\beta \cdot R^2}
\]</span> in which <span class="math inline">\(\beta=\frac{\mu_{n}\cdot
C_{ox}\cdot W}{L}\)</span>, where:</p>
<p><span class="math inline">\(\mu_n\)</span>=mobility,</p>
<p><span class="math inline">\(C_{ox}\)</span> = oxide capacitance
density,</p>
<p><span class="math inline">\(\frac{W}{L}\)</span> = dimension ratio of
unit NMOS used for <span class="math inline">\(M_1\)</span> and <span
class="math inline">\(M_2\)</span></p>
<p><span class="math inline">\(\mu_n\)</span> is <strong>complementary
to the absolute temperature</strong> and resitor R is implemented using
high-R flow in FinFET which has a low temperature dependency, the net
temperature dependency of <span class="math inline">\(I_{bias}\)</span>
is proportional to the absolute temperature <span
class="math display">\[
I_{bias}\propto  T
\]</span></p>
<h3 id="errors-due-to-v-i-finite-gain">Errors due to V-I Finite
Gain</h3>
<p>Finite gain introduces errors both in the V-I converters, finite loop
gain results in errors in the closed-loop transconductances.</p>
<p><img src="/2022/08/11/t-sensor/image-20221106153613505.png"
alt="image-20221106153613505" /> <span
class="math display">\[\begin{align}
(V_{i1} - V_{o1})\cdot A_{OL1} &amp;= V_{o1} \\
V_{o1} &amp;= \frac{A_{OL1}}{1+A_{OL1}}V_{i1} \\
I_{o1} &amp;= \frac{A_{OL1}}{1+A_{OL1}}\frac{1}{R_1}V_{i1}
\end{align}\]</span> similarly, <span class="math display">\[
I_{o2} = \frac{A_{OL2}}{1+A_{OL2}}\frac{1}{R_2}V_{i2}
\]</span></p>
<p>Then, <span class="math inline">\(\alpha\)</span> is obtained <span
class="math display">\[
\alpha =
\frac{(1+A_{OL2})A_{OL1}}{A_{OL2}(1+A_{OL1})}\cdot\frac{R_2}{R_1}
\]</span> Since the loop gains in the two V-I converters cannot be
expected to <em>match</em>, the resulting errors in
<strong>both</strong> converters should be reduced to negligible
levels.</p>
<p>First, assume <span class="math inline">\(A_{OL2}=\infty\)</span>
<span class="math display">\[\begin{align}
\Delta \alpha &amp;= (1-\frac{A_{OL1}}{1+A_{OL1}})\cdot\frac{R_2}{R_1}\\
&amp;=\frac{1}{1+A_{OL1}}\cdot\frac{R_2}{R_1}\\
&amp;\cong \frac{1}{A_{OL1}}\cdot\frac{R_2}{R_1}
\end{align}\]</span></p>
<p>We get <span class="math display">\[
\frac{\Delta \alpha}{\alpha}=\frac{1}{A_{OL1}}
\]</span> Follow the same procedure, assume <span
class="math inline">\(A_{OL1}=\infty\)</span> <span
class="math display">\[
\frac{\Delta \alpha}{\alpha}=\frac{1}{A_{OL2}}
\]</span> The finite gain introduces an error inversely proportional to
the loop gain <span class="math inline">\(A_{OL1}\)</span>,<span
class="math inline">\(A_{OL2}\)</span>, the resulting errors in both
converters should be reduced to negligible levels</p>
<h3 id="why-is-it-named-as-bandgap-reference">Why is it named as
"bandgap reference"</h3>
<p>Let us write the output voltage as <span class="math display">\[
V_{REF} = V_{BE} + V_T\cdot \ln n
\]</span> and hence <span class="math display">\[
\frac{\partial V_{REF}}{\partial T} = \frac{\partial V_{BE}}{\partial T}
+ \frac{V_T}{T}\ln n
\]</span> Setting this to zero and substituting for <span
class="math inline">\(\frac{\partial V_{BE}}{\partial T}\)</span>, we
have <span class="math display">\[
\frac{V_{BE}-(4+m)V_T-E_g/q}{T}=-\frac{V_T}{T}\ln n
\]</span> If <span class="math inline">\(V_T\ln n\)</span> is found from
this equation and inserted in <span
class="math inline">\(V_{REF}\)</span>, we obtain <span
class="math display">\[
V_{REF}=\frac{E_g}{q} + (4+m)V_T
\]</span></p>
<blockquote>
<p>The term <strong>bandgap</strong> is used here because as <span
class="math inline">\(T\to 0\)</span>, <span
class="math inline">\(V_{REF} \to E_g/q\)</span></p>
</blockquote>
<h3 id="consideration-for-readout-circuit">Consideration for Readout
Circuit</h3>
<h4 id="adc-dynamic-range">ADC dynamic range</h4>
<p>Take <span class="math inline">\(V_{PTAT}=\alpha \cdot \Delta
V_{BE}\)</span> as input and <span
class="math inline">\(V_{REF}\)</span> as reference. The output <span
class="math inline">\(\mu\)</span> of the ADC will then be <span
class="math display">\[
\mu =\frac{V_{PTAT}}{V_{VREF}}=\frac{\alpha \cdot \Delta
V_{BE}}{V_{BE}+\alpha \cdot \Delta V_{BE}}
\]</span> A final digital output <span
class="math inline">\(D_{out}\)</span> in degrees <em>Celsius</em> can
be obtained by linear scaling: <span class="math display">\[
D_{out}=A\cdot \mu + B
\]</span> where <span class="math inline">\(A\simeq 600K\)</span> and
<span class="math inline">\(B\simeq -273K\)</span></p>
<p>While the transfer is simple, it only uses about 30% of the of the
ADC (the extremes of the operating range correspond to <span
class="math inline">\(\mu \simeq 1/3\)</span> and <span
class="math inline">\(\mu \simeq 2/3\)</span>). The ratio results in a
rather inefficient use of the modulator's <em>dynamic range</em>.</p>
<p>For a first-order <span class="math inline">\(\Sigma\Delta\)</span>
modulator, this means that about <strong>1.5 bits</strong> of resolution
are lost</p>
<p>A more efficient transfer is <span class="math display">\[
\mu &#39;=\frac{2\alpha \cdot \Delta V_{BE}-V_{BE}}{V_{BE}+\alpha \cdot
\Delta V_{BE}}
\]</span> With this more efficient combination, <em>90%</em> of the
dynamic range is used rather than 30%. Thus, <em>the required resolution
of the ADC</em> is reduced by <strong>a factor of three</strong>.</p>
<p><img src="/2022/08/11/t-sensor/image-20230204220522392.png"
alt="image-20230204220522392" /></p>
<h4 id="integrator-output-swing">Integrator Output Swing</h4>
<blockquote>
<p><span class="math display">\[
\mu =\frac{\alpha \cdot \Delta V_{BE}}{V_{BE}+\alpha \cdot \Delta
V_{BE}}
\]</span></p>
</blockquote>
<p><img src="/2022/08/11/t-sensor/image-20230207002324363.png"
alt="image-20230207002324363" /></p>
<blockquote>
<p><span class="math display">\[
\mu &#39;=\frac{2\alpha \cdot \Delta V_{BE}-V_{BE}}{V_{BE}+\alpha \cdot
\Delta V_{BE}}
\]</span></p>
</blockquote>
<p><img src="/2022/08/11/t-sensor/image-20230206230202755.png"
alt="image-20230206230202755" /></p>
<p>In advanced process, like Finfet 16nm, 7nm, high resistance resistor
has <strong>+/-15%</strong> variation and MOM capacitor has
<strong>+/-30%</strong> variation.</p>
<p>Then, <span class="math inline">\(R_1\)</span> and <span
class="math inline">\(R_2\)</span> not only determine the <span
class="math inline">\(\alpha\)</span> but also the integrator's output
swing, so do <span class="math inline">\(V_{BE}\)</span> and <span
class="math inline">\(\Delta V_{BE}\)</span>, <span
class="math inline">\(C_{int}\)</span>.</p>
<blockquote>
<p>The integrator's output change per period</p>
</blockquote>
<p><img src="/2022/08/11/t-sensor/image-20230206231010121.png"
alt="image-20230206231010121" /></p>
<h5 id="example">example</h5>
<p><img src="/2022/08/11/t-sensor/image-20230430112230224.png"
alt="image-20230430112230224" /></p>
<h4 id="integrator-comparator-offset">integrator, comparator offset</h4>
<h5 id="integrator-offset">integrator offset</h5>
<p><img src="/2022/08/11/t-sensor/image-20230430114429118.png"
alt="image-20230430114429118" /></p>
<p><img src="/2022/08/11/t-sensor/image-20230430114520336.png"
alt="image-20230430114520336" /></p>
<h5 id="comparator-offset">comparator offset</h5>
<p><img src="/2022/08/11/t-sensor/image-20230501223512686.png"
alt="image-20230501223512686" /></p>
<h3 id="reference">reference</h3>
<p>Micheal, A., P., Pertijs., Johan, H., Huijsing., Pertijs., Johan, H.,
Huijsing. (2006). Precision Temperature Sensors in CMOS Technology.</p>
<p>Kamath, Umanath Ramachandra. "BJT Based Precision Voltage Reference
in FinFET Technology." (2021).</p>
<p>C. -H. Chang, J. -J. Horng, A. Kundu, C. -C. Chang and Y. -C. Peng,
"An ultra-compact, untrimmed CMOS bandgap reference with 3σ inaccuracy
of +0.64% in 16nm FinFET," 2014 IEEE Asian Solid-State Circuits
Conference (A-SSCC), 2014, pp. 165-168, doi:
10.1109/ASSCC.2014.7008886.</p>
<p>EE247 - Analog Digital Interface Integrated Circuits - Fall 2009 <a
href="https://inst.eecs.berkeley.edu/~ee247/fa09/files07/lectures/L24_2_f09.pdf">Lecture
24- Oversampled ADCs</a></p>
<p>Hecht, Bruce. (2010). SSCS DL Kofi Makinwa Talks About Smart Sensor
Design at SSCS-Boston [People]. Solid-State Circuits Magazine, IEEE. 2.
54 - 56. 10.1109/MSSC.2009.935278.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>T-coil and its application</title>
    <url>/2022/03/17/tcoil/</url>
    <content><![CDATA[<ul>
<li>Broaden the bandwidth</li>
<li>Create a constant, resistive input impedance in the presence of a
heavy load capacitance (ESD protection circuit)</li>
</ul>
<blockquote>
<p>L<sub>1</sub> = L<sub>2</sub> for impedance matching</p>
</blockquote>
<p>The use of T-coils can dramatically increase the
<strong>bandwidth</strong> and improve the <strong>return loss</strong>
in both TXs and RXs.</p>
<h2 id="tcoil-in-rx">Tcoil in RX</h2>
<p><img src="/2022/03/17/tcoil/image-20220502201254057.png"
alt="image-20220502201254057" /></p>
<blockquote>
<p><strong>ppwl</strong>: Independent Piece-Wise Linear Resistive
Source</p>
</blockquote>
<p><img src="/2022/03/17/tcoil/image-20220502201321341.png"
alt="image-20220502201321341" /></p>
<h2 id="simple-model">simple model</h2>
<blockquote>
<p>L1, L2, Km, Cb</p>
</blockquote>
<p><img src="/2022/03/17/tcoil/image-20220502215310947.png"
alt="image-20220502215310947" /></p>
<p><img src="/2022/03/17/tcoil/image-20220622224842237.png"
alt="image-20220622224842237" /></p>
<p><img src="/2022/03/17/tcoil/image-20220622225709712.png"
alt="image-20220622225709712" /></p>
<h2 id="equivalent-model">equivalent model</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">simulator lang=spectre</span><br><span class="line">include &quot;/path/to/INDL0.scs&quot;</span><br><span class="line">subckt for_import(p0 p1 p2 gnd)</span><br><span class="line">	xmod (p0 p1 p2 gnd) INDL0</span><br><span class="line">ends for_import</span><br><span class="line"></span><br><span class="line">x_1 (p_1_1 p_1_2 p_1_3 0) for_import</span><br><span class="line">v_1_1 (p_1_1 0) vsource mag=-1</span><br><span class="line">v_1_2 (p_1_2 0) vsource mag=0</span><br><span class="line">v_1_3 (p_1_3 0) vsource mag=0</span><br><span class="line">save v_1_1:p v_1_2:p v_1_3:p</span><br><span class="line"></span><br><span class="line">x_2 (p_2_1 p_2_2 p_2_3 0) for_import</span><br><span class="line">v_2_1 (p_2_1 0) vsource mag=0</span><br><span class="line">v_2_2 (p_2_2 0) vsource mag=-1</span><br><span class="line">v_2_3 (p_2_3 0) vsource mag=0</span><br><span class="line">save v_2_1:p v_2_2:p v_2_3:p</span><br><span class="line"></span><br><span class="line">x_3 (p_3_1 p_3_2 p_3_3 0) for_import</span><br><span class="line">v_3_1 (p_3_1 0) vsource mag=0</span><br><span class="line">v_3_2 (p_3_2 0) vsource mag=0</span><br><span class="line">v_3_3 (p_3_3 0) vsource mag=-1</span><br><span class="line">save v_3_1:p v_3_2:p v_3_3:p</span><br><span class="line">Y ac start=1.000000e+08 stop=2.000000e+10 step=1.000000e+08</span><br><span class="line"></span><br><span class="line">xsp (p_1 p_2 p_3 0) for_import</span><br><span class="line">port1 (p_1 0) port</span><br><span class="line">port2 (p_2 0) port</span><br><span class="line">port3 (p_3 0) port</span><br><span class="line">S sp start=1.000000e+08 stop=2.000000e+10 step=1.000000e+08 ports=[ port1 port2 port3]</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/17/tcoil/image-20220503005728763.png"
alt="image-20220503005728763" /></p>
<p><img src="/2022/03/17/tcoil/image-20220503005903105.png"
alt="image-20220503005903105" /></p>
<h3 id="emx_plot_tcoil-in-emxform.ils"><code>EMX_plot_tcoil</code> in
<code>emxform.ils</code></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (EMX_plot_tcoil bgui wid what)</span><br><span class="line">  (needNCells &#x27;adtComplex 100000)</span><br><span class="line">  (letseq ((to_z (lambda (ys)</span><br><span class="line">		   (letseq ((y11 (EMX_matrix_ref ys 0 0))</span><br><span class="line">			    (y12 (EMX_matrix_ref ys 0 1))</span><br><span class="line">			    (y21 (EMX_matrix_ref ys 1 0))</span><br><span class="line">			    (y22 (EMX_matrix_ref ys 1 1))</span><br><span class="line">			    (det y11*y22-y12*y21)</span><br><span class="line">			    (z11 y22/det)</span><br><span class="line">			    (z12 -y12/det)</span><br><span class="line">			    (z22 y11/det))</span><br><span class="line">		     (list z11 z12 z22))))</span><br><span class="line">	   (ground</span><br><span class="line">	    (lambda (y p)</span><br><span class="line">	      (letseq ((n (EMX_matrix_rows y))</span><br><span class="line">		       (yg (make_EMX_matrix n-1)))</span><br><span class="line">		(do ((i 0 i+1))</span><br><span class="line">		    ((i &gt;= n-1))</span><br><span class="line">		  (do ((j 0 j+1))</span><br><span class="line">		      ((j &gt;= n-1))</span><br><span class="line">		    (EMX_matrix_set yg i j (EMX_matrix_ref y i+(if (i &gt;= p) 1 0) j+(if (j &gt;= p) 1 0)))))</span><br><span class="line">		yg)))</span><br><span class="line">	   (reduce</span><br><span class="line">	    (lambda (yys)</span><br><span class="line">	      (letseq ((xvec (drGetWaveformXVec (car yys)))</span><br><span class="line">		       (n (drVectorLength xvec))</span><br><span class="line">		       (yyvecs (mapcar drGetWaveformYVec yys))</span><br><span class="line">		       (zz1 (drCreateVec &#x27;doublecomplex n))</span><br><span class="line">		       (zz2 (drCreateVec &#x27;doublecomplex n))</span><br><span class="line">		       (zz3 (drCreateVec &#x27;doublecomplex n)))</span><br><span class="line">		(do ((i 0 i+1))</span><br><span class="line">		    ((i &gt;= n))</span><br><span class="line">		  (let ((ys (mapcar (lambda (w) (drGetElem w i)) yyvecs)))</span><br><span class="line">		    (setq ys (ground (as_EMX_matrix 3 3 ys) 2))</span><br><span class="line">		    (let ((zz (to_z ys)))</span><br><span class="line">		      (drSetElem zz1 i (nth 0 zz))</span><br><span class="line">		      (drSetElem zz2 i (nth 1 zz))</span><br><span class="line">		      (drSetElem zz3 i (nth 2 zz)))))</span><br><span class="line">		(list (drCreateWaveform xvec zz1)</span><br><span class="line">		      (drCreateWaveform xvec zz2)</span><br><span class="line">		      (drCreateWaveform xvec zz3)))))</span><br><span class="line">	   (get_k</span><br><span class="line">	    (lambda (l12 l1122)</span><br><span class="line">	      (letseq ((xvec (drGetWaveformXVec l12))</span><br><span class="line">		       (n (drVectorLength xvec))</span><br><span class="line">		       (l12v (drGetWaveformYVec l12))</span><br><span class="line">		       (l1122v (drGetWaveformYVec l1122))</span><br><span class="line">		       (resultv (drCreateVec &#x27;double n)))</span><br><span class="line">		(do ((i 0 i+1))</span><br><span class="line">		    ((i &gt;= n))</span><br><span class="line">		  (letseq ((l12i (drGetElem l12v i))</span><br><span class="line">			   (l1122i (drGetElem l1122v i))</span><br><span class="line">			   (kk (if (l1122i &gt; 0.0)</span><br><span class="line">				   l12i/(sqrt l1122i)</span><br><span class="line">				   0.0))</span><br><span class="line">			   (k (if ((abs kk) &lt; 2.0) kk 0.0)))</span><br><span class="line">		    (drSetElem resultv i k)))</span><br><span class="line">		(drCreateWaveform xvec resultv)))))</span><br><span class="line">  (EMX_plot_aux bgui wid what 3</span><br><span class="line">		&#x27;(&quot;Inductance&quot; &quot;Q&quot; &quot;k&quot;)</span><br><span class="line">		&#x27;(&quot;Henry&quot; &quot;&quot; &quot;&quot;)</span><br><span class="line">		(lambda (ys)</span><br><span class="line">		  (letseq ((zs (reduce ys))</span><br><span class="line">			   (z11 (nth 0 zs))</span><br><span class="line">			   (z12 (nth 1 zs))</span><br><span class="line">			   (z22 (nth 2 zs))</span><br><span class="line">			   (pi 3.14159265358979)</span><br><span class="line">			   (f (xval z11))</span><br><span class="line">			   (l11 (imag z11)/(2*pi*f))</span><br><span class="line">			   (q11 (imag z11)/(real z11))</span><br><span class="line">			   (l12 (imag z12)/(2*pi*f))</span><br><span class="line">			   (l22 (imag z22)/(2*pi*f))</span><br><span class="line">			   (q22 (imag z22)/(real z22))</span><br><span class="line">			   (k (get_k l12 l11*l22)))</span><br><span class="line">		    `((,l11 ,l22) (,q11 ,q22) (,k))))</span><br><span class="line">		&#x27;((&quot;L1&quot; &quot;L2&quot;) (&quot;Q1&quot; &quot;Q2&quot;) (&quot;k&quot;)))))</span><br></pre></td></tr></table></figure>
<h2 id="tcoil-and-tapped-inductor">tcoil and tapped inductor</h2>
<p>tcoil and tapped inductor share same EM simulation result, and use
modelgen with different model formula.</p>
<p>The relationship is <span class="math display">\[
L_{\text{sim}} = L1_{\text{sim}}+L2_{\text{sim}}+2\times k_{\text{sim}}
\times \sqrt{L1_{\text{sim}}\cdot L2_{\text{sim}}}
\]</span> where <span class="math inline">\(L1_{\text{sim}}\)</span>,
<span class="math inline">\(L2_{\text{sim}}\)</span> and <span
class="math inline">\(k_{\text{sim}}\)</span> come from tcoil model
result, <span class="math inline">\(L_{\text{sim}}\)</span> comes from
tapped inductor model result</p>
<blockquote>
<p><span class="math inline">\(k_{\text{sim}}\)</span> in EMX have
assumption, induce current from P1 and P2 Given Dot Convention:</p>
<p>Same direction : k &gt; 0</p>
<p>Opposite direction : k &lt; 0</p>
<p>So, the <span class="math inline">\(k_{\text{sim}}\)</span> is
negative if routing coil in same direction</p>
</blockquote>
<p><img src="/2022/03/17/tcoil/image-20220623013225554.png"
alt="image-20220623013225554" /></p>
<p><img src="/2022/03/17/tcoil/image-20220623013923263.png"
alt="image-20220623013923263" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% EMX - shield tcoil model</span></span><br><span class="line">L1 = csvread(<span class="string">&#x27;./L1sim.csv&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">L2 = csvread(<span class="string">&#x27;./L2sim.csv&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">k = csvread(<span class="string">&#x27;./ksim.csv&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% EMX - Tapped shield inductor</span></span><br><span class="line">L = csvread(<span class="string">&#x27;./Lsim.csv&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">freq = L1(:, <span class="number">1</span>)/<span class="number">1e9</span>;    <span class="comment">% GHz</span></span><br><span class="line">L1 = L1(:, <span class="number">2</span>);</span><br><span class="line">L2 = L2(:, <span class="number">2</span>);</span><br><span class="line">k = -k(:, <span class="number">2</span>);   <span class="comment">% Caution: minus of EMX ksim due to same current direction</span></span><br><span class="line"></span><br><span class="line">L = L(:, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Lcalc = L1 + L2 + <span class="number">2</span>*k.*(L1.*L2).^<span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(freq, L*<span class="number">1e9</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(freq, Lcalc*<span class="number">1e9</span>, <span class="string">&#x27;--b&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Freq (GHz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Inductance (nH)&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Tapped inductor model&#x27;</span>, <span class="string">&#x27;tcoil model calc&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="reference">reference</h2>
<p>B. Razavi, "The Bridged T-Coil [A Circuit for All Seasons]," IEEE
Solid-State Circuits Magazine, Volume. 7, Issue. 40, pp. 10-13, Fall
2015.</p>
<p>B. Razavi, "The Design of Broadband I/O Circuits [The Analog Mind],"
IEEE Solid-State Circuits Magazine, Volume. 13, Issue. 2, pp. 6-15,
Spring 2021.</p>
<p>S. Galal and B. Razavi, "Broadband ESD protection circuits in CMOS
technology," in IEEE Journal of Solid-State Circuits, vol. 38, no. 12,
pp. 2334-2340, Dec. 2003, doi: 10.1109/JSSC.2003.818568.</p>
<p>M. Ker and Y. Hsiao, "On-Chip ESD Protection Strategies for RF
Circuits in CMOS Technology," 2006 8th International Conference on
Solid-State and Integrated Circuit Technology Proceedings, 2006, pp.
1680-1683, doi: 10.1109/ICSICT.2006.306371.</p>
<p>M. Ker, C. Lin and Y. Hsiao, "Overview on ESD Protection Designs of
Low-Parasitic Capacitance for RF ICs in CMOS Technologies," in IEEE
Transactions on Device and Materials Reliability, vol. 11, no. 2, pp.
207-218, June 2011, doi: 10.1109/TDMR.2011.2106129.</p>
<p><a
href="https://pdfs.semanticscholar.org/29db/7f450d63eee941424655fb787de7d644a3c2.pdf">David
J. Allstot Bandwidth Extension Techniques for CMOS Amplifiers</a></p>
<p><a href="https://ibis.org/summits/feb11/ross.pdf">Bob Ross, "T-Coil
Topics" DesignCon IBIS Summit 2011</a></p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Linear Circuits Analysis - Transfer Function &amp; Frequency Response</title>
    <url>/2023/12/23/tf-freqresp/</url>
    <content><![CDATA[<h2 id="are-ac-driven-circuits-linear">Are AC-Driven Circuits
Linear?</h2>
<p><span class="math display">\[
f(x_1 + x_2)= f(x_1)+ f(x_2)
\]</span></p>
<p>Often, AC-driven circuits can be mistaken as non-linear as the basis
that determines the linearity of a circuit is the relationship between
the voltage and current.</p>
<p>While an AC signal varies with time, it still exhibits a linear
relationship across elements like resistors, capacitors, and inductors.
Therefore, AC driven circuits are linear.</p>
<h2 id="phasor">Phasor</h2>
<p><em>Phasor concept has no real physical significance. It is just a
convenient mathematical tool.</em></p>
<blockquote>
<p>Phasor analysis determines the steady-state response to a linear
circuit driven by sinusoidal sources with frequency <span
class="math inline">\(f\)</span></p>
<p>If your circuit includes transistors or other nonlinear components,
all is not lost. There is an extension of phasor analysis to nonlinear
circuits called small-signal analysis in which you linearize the
components before performing phasor analysis - AC analyses of SPICE</p>
</blockquote>
<p>A sinusoid is characterized by 3 numbers, its amplitude, its phase,
and its frequency. For example <span class="math display">\[
v(t) = A\cos(\omega t + \phi) \tag{1}
\]</span> In a circuit there will be many signals but in the case of
phasor analysis they will all have the same frequency. For this reason,
the signals are characterized using only their <strong>amplitude and
phase</strong>.</p>
<p>The combination of an <strong>amplitude</strong> and
<strong>phase</strong> to describe a signal is the
<strong>phasor</strong> for that signal.</p>
<p>Thus, the phasor for the signal in <span
class="math inline">\((1)\)</span> is <span
class="math inline">\(A\angle \phi\)</span></p>
<blockquote>
<p>In general, phasors are functions of frequency</p>
</blockquote>
<p>Often it is preferable to represent a phasor using <strong>complex
numbers</strong> rather than using amplitude and phase. In this case we
represent the signal as: <span class="math display">\[
v(t) = \Re\{Ve^{j\omega t} \} \tag{2}
\]</span> where <span class="math inline">\(V=Ae^{j\phi}\)</span> is the
<strong>phasor</strong>.</p>
<blockquote>
<p><span class="math inline">\((1)\)</span> and <span
class="math inline">\((2)\)</span> are the same</p>
</blockquote>
<h3 id="phasor-model-of-a-resistor">Phasor Model of a Resistor</h3>
<p>A linear resistor is defined by the equation <span
class="math inline">\(v = Ri\)</span></p>
<p>Now, assume that the resistor current is described with the
<em>phasor</em> <span class="math inline">\(I\)</span>. Then <span
class="math display">\[
i(t) = \Re\{Ie^{j\omega t}\}
\]</span> <span class="math inline">\(R\)</span> is a real constant, and
so the voltage can be computed to be <span class="math display">\[
v(t) = R\Re\{Ie^{j\omega t}\} = \Re\{RIe^{j\omega t}\} =
\Re\{Ve^{j\omega t}\}
\]</span> where <span class="math inline">\(V\)</span> is the phasor
representation for <span class="math inline">\(v\)</span>, i.e. <span
class="math display">\[
V = RI
\]</span></p>
<ol type="1">
<li><p>Thus, given the <em>phasor</em> for the current we can directly
compute the <em>phasor</em> for the voltage across the
resistor.</p></li>
<li><p>Similarly, given the <em>phasor</em> for the voltage across a
resistor we can compute the <em>phasor</em> for the current through the
resistor using <span class="math inline">\(I =
\frac{V}{R}\)</span></p></li>
</ol>
<h3 id="phasor-model-of-a-capacitor">Phasor Model of a Capacitor</h3>
<p>A linear capacitor is defined by the equation <span
class="math inline">\(i=C\frac{dv}{dt}\)</span></p>
<p>Now, assume that the voltage across the capacitor is described with
the <em>phasor</em> <span class="math inline">\(V\)</span>. Then <span
class="math display">\[
v(t) = \Re\{ V e^{j\omega t}\}
\]</span> <span class="math inline">\(C\)</span> is a real constant
<span class="math display">\[
i(t) = C\Re\{\frac{d}{dt}V e^{j\omega t}\} = \Re\{j\omega C V e^{j\omega
t}\}
\]</span> The <em>phasor</em> representation for <span
class="math inline">\(i\)</span> is <span class="math inline">\(i(t) =
\Re\{Ie^{j\omega t}\}\)</span>, that is <span class="math inline">\(I =
j\omega C V\)</span></p>
<ol type="1">
<li><p>Thus, given the <em>phasor</em> for the voltage across a
capacitor we can directly compute the <em>phasor</em> for the current
through the capacitor.</p></li>
<li><p>Similarly, given the <em>phasor</em> for the current through a
capacitor we can compute the <em>phasor</em> for the voltage across the
capacitor using <span class="math inline">\(V=\frac{I}{j\omega
C}\)</span></p></li>
</ol>
<h3 id="phasor-model-of-an-inductor">Phasor Model of an Inductor</h3>
<p>A linear inductor is defined by the equation <span
class="math inline">\(v=L\frac{di}{dt}\)</span></p>
<p>Now, assume that the inductor current is described with the
<em>phasor</em> <span class="math inline">\(I\)</span>. Then <span
class="math display">\[
i(t) = \Re\{ I e^{j\omega t}\}
\]</span> <span class="math inline">\(L\)</span> is a real constant, and
so the voltage can be computed to be <span class="math display">\[
v(t) = L\Re\{\frac{d}{dt}I e^{j\omega t}\} = \Re\{j\omega L I e^{j\omega
t}\}
\]</span> The <em>phasor</em> representation for <span
class="math inline">\(v\)</span> is <span class="math inline">\(v(t) =
\Re\{Ve^{j\omega t}\}\)</span>, that is <span class="math inline">\(V =
j\omega L I\)</span></p>
<ol type="1">
<li><p>Thus, given the <em>phasor</em> for the current we can directly
compute the <em>phasor</em> for the voltage across the
inductor.</p></li>
<li><p>Similarly, given the phasor for the voltage across an inductor we
can compute the phasor for the current through the inductor using <span
class="math inline">\(I=\frac{V}{j\omega L}\)</span></p></li>
</ol>
<h3 id="impedance-and-admittance">Impedance and Admittance</h3>
<blockquote>
<p>Impedance and admittance are generalizations of resistance and
conductance.</p>
<p>They differ from resistance and conductance in that they are complex
and they vary with frequency.</p>
</blockquote>
<p>Impedance is defined to be the ratio of the <em>phasor</em> for the
voltage across the component and the current through the component:
<span class="math display">\[
Z = \frac{V}{I}
\]</span></p>
<blockquote>
<p>Impedance is a complex value. The real part of the impedance is
referred to as the resistance and the imaginary part is referred to as
the reactance</p>
</blockquote>
<p>For a linear component, admittance is defined to be the ratio of the
<em>phasor</em> for the current through the component and the voltage
across the component: <span class="math display">\[
Y = \frac{I}{V}
\]</span></p>
<blockquote>
<p>Admittance is a complex value. The real part of the admittance is
referred to as the conductance and the imaginary part is referred to as
the susceptance.</p>
</blockquote>
<h2 id="response-to-complex-exponentials">Response to Complex
Exponentials</h2>
<p>The response of an LTI system to a <strong>complex
exponential</strong> input is the same <strong>complex
exponential</strong> with only a change in <em>amplitude</em></p>
<p><span class="math display">\[\begin{align}
y(t) &amp;= H(s)e^{st} \\
H(s) &amp;= \int_{-\infty}^{+\infty}h(\tau)e^{-s\tau}d\tau
\end{align}\]</span></p>
<p>where <span class="math inline">\(h(t)\)</span> is the impulse
response of a continuous-time LTI system</p>
<blockquote>
<p><strong>convolution integral</strong> is used here</p>
</blockquote>
<p><span class="math display">\[\begin{align}
y[n] &amp;= H(z)z^n \\
H(z) &amp;= \sum_{k=-\infty}^{+\infty}h[k]z^{-k}
\end{align}\]</span></p>
<p>where <span class="math inline">\(h(n)\)</span> is the impulse
response of a discrete-time LTI system</p>
<blockquote>
<p><strong>convolution sum</strong> is used here</p>
</blockquote>
<p>The signals of the form <span class="math inline">\(e^{st}\)</span>
in continuous time and <span class="math inline">\(z^{n}\)</span> in
discrete time, where <span class="math inline">\(s\)</span> and <span
class="math inline">\(z\)</span> are <em>complex numbers</em> are
referred to as an <strong>eigenfunction</strong> of the system, and the
<em>amplitude factor</em> <span class="math inline">\(H(s)\)</span>,
<span class="math inline">\(H(z)\)</span> is referred to as the system's
<strong>eigenvalue</strong></p>
<h2 id="laplace-transform">Laplace transform</h2>
<p>One of the important applications of the Laplace transform is in the
<strong>analysis and characterization of LTI systems</strong>, which
stems directly from the <em>convolution property</em> <span
class="math display">\[
Y(s) = H(s)X(s)
\]</span> where <span class="math inline">\(X(s)\)</span>, <span
class="math inline">\(Y(s)\)</span>, and <span
class="math inline">\(H(s)\)</span> are the <em>Laplace transforms</em>
of the input, output, and impulse response of the system,
respectively</p>
<blockquote>
<p>From the response of LTI systems to complex exponentials, if the
input to an LTI system is <span class="math inline">\(x(t) =
e^{st}\)</span>, with <span class="math inline">\(s\)</span> the ROC of
<span class="math inline">\(H(s)\)</span>, then the output will be <span
class="math inline">\(y(t)=H(s)e^{st}\)</span>; i.e., <span
class="math inline">\(e^{st}\)</span> is an <em>eigenfunction</em> of
the system with <strong>eigenvalue</strong> equal to the <strong>Laplace
transform of the impulse response</strong>.</p>
</blockquote>
<h3 id="s-domain-element-models">s-Domain Element Models</h3>
<p><img src="/2023/12/23/tf-freqresp/image-20231223225541693.png"
alt="image-20231223225541693" /></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231223225609893.png"
alt="image-20231223225609893" /></p>
<h2 id="sinusoidal-steady-state-analysis">Sinusoidal Steady-State
Analysis</h2>
<blockquote>
<p>Here <strong>Sinusoidal</strong> means that source excitations have
the form <span class="math inline">\(V_s\cos(\omega t +\theta)\)</span>
or <span class="math inline">\(V_s\sin(\omega t+\theta)\)</span></p>
<p><strong>Steady state</strong> mean that all transient behavior of the
stable circuit has died out, i.e., decayed to zero</p>
</blockquote>
<p><img src="/2023/12/23/tf-freqresp/image-20231223212820547.png"
alt="image-20231223212820547" /></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231223212846596.png"
alt="image-20231223212846596" /></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231223213016508.png"
alt="image-20231223213016508" /></p>
<h2 id="s-domain-and-phasor-domain"><span
class="math inline">\(s\)</span>-domain and phasor-domain</h2>
<p>Phasor analysis is a technique to find the steady-state response when
the system input is a sinusoid. That is, phasor analysis is sinusoidal
analysis.</p>
<ul>
<li>Phasor analysis is a powerful technique with which to find the
steady-state portion of the complete response.</li>
<li>Phasor analysis does not find the transient response.</li>
<li>Phasor analysis does not find the complete response.</li>
</ul>
<blockquote>
<p>The beauty of the phasor-domain circuit is that it is described by
algebraic KVL and KCL equations with time-invariant sources, not
differential equations of time</p>
</blockquote>
<p><img src="/2023/12/23/tf-freqresp/image-20231224001422189.png"
alt="image-20231224001422189" /></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231223230739219.png"
alt="image-20231223230739219" /></p>
<blockquote>
<p>The difference here is that <em>Laplace analysis</em> can also give
us the <strong>transient response</strong></p>
</blockquote>
<p><img src="/2023/12/23/tf-freqresp/image-20231224132406755.png"
alt="image-20231224132406755" /></p>
<h3 id="general-response-classifications">General Response
Classifications</h3>
<p><img src="/2023/12/23/tf-freqresp/image_2_2_4.png" alt="img" /></p>
<ul>
<li><p><strong>zero-input response</strong>, <strong>zero-state
response</strong> &amp; <strong>complete response</strong></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231223235252850.png"
alt="image-20231223235252850" /></p>
<blockquote>
<p>The <em>zero-state response</em> is given by <span
class="math inline">\(\mathscr{L^1}[H(s)F(s)]\)</span>, for the
arbitrary <span class="math inline">\(s\)</span>-domain input <span
class="math inline">\(F(s)\)</span></p>
<p>where <span class="math inline">\(Z_L(s) = sL\)</span>, the inductor
with zero initial current <span class="math inline">\(i_L(0)=0\)</span>
and <span class="math inline">\(Z_C(s)=1/sC\)</span> with zero initial
voltage <span class="math inline">\(v_C(0)=0\)</span></p>
</blockquote></li>
<li><p><strong>transient response</strong> &amp; <strong>steady-state
response</strong></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231224000454014.png"
alt="image-20231224000454014" /></p></li>
<li><p><strong>natural response</strong> &amp; <strong>forced
response</strong></p>
<p><img src="/2023/12/23/tf-freqresp/image-20231224000817438.png"
alt="image-20231224000817438" /></p></li>
</ul>
<hr />
<p><img src="/2023/12/23/tf-freqresp/image-20240118212304219.png"
alt="image-20240118212304219" /></p>
<h2 id="transfer-functions-and-frequency-response">Transfer Functions
and Frequency Response</h2>
<h3 id="transfer-function">transfer function</h3>
<p>The <strong>transfer function</strong> <span
class="math inline">\(H(s)\)</span> is the ratio of the <em>Laplace
transform</em> of the output of the system to its input <strong>assuming
all zero initial conditions</strong>.</p>
<p><img src="/2023/12/23/tf-freqresp/image-20240106185523937.png"
alt="image-20240106185523937" /></p>
<p><img src="/2023/12/23/tf-freqresp/image-20240106185937270.png"
alt="image-20240106185937270" /></p>
<h3 id="frequency-response">frequency response</h3>
<p>An immediate consequence of <em>convolution</em> is that an input of
the form <span class="math inline">\(e^{st}\)</span> results in an
output <span class="math display">\[
y(t) = H(s)e^{st}
\]</span> where the specific constant <span
class="math inline">\(s\)</span> may be complex, expressed as <span
class="math inline">\(s = \sigma + j\omega\)</span></p>
<p>A very common way to use the <em>exponential response</em> of LTIs is
in finding the <strong>frequency response</strong> i.e. <strong>response
to a sinusoid</strong></p>
<p>First, we express the <em>sinusoid</em> as a sum of two
<em>exponential expressions</em> (Euler’s relation): <span
class="math display">\[
\cos(\omega t) = \frac{1}{2}(e^{j\omega t}+e^{-j\omega t})
\]</span> If we let <span class="math inline">\(s=j\omega\)</span>, then
<span class="math inline">\(H(-j\omega)=H^*(j\omega)\)</span>, in polar
form <span class="math inline">\(H(j\omega)=Me^{j\phi}\)</span> and
<span class="math inline">\(H(-j\omega)=Me^{-j\phi}\)</span>. <span
class="math display">\[\begin{align}
y_+(t) &amp; = H(s)e^{st}|_{s=j\omega} = H(j\omega)e^{j\omega t} = M
e^{j(\omega t + \phi)} \\
y_-(t) &amp; = H(s)e^{st}|_{s=-j\omega} = H(-j\omega)e^{-j\omega t} = M
e^{-j(\omega t + \phi)}
\end{align}\]</span></p>
<p>By <em>superposition</em>, the response to the sum of these two
exponentials, which make up the cosine signal, is the sum of the
responses <span class="math display">\[\begin{align}
y(t) &amp;= \frac{1}{2}[H(j\omega)e^{j\omega t} + H(-j\omega)e^{-j\omega
t}] \\
&amp;= \frac{M}{2}[e^{j(\omega t + \phi)} + e^{-j(\omega t + \phi)}] \\
&amp;= M\cos(\omega t + \phi)
\end{align}\]</span></p>
<p>where <span class="math inline">\(M = |H(j\omega|\)</span> and <span
class="math inline">\(\phi = \angle H(j\omega)\)</span></p>
<blockquote>
<p>This means if a system represented by the transfer function <span
class="math inline">\(H(s)\)</span> has a <em>sinusoidal input</em>, the
output will be <em>sinusoidal</em> at the same frequency with magnitude
<span class="math inline">\(M\)</span> and will be shifted in phase by
the angle <span class="math inline">\(\phi\)</span></p>
</blockquote>
<h3 id="laplace-transform-fourier-transform">Laplace transform &amp;
Fourier transform</h3>
<ul>
<li>Laplace transforms such as <span
class="math inline">\(Y(s)=H(s)U(s)\)</span> can be used to study the
<strong>complete response characteristics</strong> of systems, including
the <em>transient response</em>—that is, the time response to <em>an
initial condition</em> or <em>suddenly applied signal</em></li>
<li>This is in contrast to the use of <em>Fourier transforms</em>, which
<strong>only take into account the steady-state response</strong></li>
</ul>
<p>Given a general linear system with transfer function <span
class="math inline">\(H(s)\)</span> and an input signal <span
class="math inline">\(u(t)\)</span>, the procedure for determining <span
class="math inline">\(y(t)\)</span> using the <em>Laplace transform</em>
is given by the following steps:</p>
<p><img src="/2023/12/23/tf-freqresp/image-20240106224403401.png"
alt="image-20240106224403401" /></p>
<h2 id="reference">reference</h2>
<p>Ken Kundert. <a
href="http://www.designers-guide.org/Theory/phasors.pdf">Introduction to
Phasors</a>. <em>Designer’s Guide Community</em>. September 2011.</p>
<p>How to Perform Linearity Circuit Analysis [<a
href="https://resources.pcb.cadence.com/blog/2021-how-to-perform-linearity-circuit-analysis">https://resources.pcb.cadence.com/blog/2021-how-to-perform-linearity-circuit-analysis</a>]</p>
<p>Stephen P. Boyd. EE102 Lecture 7 Circuit analysis via Laplace
transform <a
href="https://web.stanford.edu/~boyd/ee102/laplace_ckts.pdf">[https://web.stanford.edu/~boyd/ee102/laplace_ckts.pdf]</a></p>
<p>Cheng-Kok Koh, EE695K VLSI Interconnect, S-Domain Analysis [<a
href="https://engineering.purdue.edu/~chengkok/ee695K/lec3c.pdf">https://engineering.purdue.edu/~chengkok/ee695K/lec3c.pdf</a>]</p>
<p>Kenneth R. Demarest, Circuit Analysis using Phasors, Laplace
Transforms, and Network Functions [<a
href="https://people.eecs.ku.edu/~demarest/212/Phasor%20and%20Laplace%20review.pdf">https://people.eecs.ku.edu/~demarest/212/Phasor%20and%20Laplace%20review.pdf</a>]</p>
<p>DeCarlo, R. A., &amp; Lin, P.-M. (2009). <em>Linear circuit
analysis : time domain, phasor, and Laplace transform approaches</em>
(3rd ed).</p>
<p>Davis, Artice M.. "Linear Circuit Analysis." <em>The Electrical
Engineering Handbook - Six Volume Set</em> (1998)</p>
<p>Duane Marcy, Fundamentals of Linear Systems [<a
href="http://lcs-vc-marcy.syr.edu:8080/Chapter22.html">http://lcs-vc-marcy.syr.edu:8080/Chapter22.html</a>]</p>
<p><em>Gene F. Franklin, J. David Powell, and Abbas Emami-Naeini. 2018.
Feedback Control of Dynamic Systems (8th Edition) (8th. ed.).
Pearson.</em></p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
  <entry>
    <title>刹那</title>
    <url>/2009/05/20/thinking/</url>
    <content><![CDATA[<h2 id="爱">爱</h2>
<blockquote>
<p><strong>自然</strong>，<strong>自信</strong>，<strong>坚定</strong></p>
<p><strong>坦诚</strong>，<strong>真诚</strong>，
<strong>善良</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sun Jun  2 11:34:09 PM CST 2024</span><br><span class="line">反思过错，舔舐伤口，再毫无保留地，勇敢地去爱</span><br><span class="line"></span><br><span class="line">Sun Jun  9 06:51:28 PM CST 2024</span><br><span class="line">释怀了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">体会了后悔和遗憾，才会明白，人生的出场顺序有多重要 。</span><br></pre></td></tr></table></figure>
<p>​ [<a
href="https://www.zhihu.com/question/341872732/answer/801124328">-知乎</a>]</p>
<h3 id="圆桌派-第三季ep24-失恋-失恋是一种病">【圆桌派 第三季】EP24 |
失恋: 失恋是一种病</h3>
<blockquote>
<p>[<a
href="https://youtu.be/ofMDWwS2X38?si=u7SCPsyFBomgPgrh">https://youtu.be/ofMDWwS2X38?si=u7SCPsyFBomgPgrh</a>]</p>
</blockquote>
<p>我永远不能把我的快乐寄托在另一个人的合作上——窦文涛</p>
<p>每当有人问起，为什么我不恋爱的时候，我都以麻烦为由搪塞过去。又有人开始问我到底喜欢过谁没有，我也轻描淡写地表示否定。无数的朋友告诉我，或许是你还没碰到过真正喜欢的人吧，我却没法开口告诉他们，其实我曾经碰到过，碰得太早，以至于我没来得及分清，也没来得及弄明白——jasonwang524</p>
<h3 id="圆桌派-第三季ep04-爱哭-何时你变得爱哭了">【圆桌派 第三季】EP04 |
爱哭: 何时你变得爱哭了</h3>
<blockquote>
<p>[<a
href="https://youtu.be/oZlSd0PNhfA?si=ofTfMxk1m1MhD6AS">https://youtu.be/oZlSd0PNhfA?si=ofTfMxk1m1MhD6AS</a>]</p>
</blockquote>
<h3 id="圆桌派-第四季ep27-分手拒绝的理由">【圆桌派 第四季】EP27 |
分手:拒绝的理由</h3>
<blockquote>
<p>[<a
href="https://youtu.be/ovZQxSBsCMs?si=ELqoeSawVY06pHSs">https://youtu.be/ovZQxSBsCMs?si=ELqoeSawVY06pHSs</a>]</p>
</blockquote>
<p>成熟的人，处事不会用人情来胁迫人家。预留人家say no
的权利，也是對别人的尊重。——Rebecca Liang</p>
<p>爱哪有那么多解释，无非是心底的那片温柔属于某个人而已 ——White
Whale</p>
<h3 id="恋爱必修课">恋爱必修课</h3>
<blockquote>
<p>[<a
href="https://learn.lianglianglee.com/%E6%81%8B%E7%88%B1%E5%BF%85%E4%BF%AE%E8%AF%BE">https://learn.lianglianglee.com/%E6%81%8B%E7%88%B1%E5%BF%85%E4%BF%AE%E8%AF%BE</a>]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一条：再差的目标，也胜过没有目标。</span><br><span class="line"></span><br><span class="line">    但你不能不知道自己到底要什么，也不能什么都想要。</span><br><span class="line"></span><br><span class="line">    其实，最痛苦的就是这种半吊子。半吊子们，既无法彻底坚持理想主义，搞纯粹的爱情，又无法彻底向功利主义低	头，去做现实的奴隶，他们站在此岸望彼岸，两头不靠岸。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二条：再好的目标，也得服从人生目标</span><br><span class="line"></span><br><span class="line">    因为，再好的恋爱目标，也要服从于人生目标。</span><br><span class="line">    爱情就是一场自我修炼，找对象其实也是在找寻自我。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">第三条：恋爱目标，要以我为主</span><br><span class="line"></span><br><span class="line">    这个好，也可以是视野的开阔，为了一个人，去到了从未踏足的地方，见到了从未看过的风景，吃到了从未尝试的美食，多了以前想象不到的人生体验，这非常美好。</span><br><span class="line"></span><br><span class="line">    这个好，还可以是情感能力的提升，学会了如何爱一个人，也学会了如何享受被爱，明白了如何在习惯的生活中接纳一段亲密关系，这都是宝贵的财富。只有当你把恋爱的出发点和落脚点转回到自己身上时，你才会发现很多困扰自己的问题，都不再是问题。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">痛痛快快地勇敢追求心中所爱，成了，你抱得美人归；没成，你也可以昂首挺胸走出这段关系。任何人挑不出你毛病，拒绝你追求的姑娘，也得给你点个赞：“是个坦荡人”。</span><br><span class="line"></span><br><span class="line">最糟糕的就是爱情中黏黏糊糊的人，当断不断、循环往复、来来回回、不清不楚，既浪费自己的时间，也浪费他人的时间。</span><br><span class="line"></span><br><span class="line">所以，破局之道的第一要点就是，你要先改变自己这个状态，千万不要因为对方可能喜欢你，你才去喜欢人家，你最需要做的不是焦虑对方是否喜欢你，而是要确定自己是否喜欢对方。确定了这一点之后，我们才可以进入下一个环节。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在恋爱中，永远要做个善良的人，这比恋爱更加重要。</span><br><span class="line"></span><br><span class="line">也许，你发现了，我给被动等待的人的建议是，别太被动；我给主动出击的人的建议是，别太主动。这看似朴实无华的道理，蕴藏了深意，总结就是：既不刻意讨好，也不掩饰喜欢。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">真心爱慕和蓄意撩拨，完全不同。真正的喜欢，是一片赤诚的坦然相对，是自然而然的真情流露，是不加修饰的一尘不染，你根本不会有丝毫犹豫就能确定。</span><br><span class="line"></span><br><span class="line">而人总是想给自己留一点余地，你明知道对方大概率不是特别喜欢自己，但想作弊看看对方的底牌，然后我再考虑在这个爱情的赌桌上加注，所以要反复猜测对方到底有多喜欢自己。</span><br><span class="line"></span><br><span class="line">但是，要记住，找一个人谈恋爱绝不是因为这个人在暗暗喜欢你，而必须是因为你足够喜欢这个人。因为足够喜欢，所以勇敢，这种勇敢不是直勾勾地表白，也不是惨兮兮地跪舔，而是坚持自我、展现自我、享受自我的过程。</span><br></pre></td></tr></table></figure>
<h2 id="诗词曲">诗词曲</h2>
<h3 id="纳兰容若">纳兰容若</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浣溪沙</span><br><span class="line"></span><br><span class="line">谁念西风独自凉， 萧萧黄叶闭疏窗。 沉思往事立残阳。</span><br><span class="line">被酒莫惊春睡重， 赌书消得泼茶香。 当时只道是寻常。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">木兰花令</span><br><span class="line"></span><br><span class="line">人生若只如初见， 何事秋风悲画扇。 等闲变却故人心， 却道故人心</span><br><span class="line">易变。</span><br></pre></td></tr></table></figure>
<h3 id="李白">李白</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将进酒</span><br><span class="line"></span><br><span class="line">君不见黄河之水天上来， 奔流到海不复回。</span><br><span class="line">君不见高堂明镜悲白发， 朝如青丝暮成雪。</span><br><span class="line">人生得意须尽欢， 莫使金樽空对月。</span><br><span class="line">天生我材必有用， 千金散尽还复来。</span><br><span class="line">烹羊宰牛且为乐， 会须一饮三百杯。</span><br><span class="line">岑夫子， 丹丘生， 将进酒， 杯莫停。</span><br><span class="line">与君歌一曲， 请君为我倾耳听。</span><br><span class="line">钟鼓馔玉不足贵， 但愿长醉不复醒。</span><br><span class="line">古来圣贤皆寂寞， 惟有饮者留其名。</span><br><span class="line">陈王昔时宴平乐， 斗酒十千恣欢谑。</span><br><span class="line">主人何为言少钱， 径须沽取对君酌。</span><br><span class="line">五花马， 千金裘，</span><br><span class="line">呼儿将出换美酒， 与尔同销万古愁。</span><br></pre></td></tr></table></figure>
<h3 id="辛弃疾">辛弃疾</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">破阵子</span><br><span class="line"></span><br><span class="line">醉里挑灯看剑， 梦回吹角连营。 八百里分麾下炙， 五十弦翻塞外</span><br><span class="line">声。 沙场秋点兵。</span><br><span class="line">马作的卢飞快， 弓如霹雳弦惊。 了却君王天下事， 赢得生前身后</span><br><span class="line">名。 可怜白发生！</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水调歌头·和马叔度游月波楼</span><br><span class="line"></span><br><span class="line">唤起一天明月，照我满怀冰雪，浩荡百川流。鲸饮未吞海，剑气已横秋。</span><br></pre></td></tr></table></figure>
<h3 id="刘过">刘过</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唐多令</span><br><span class="line"></span><br><span class="line">芦叶满汀洲。</span><br><span class="line">塞沙带浅流。</span><br><span class="line">二十年、重过南楼。</span><br><span class="line">柳下系舟犹未稳，能几日、又中秋。</span><br><span class="line">黄鹤断矶头。</span><br><span class="line">故人今不在。</span><br><span class="line">旧江山，浑是新愁。</span><br><span class="line">欲买桂花同载酒，终不是、少年游。</span><br></pre></td></tr></table></figure>
<h3 id="岳飞">岳飞</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">满江红</span><br><span class="line"></span><br><span class="line">怒发冲冠， 凭栏处、 潇潇雨歇。 抬望眼， 仰天长啸， 壮怀激烈。 </span><br><span class="line">三十功名尘与土， 八千里路云和月。 莫等闲， 白了少年头， 空悲切。</span><br><span class="line">靖康耻， 犹未雪。 臣子恨， 何时灭。 驾长车踏破， 贺兰山缺。 </span><br><span class="line">壮志饥餐胡虏肉， 笑谈渴饮匈奴血。 待从头、 收拾旧山河， 朝天阙。</span><br></pre></td></tr></table></figure>
<h3 id="元好问">元好问</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">摸鱼儿</span><br><span class="line"></span><br><span class="line">问世间，情为何物， 直教生死相许？</span><br><span class="line">天南地北双飞客， 老翅几回寒暑。</span><br><span class="line">欢乐趣， 离别苦， 就中更有痴儿女。</span><br><span class="line">君应有语， 渺万里层云， 千山暮雪， 只影向谁去？</span><br><span class="line"></span><br><span class="line">横汾路， 寂寞当年箫鼓， 荒烟依旧平楚。</span><br><span class="line">招魂楚些何嗟及， 山鬼暗啼风雨。</span><br><span class="line">天也妒， 未信与， 莺儿燕子俱黄土。</span><br><span class="line">千秋万古， 为留待骚人， 狂歌痛饮， 来访雁丘处。</span><br></pre></td></tr></table></figure>
<h2 id="阿德勒">阿德勒</h2>
<h3 id="被讨厌的勇气">被讨厌的勇气</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。</span><br></pre></td></tr></table></figure>
<h2 id="悉达多">悉达多</h2>
<h3 id="沙门">沙门</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一切欲望、幸福和优美皆为虚幻。一切都在腐朽。世界是苦涩的。生活即是折磨。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">悉达多唯一的目标是堕入空无。无渴慕，无愿望，无梦想。无喜无悲。“我”被去除，不复存在。让空洞的心灵觅得安宁，在无“我”的深思中听便奇迹。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乔文达道：“你这样说，哦，朋友，你当然知道，悉达多不是驱牛车夫，沙门也不是酒鬼。酗酒者可以被麻醉，他可以获得短暂的逃避和休憩，但当他从幻觉中醒来时会发现一切依旧。他没有成为智者，没有积累知识，也没有进入更高的境界。”</span><br></pre></td></tr></table></figure>
<h3 id="乔达摩">乔达摩</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这就是我为何要继续我的求道之路——并非去寻找更好的法义，我知道它并不存在——而是为摆脱所有圣贤及法义，独自去实现我的目标，或者去幻灭。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您通过探索，求道，通过深观，禅修，通过认知，彻悟而非通过法义修成正果！——这就是我的想法，哦，世尊，没人能通过法义得到解脱！</span><br></pre></td></tr></table></figure>
<h3 id="乔文达">乔文达</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">知识可以传授，智慧却不能</span><br></pre></td></tr></table></figure>
<h2 id="小心思">小心思</h2>
<blockquote>
<p><strong>我还没想好，就跟他说了不合适，做朋友</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标准的“鸡肋”心态。</span><br><span class="line">条件满意，但看着提不起性欲。</span><br><span class="line">立刻放弃吧，不甘心对方这么好的条件。</span><br><span class="line">立刻同意吧，自己又说服不了自己。</span><br><span class="line">要不就等等吧，看后面会不会出现更好的。</span><br></pre></td></tr></table></figure>
<p>[<a
href="https://www.zhihu.com/question/341872732/answer/2307393870">知乎1</a>]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你先想一想，到底是喜欢这个人，还是只是说条件确实不错让你觉得放弃可惜？</span><br><span class="line"></span><br><span class="line">我见过不少类似情况，因为觉得错过可惜，而回头去挽回。但是，在一起之后，又发现对方和自己想象中的那个人不一样，仅仅是因为当初自己幻想的、没有证实的一些东西误导了自己的情绪。当初的“心动”，实际上也只是自己的“不甘心、不想错过”。</span><br><span class="line"></span><br><span class="line">要知道，一个人的条件能满足你的情感诉求时（比如外貌满足你审美，比如家境满足你的安全感），这种感觉仅仅是你单方面的幻想。对方的条件匹配你的需求，不等于对方愿意满足你的需求。对方是否愿意来满足你、你是否相信对方愿意满足你，这些东西是在相处过程中慢慢建立起来的。</span><br></pre></td></tr></table></figure>
<p>[<a
href="https://www.zhihu.com/question/341872732/answer/2327863003">知乎2</a>]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;We have to dare to be ourselves, however frightening or strange that self may prove to be.&quot;</span><br><span class="line"></span><br><span class="line">― May Sarton</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The past was a lie, that memory has no return, that every spring gone by could never be recovered, and that the wildest and most tenacious love was an ephemeral truth in the end.</span><br><span class="line"></span><br><span class="line">- Gabriel García Márquez&#x27;s One Hundred Years of Solitude</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Life is the most difficult exam. Many people fail because they try to copy others, withuout realizing that everyone has a different question paper</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不像考卷，所有複雜困難的問題，都能得到一個解答。真實人生裡，有些事永遠也沒有答案。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你如果不信命，这一生该有多少让你失望的事情</span><br><span class="line"></span><br><span class="line">- 王德峰</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们确认有命之后，我们的人生观才会是积极的。</span><br><span class="line"></span><br><span class="line">- 王德峰</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;We suffer more often in imagination than in reality.&quot;&quot;</span><br><span class="line"></span><br><span class="line">- Seneca</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Life can only be understood backwards; but it must be lived forwards.&quot;</span><br><span class="line"></span><br><span class="line">- Soren Kierkegaard</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;But man is not made for defeat… A man can be destroyed but not defeated.&quot;</span><br><span class="line"></span><br><span class="line">- The Old Man and The Sea, 1952</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">知不可奈何而安之若命，唯有德者能之。</span><br><span class="line">- 庄子·德充符</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我有一种哲学，就是不为过去所做的事情后悔。只是设法记住你当时为什么做出那样的决定。</span><br><span class="line"></span><br><span class="line">I have a philosophy that it doesn&#x27;t do any good to go and make regrets about what you did before but to try to remember how you made the decision at the time.</span><br><span class="line"></span><br><span class="line">										——Richard P. Feynman, Perfectly Reasonable Deviations from the Beaten Track, p. 421</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The healthier strategy for controlling the fear of failure is to redefine the meaning of your mistakes. </span><br><span class="line"></span><br><span class="line">People with low self-esteem consider mistakes to be an indication of a general lack of worth. Each error reaffirms their underlying belief that something is terribly wrong with them. </span><br><span class="line"></span><br><span class="line">In chapter 10, on handling mistakes, you will explore one of the fundamental laws of human nature: that you always choose actions that seem most likely to meet your needs based on current awareness. You make the best decision you can at any point in time, given what you know and what you want. </span><br><span class="line"></span><br><span class="line">The secret to coping with any failure is to recognize that each decision you&#x27;ve made was the very best one available under the circumstances.</span><br><span class="line"></span><br><span class="line">- Self-Esteem Fourth edition</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>TLM</title>
    <url>/2022/04/03/tlm/</url>
    <content><![CDATA[<p><img src="/2022/04/03/tlm/image-20220403094350570.png"
alt="image-20220403094350570" /></p>
<p><img src="/2022/04/03/tlm/image-20220403094404891.png"
alt="image-20220403094404891" /></p>
<ul>
<li><strong>Blocking methods</strong> are defined with
<code>get()</code> or <code>put()</code> <strong>tasks</strong> to allow
them to consume time</li>
<li><strong>Non-blocking methods</strong> are defined with
<code>try_get()</code> or <code>try_put()</code>
<strong>functions</strong> as they execute in zero time</li>
</ul>
<h2 id="uni-directional-tlm-methods-reference">Uni-Directional TLM
Methods Reference</h2>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 51%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Method</strong></th>
<th><strong>Description</strong></th>
<th><strong>Syntax</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>put()</code></td>
<td>Blocking put</td>
<td><code>virtual task put(iput TR t);</code></td>
</tr>
<tr class="even">
<td><code>try_put()</code></td>
<td>Nonblocking put<br />-return 1 if successful<br />-return 0 if
not</td>
<td><code>virtual function bit try_put(input TR t);</code></td>
</tr>
<tr class="odd">
<td><code>can_put()</code></td>
<td>Nonblocking test put<br />-return 1 if put would be
successful<br />-return 0 if not</td>
<td><code>virtual function bit can_put();</code></td>
</tr>
<tr class="even">
<td><code>get()</code></td>
<td>Blocking get</td>
<td><code>virtual task get(output TR t);</code></td>
</tr>
<tr class="odd">
<td><code>try_get()</code></td>
<td>Nonblocking get<br />-return 1 if successful<br />-return 0 if
not</td>
<td><code>virtual function bit try_get(output TR t);</code></td>
</tr>
<tr class="even">
<td><code>can_get()</code></td>
<td>Nonblocking test get<br />-return 1 if get would be
successful<br />-return 0 if not</td>
<td><code>virtual function bit can_get();</code></td>
</tr>
<tr class="odd">
<td><code>peek()</code></td>
<td>Blocking peek</td>
<td><code>virtual task peek(output TR t);</code></td>
</tr>
<tr class="even">
<td><code>try_peek()</code></td>
<td>Nonblocking peek<br />-return 1 if successful<br />-return 0 if
not</td>
<td><code>virtual function bit try_peek(output TR t);</code></td>
</tr>
<tr class="odd">
<td><code>can_peek</code></td>
<td>Nonblocking test peek<br />-return 1 if peek would be
successful<br />-return 0 if not</td>
<td><code>virtual function bit can_peek();</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>The <code>peek()</code> methods are similarly to the
<code>get()</code> methods, but <strong>copy</strong> the transaction
instead of <strong>removing</strong> it. The transaction is not
consumed, and a subsequent <code>get</code> or <code>peek</code>
operation will return the <em>same</em> transaction</p>
</blockquote>
<h2 id="selected-connector-and-method-options">Selected Connector and
Method Options</h2>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 6%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><code>put</code></th>
<th><code>try_put</code></th>
<th><code>can_put</code></th>
<th><code>get</code></th>
<th><code>try_get</code></th>
<th><code>can_get</code></th>
<th><code>peek</code></th>
<th><code>try_peed</code></th>
<th><code>can_peek</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>uvm_put_*</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>uvm_blocking_put_*</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>uvm_nonblocking_put_*</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>uvm_get_*</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>uvm_blocking_get_*</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>uvm_nonblocking_get_*</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>uvm_get_peek_*</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>uvm_blocking_get_peek_*</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>uvm_nonblocking_get_peek_*</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<blockquote>
<p>in the connectors above, <code>*</code> can be replaced by
<code>port</code>, <code>imp</code>, or <code>export</code></p>
<p>All the methods for a specific connector type <strong>MUST</strong>
be implemented. If you define an <code>uvm_put</code> connection between
two compoents, then the component with the <code>uvm_put_imp</code>
object must provide implementations of <strong>ALL</strong> three put
methods, <code>put</code>, <code>try_put</code> and
<code>can_put</code>, even if these methods are not explicitly
called</p>
</blockquote>
<h2 id="tlm-fifo">TLM FIFO</h2>
<p>The TLM FIFO is a FIFO component wrapped in <code>get</code> and
<code>put</code> <code>imp</code> connectors. This has the benefit of
data storage as well as providing implementations of the communication
methods. Components connected to the TLM FIFO are in control of data
transfer and can simply defined port connectors to initiate read and
write operations on the FIFO</p>
<h3 id="uvm_tlm_fifo">uvm_tlm_fifo</h3>
<p><img src="/2022/04/03/tlm/image-20220403141222126.png"
alt="image-20220403141222126" /></p>
<p>The TLM FIFO object is effectively a FIFO component instantiated
between and connected to two components. The FIFO contains
<code>imp</code> connectors for the standard TLM <code>put</code> and
<code>get</code>/<code>peek</code> interfaces, therefore the user does
not have to define<code>imp</code> ports or communication methods and
the FIRO takes care of data storage</p>
<p>The advantages are:</p>
<ul>
<li>The user does not need to define communication methods or
<code>imp</code> connectors</li>
<li>The FIFO provides data storage between the <code>write</code>
(<code>put</code>) and <code>read</code>
(<code>get</code>/<code>peek</code>) components</li>
<li>There are a number of built-in methods for checking FIFO status</li>
</ul>
<p>The disadvantages are:</p>
<ul>
<li>The user must now initiate both sides of the transfer (both
<code>get</code>/<code>peek</code> and <code>put</code>) to complete the
transaction</li>
<li>Two connections must be made (both sides of the FIFO) rather than
one</li>
</ul>
<p>The <code>put_export</code> and <code>get_peek_export</code>
connection objects have alternatives which provide subsets of the full
connector. For example, <code>blocking_put_export</code> and
<code>nonblocking_put_export</code> can replace <code>put_export</code>.
<code>blocking_get_export</code>, <code>nonblocking_get_export</code>
and <code>get_export</code> (as well as others) can replace
<code>get_peek_export</code>.</p>
<h4 id="built-in-methods">built-in methods</h4>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
<th>Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>new</code></td>
<td>Standard component constructor with an additional third argument,
<code>size</code>, which sets the maximum FIFO size. Default size is 1.
A size of <strong>0</strong> is an unbounded FIFO</td>
<td><code>function new(string name, uvm_component parent=null, int size=1);</code></td>
</tr>
<tr class="even">
<td><code>size</code></td>
<td>Return size of FIFO. <strong>0</strong> indicates unbounded
FIFO</td>
<td><code>virtual function int size()</code></td>
</tr>
<tr class="odd">
<td><code>used</code></td>
<td>Return number of entries written to the FIFO</td>
<td><code>virtual function int used();</code></td>
</tr>
<tr class="even">
<td><code>is_empty</code></td>
<td>Return <strong>1</strong> if <code>used()</code> is 0, otherwise
<strong>0</strong></td>
<td><code>virtual function bit is empty();</code></td>
</tr>
<tr class="odd">
<td><code>is_full</code></td>
<td>Return 1 if <code>used()</code> is equal to <code>size</code>,
otherwise <strong>0</strong></td>
<td><code>virtual function bit is_full()</code></td>
</tr>
<tr class="even">
<td><code>flush</code></td>
<td>Delete all entries from the FIFO, upon which <code>used()</code> is
<strong>0</strong> and <code>is_empty()</code> is
<strong>1</strong></td>
<td><code>virtual funciton void flush();</code></td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_tlm_fifo <span class="variable">#(type T=int) extends uvm_tlm_fifo_base #(T)</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span>    </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">class</span> uvm_tlm_fifo_base <span class="variable">#(type T=int)</span> <span class="keyword">extends</span> uvm_component;</span><br><span class="line">    uvm_put_imp <span class="variable">#(T, this_type)</span> put_export;</span><br><span class="line">    </span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> get_peek_export;</span><br><span class="line">    </span><br><span class="line">    uvm_analysis_port <span class="variable">#(T)</span> put_ap;</span><br><span class="line">    </span><br><span class="line">    uvm_analysis_port <span class="variable">#(T)</span> get_ap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following are aliases to the above put_export</span></span><br><span class="line">    uvm_put_imp      <span class="variable">#(T, this_type)</span> blocking_put_export;</span><br><span class="line">    uvm_put_imp      <span class="variable">#(T, this_type)</span> nonblocking_put_export;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following are all aliased to the above get_peek_export, which provides</span></span><br><span class="line">    <span class="comment">// the superset of these interfaces.</span></span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> blocking_get_export;</span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> nonblocking_get_export;</span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> get_export;</span><br><span class="line">    </span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> blocking_peek_export;</span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> nonblocking_peek_export;</span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> peek_export;</span><br><span class="line">    </span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> blocking_get_peek_export;</span><br><span class="line">    uvm_get_peek_imp <span class="variable">#(T, this_type)</span> nonblocking_get_peek_export;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">        </span><br><span class="line">        put_export = <span class="keyword">new</span>(<span class="string">&quot;put_export&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        blocking_put_export     = put_export;</span><br><span class="line">        nonblocking_put_export  = put_export;</span><br><span class="line">        </span><br><span class="line">        get_peek_export = <span class="keyword">new</span>(<span class="string">&quot;get_peek_export&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        blocking_get_peek_export    = get_peek_export;</span><br><span class="line">        nonblocking_get_peek_export = get_peek_export;</span><br><span class="line">        blocking_get_export         = get_peek_export;</span><br><span class="line">        nonblocking_get_export      = get_peek_export;</span><br><span class="line">        get_export                  = get_peek_export;</span><br><span class="line">        blocking_peek_export        = get_peek_export;</span><br><span class="line">        nonblocking_peek_export     = get_peek_export;</span><br><span class="line">        peek_export                 = get_peek_export;</span><br><span class="line">        </span><br><span class="line">        put_ap = <span class="keyword">new</span>(<span class="string">&quot;put_ap&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        get_ap = <span class="keyword">new</span>(<span class="string">&quot;get_ap&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h2 id="analysis-fifo">Analysis FIFO</h2>
<h3 id="uvm_tlm_analysis_fifo">uvm_tlm_analysis_fifo</h3>
<p><img src="/2022/04/03/tlm/image-20220403144951278.png"
alt="image-20220403144951278" /></p>
<p><code>uvm_tlm_analysis_fifo</code> is a specialization of
<code>uvm_tlm_fifo</code></p>
<ul>
<li>Intended to buffer write transactions between the UVC monitor
analysis port and scoreboard</li>
</ul>
<p>It has the following characteristics:</p>
<ul>
<li>Unbounded (size=0)</li>
<li><code>analysis_export</code> connector replaces
<code>put_export</code>
<ul>
<li>Support the analysis <code>write</code> method</li>
</ul></li>
</ul>
<p><img src="/2022/04/03/tlm/image-20220403150326750.png"
alt="image-20220403150326750" /></p>
<blockquote>
<p>By declaring the FIFO in the scoreboard, we can <code>get</code>
directly from the FIFO output.</p>
<p>However the write side connection of the FIFO to the interface UVC
monitor analysis port must be made (usually) in the testbench which has
visibility of both UVC and scoreboard components. The connection is made
using a connect method call inside the connect phase method</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_tlm_analysis_fifo <span class="variable">#(type T = int) extends uvm_tlm_fifo #(T)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Port: analysis_export #(T)</span></span><br><span class="line">  <span class="comment">//  </span></span><br><span class="line">  <span class="comment">// The analysis_export provides the write method to all connected analysis</span></span><br><span class="line">  <span class="comment">// ports and parent exports:</span></span><br><span class="line">  <span class="comment">//  </span></span><br><span class="line">  <span class="comment">//|  function void write (T t)</span></span><br><span class="line">  <span class="comment">//  </span></span><br><span class="line">  <span class="comment">// Access via ports bound to this export is the normal mechanism for writing</span></span><br><span class="line">  <span class="comment">// to an analysis FIFO. </span></span><br><span class="line">  <span class="comment">// See write method of &lt;uvm_tlm_if_base #(T1,T2)&gt; for more information.</span></span><br><span class="line"></span><br><span class="line">  uvm_analysis_imp <span class="variable">#(T, uvm_tlm_analysis_fifo #(T))</span> analysis_export;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Function: new</span></span><br><span class="line">  <span class="comment">//  </span></span><br><span class="line">  <span class="comment">// This is the standard uvm_component constructor. ~name~ is the local name</span></span><br><span class="line">  <span class="comment">// of this component. The ~parent~ should be left unspecified when this</span></span><br><span class="line">  <span class="comment">// component is instantiated in statically elaborated constructs and must be</span></span><br><span class="line">  <span class="comment">// specified when this component is a child of another UVM component.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name ,  uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent, <span class="number">0</span>); <span class="comment">// analysis fifo must be unbounded</span></span><br><span class="line">    analysis_export = <span class="keyword">new</span>(<span class="string">&quot;analysis_export&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">string</span> type_name = <span class="string">&quot;uvm_tlm_analysis_fifo #(T)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">string</span> get_type_name();</span><br><span class="line">    <span class="keyword">return</span> type_name;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> write(<span class="keyword">input</span> T t); </span><br><span class="line">    <span class="keyword">void</span>&#x27;(<span class="keyword">this</span><span class="variable">.try_put</span>(t)); <span class="comment">// unbounded =&gt; must succeed</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="analysis-port-broadcast">Analysis Port Broadcast</h2>
<p><img src="/2022/04/03/tlm/image-20220403152922101.png"
alt="image-20220403152922101" /></p>
<p>Analysis ports can (uniquely) be connected to any number of
<code>imp</code> connectors, including zero</p>
<p><img src="/2022/04/03/tlm/image-20220403153148158.png"
alt="image-20220403153148158" /></p>
<p>The analysis port in component <em>yapp_monitor</em> will be
connected to both <em>monitor_one</em> and <em>monitor_two</em>
components. Each of the receiving components has an <em>analysis imp
object</em> and a write communication method declared. The write method
must have the same signature - i.e., they must be void functions called
write with a single input argument of type <em>yapp_packet</em>, but
their implementations can be completely different.</p>
<p>When the <code>send_yapp</code> port is connected to both
<em>mone_in</em> and <em>mtwo_in</em> imps, then a single write call
from <em>yapp_monitor</em> executes both write implementations in
<em>monitor_one</em> and <em>monitor_two</em></p>
<p><img src="/2022/04/03/tlm/image-20220403153742706.png"
alt="image-20220403153742706" /></p>
<p>For non-analysis connections</p>
<ul>
<li>the TLM object must be connected to a single destination only, i.e.,
each non-analysis object has exactly <strong>one</strong> connect call.
An object may be used multiple times as the <em>argument</em> to a
connect, but exactly once as the caller. This is called
<strong>many-to-one</strong> connection. For example, many ports can be
connected to a one imp connector</li>
</ul>
<p>For analysis connections</p>
<ul>
<li>a TLM object can be connected to any number of destinations i.e.,
one analysis object can call connect many times. This is called
<strong>one-to-many</strong> connection. For example, one port can be
connected to many imp connectors. <strong>one-to-many</strong> is only
allowed for analysis connections. An analysis connection can also
<em>NOT</em> call connect. An unconnected TLM object is also only
allowed for analysis connections</li>
</ul>
<h2 id="bi-directional-tlm-transport-connection">Bi-Directional TLM
Transport Connection</h2>
<p><img src="/2022/04/03/tlm/image-20220403160248099.png"
alt="image-20220403160248099" /></p>
<p>Connector syntax</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">uvm_blocking_transport_XXX <span class="variable">#(type REA, type RSP)</span></span><br><span class="line">uvm_nonblocking_transport_XXX <span class="variable">#(type REQ, type RSP)</span></span><br><span class="line">uvm_transport_XXX <span class="variable">#(type REQ, type RSP)</span></span><br></pre></td></tr></table></figure>
<p>Communication methods</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> transport(REQ request, <span class="keyword">output</span> RSP response)</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">bit</span> nb_transport(REQ request, <span class="keyword">output</span> RSP response)</span><br></pre></td></tr></table></figure>
<h2 id="gotchas">Gotchas</h2>
<p>FIFO/analysis FIFOs do not perform any cloning on input transactions.
Therefore, you will need to check that the UVC monitors collect every
transaction into a different instance to avoid overwriting data in the
FIFOs</p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>DC operating points during TRANSIENT analysis</title>
    <url>/2023/10/06/tranOP/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://community.cadence.com/members/andrew-beckett">Andrew
Beckett</a><a
href="https://community.cadence.com/cadence_technology_forums/f/rf-design/25702/finding-dc-operating-points-at-certain-timepoints-during-transient-analysis/1321796#1321796">over
11 years ago</a></p>
<p>Two approaches:</p>
<ol type="1">
<li>On the transient options form, there's a field called "infotimes" -
specify the times at which you want it to output the dc operating point
data. You can then annotate the "transient operating points" from any of
these times after the simulation, or access them via the results
browser.</li>
<li>Or you could get the operating point data to be continuously saved
during the transient for selected devices - if so, create a file called
(say) "save.scs" (make sure it has a ".scs" suffix), and put: save
M1:oppoint or save M*:oppoint sigtype=dev in this file, and then
reference the file via Setup-&gt;Model Libraries or as a "definition
file" on Setup-&gt;Simulation Files. With this approach you can then
find the operating point data for the selected devices in the results
browser and plot it versus time (be cautious of saving too much though
because this can generate a lot of data if you're not careful)</li>
</ol>
<p>Regards,</p>
<p>Andrew.</p>
</blockquote>
<p><img src="/2023/10/06/tranOP/image-20231006110801078.png"
alt="image-20231006110801078" /></p>
<h2 id="transient-options-form">transient options form</h2>
<h3 id="setup">setup</h3>
<p><img src="/2023/10/06/tranOP/image-20231006103506475.png"
alt="image-20231006103506475" /></p>
<h3 id="access-1">access 1</h3>
<p><strong>right-click</strong> <span class="math inline">\(\to\)</span>
<strong>Annotate</strong> <span class="math inline">\(\to\)</span>
<strong>Transient Operating Points</strong></p>
<p><img src="/2023/10/06/tranOP/image-20231006104317496.png"
alt="image-20231006104317496" /></p>
<h3 id="access-2">access 2</h3>
<p><strong>tranOpTimed</strong></p>
<p><img src="/2023/10/06/tranOP/image-20231006105236323.png"
alt="image-20231006105236323" /></p>
<h2 id="save.scs">save.scs</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save M0:oppoint</span><br></pre></td></tr></table></figure>
<p><img src="/2023/10/06/tranOP/image-20231006110506245.png"
alt="image-20231006110506245" /></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>PAM4 Transmitter</title>
    <url>/2022/07/20/tx-pam4/</url>
    <content><![CDATA[<h1 id="pam4-basic">PAM4 Basic</h1>
<p><strong>PAM4</strong> only have <em>1/3</em> of the amplitude
compared to <strong>NRZ</strong> <span class="math display">\[
\text{SNR loss} = 20\log(\frac{1}{3}) \sim  9.5\text{dB}
\]</span></p>
<blockquote>
<p>In practice, there is further degradation due to nonlinearity</p>
</blockquote>
<p>In a more technical terms, we trade the <strong>transmitter’s
signal-to-noise ratio (SNR)</strong> for <strong>lower Nyquist
frequency</strong></p>
<p>Equalization will be a lot more complex</p>
<h2 id="pam4-level-names">PAM4 Level Names</h2>
<p><img src="/2022/07/20/tx-pam4/image-20220717000655620.png"
alt="image-20220717000655620" /></p>
<h2 id="pam4-eye-linearity">PAM4 Eye Linearity</h2>
<p><img src="/2022/07/20/tx-pam4/image-20220716221740224.png"
alt="image-20220716221740224" /></p>
<p>Each level can have different amplitudes, which form the <strong>Eye
Linearity</strong> <span class="math display">\[
{\text{Eye
Linearity}}=\frac{\min(AV_{\text{upp}},AV_{\text{mid}},AV_{\text{low}})}{\max(AV_{\text{upp}},AV_{\text{mid}},AV_{\text{low}})}
\]</span></p>
<blockquote>
<p>Perfect eye = 1</p>
<p>Worst eye = 0</p>
</blockquote>
<h2 id="transmitter-linearity-rlm">Transmitter Linearity (RLM)</h2>
<p>The <strong>Level Separation Mismatch Ratio</strong>, commonly
referred to as <span class="math inline">\(R_{\text{LM}}\)</span>, is a
measurement that is not required in normative or informative VSR tests,
but is required by most other variants.</p>
<p><img src="/2022/07/20/tx-pam4/image-20220716223452261.png"
alt="image-20220716223452261" /></p>
<p><span class="math display">\[\begin{align}
V_{\text{mid}} &amp;= \frac{V_0+V_3}{2} \\
ES1 &amp;= \frac{V_1-V_{\text{mid}}}{V_0-V_{\text{mid}}} \\
ES2 &amp;= \frac{V_2-V_{\text{mid}}}{V_3-V_{\text{mid}}} \\
R_{\text{LM}} &amp;= \min(3\times ES1, 3\times ES2, 2-3\times ES1,
2-3\times ES2)
\end{align}\]</span></p>
<p>where <em>ES</em> means <em>Effective Symbol Level</em></p>
<blockquote>
<p><span class="math inline">\(R_{\text{LM}}\)</span> is conceptually
similar to eye linearity but measured differently. An ideal PAM4 eye has
<span class="math inline">\(R_{\text{LM}}\)</span> equal to
<strong>1</strong>, but it does not scale in the same way as eye
linearity.</p>
<p>The closer <span class="math inline">\(R_{\text{LM}}\)</span> is to
<strong>1</strong>, the better the eye linearity is.</p>
</blockquote>
<h2 id="gray-coding">Gray Coding</h2>
<p>Gray code or reflected binary code was designed so that two
successive values differ by one bit</p>
<p>Reducing the number of switching</p>
<table>
<thead>
<tr class="header">
<th>Linear Code</th>
<th>Gray Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>11</td>
<td>10</td>
</tr>
<tr class="even">
<td>10</td>
<td>11</td>
</tr>
<tr class="odd">
<td>01</td>
<td>01</td>
</tr>
<tr class="even">
<td>00</td>
<td>00</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>Only one bit error per symbol is made for incorrect decisions</li>
<li>This is the coding adopted in all the PAM4 standards</li>
<li>Support dual-mode with PAM2, by grounding the LSB</li>
<li>MSB is the bit transmitted first</li>
</ul>
</blockquote>
<h3 id="binary-to-pam4-and-back-to-binary-example">Binary to PAM4 and
Back to Binary Example</h3>
<p><img src="/2022/07/20/tx-pam4/image-20220717000847185.png"
alt="image-20220717000847185" /></p>
<blockquote>
<p>The way that Gray coding combines the MSB (most significant bit) and
LSB (least significant bit) in each PAM4 symbol assures that
<strong>symbol errors</strong> caused by <strong>amplitude
noise</strong> are more likely to cause <strong>one bit error than
two</strong>. On the other hand, jitter is more likely to cause two bit
errors per symbol error.</p>
</blockquote>
<h1 id="pam4-tx-equalization">PAM4 TX equalization</h1>
<p><img src="/2022/07/20/tx-pam4/image-20220717010007963.png"
alt="image-20220717010007963" /></p>
<p>Here, <span class="math inline">\(d_{\text{LSB}} \in \{-1,
1\}\)</span>, <span class="math inline">\(d_{\text{MSB}} \in \{-2,
2\}\)</span> and <span class="math inline">\(d&#39; \in \{ -3, -1, 1, 3
\}\)</span></p>
<p>Implementation-1 could potentially experience performance degradation
due to</p>
<ol type="1">
<li>Clock skew, <span class="math inline">\(\Delta t\)</span>, could
make the eye misaligned horizontally</li>
<li>Gain mismatch, <span class="math inline">\(\Delta G\)</span>, could
cause eye nonlinearity</li>
<li>Bandwidth mismatch, <span class="math inline">\(\Delta
f_{\text{BW}}\)</span>, could make the eye misaligned vertically</li>
</ol>
<p><img src="/2022/07/20/tx-pam4/image-20220717011129124.png"
alt="image-20220717011129124" /></p>
<blockquote>
<p>Typically, a 3-tap FIR (pre + main + post) TX de-emphasis is used</p>
<p>3-tap FIR results in <span class="math inline">\(4^3 = 64\)</span>
possible distinct signal levels</p>
</blockquote>
<p><img src="/2022/07/20/tx-pam4/msb_lsb.drawio.svg"
alt="msb_lsb.drawio" /></p>
<p><span class="math display">\[\begin{align}
R_U^M \parallel R_D^M &amp;= \frac{3R_T}{2}\\
R_U^L \parallel R_D^L &amp;= 3R_T
\end{align}\]</span></p>
<p>Thevenin Equivalent Circuit is <img
src="/2022/07/20/tx-pam4/thevenin_1.drawio.svg"
alt="thevenin_1.drawio" /></p>
<p>Which can be simpified as <img
src="/2022/07/20/tx-pam4/thevenin_2.drawio.svg"
alt="thevenin_2.drawio" /> <span class="math display">\[\begin{align}
V_{\text{rx}} &amp;= \frac{1}{2}(V_p - V_m) \\
&amp;= \frac{1}{2}(\frac{2}{3}(2V_{\text{MSB}}+V_{\text{LSB}})-1) \\
&amp;=\frac{1}{3}(2V_{\text{MSB}}+V_{\text{LSB}})-\frac{1}{2}
\end{align}\]</span></p>
<p>The above eqations demonstrate that the output <span
class="math inline">\(V_{\text{rx}}\)</span> is the linear sum of
<strong>MSB</strong> and <strong>LSB</strong>; <strong>LSB</strong> and
<strong>MSB</strong> have relative weight, i.e. <em>1</em> for LSB and
<em>2</em> for MSB.</p>
<p>Assume pre cusor has <span class="math inline">\(L\)</span> legs,
main cursor <span class="math inline">\(M\)</span> legs and post cursor
<span class="math inline">\(N\)</span> legs, which is same with the
convention in "Voltage-Mode Driver Equalization"</p>
<p>The number of legs connected with supply can expressed as <span
class="math display">\[
n_{up} = (1-d_{n+1})L + d_{n}M + (1-d_{n-1})N
\]</span> Where <span class="math inline">\(d_n \in \{0, 1\}\)</span>,
or <span class="math display">\[
n_{up} = \frac{1}{2}(-D_{n+1}+1)L + \frac{1}{2}(D_{n}+1)M +
\frac{1}{2}(-D_{n-1}+1)N
\]</span> Where <span class="math inline">\(D_n \in \{-1,
+1\}\)</span></p>
<p>Then the number of legs connected with ground is <span
class="math display">\[
n_{dn}=L+M+N-n_{up}
\]</span> where <span
class="math inline">\(n_{up}+n_{dn}=L+M+N\)</span></p>
<p>Voltage resistor divider <span class="math display">\[\begin{align}
V_o &amp;=
\frac{\frac{R_{U}}{n_{dn}}}{\frac{R_U}{n_{dn}}+\frac{R_U}{n_{up}}} \\
&amp;= \frac{1}{2}- \frac{1}{2}D_{n+1}\frac{L}{L+M+N}+
\frac{1}{2}D_{n}\frac{M}{L+M+N}-\frac{1}{2}D_{n-1}\frac{N}{L+M+N} \\
&amp;= \frac{1}{2}-\frac{1}{2}D_{n+1}\cdot l+ \frac{1}{2}D_{n}\cdot
m-\frac{1}{2}D_{n-1}\cdot n
\end{align}\]</span></p>
<p>where <span class="math inline">\(l+m+n=1\)</span></p>
<p><span class="math inline">\(V_{\text{MSB}}\)</span> and <span
class="math inline">\(V_{\text{LSB}}\)</span> can be obtained</p>
<p><span class="math display">\[\begin{align}
V_{\text{MSB}} &amp;= \frac{1}{2}-\frac{1}{2}D^{\text{MSB}}_{n+1}\cdot
l+ \frac{1}{2}D^{\text{MSB}}_{n}\cdot
m-\frac{1}{2}D^{\text{MSB}}_{n-1}\cdot n \\
V_{\text{LSB}} &amp;= \frac{1}{2}-\frac{1}{2}D^{\text{LSB}}_{n+1}\cdot
l+ \frac{1}{2}D^{\text{LSB}}_{n}\cdot
m-\frac{1}{2}D^{\text{LSB}}_{n-1}\cdot n
\end{align}\]</span></p>
<p>Substitute the above equation into <span
class="math inline">\(V_{\text{rx}}\)</span>, we obtain the relationship
between driver legs and FFE coefficients</p>
<p><span class="math display">\[\begin{align}
V_{\text{rx}}
&amp;=\frac{1}{3}(2V_{\text{MSB}}+V_{\text{LSB}})-\frac{1}{2} \\
&amp;= \frac{1}{3} \left\{  2\left(
\frac{1}{2}-\frac{1}{2}D^{\text{MSB}}_{n+1}\cdot l+
\frac{1}{2}D^{\text{MSB}}_{n}\cdot m-
\frac{1}{2}D^{\text{MSB}}_{n-1}\cdot n \right) + \left(
\frac{1}{2}-\frac{1}{2}D^{\text{LSB}}_{n+1}\cdot l+
\frac{1}{2}D^{\text{LSB}}_{n}\cdot m-
\frac{1}{2}D^{\text{LSB}}_{n-1}\cdot n \right) \right\}-\frac{1}{2} \\
&amp;=  \left(-\frac{l}{6} \cdot 2 \cdot D^{\text{MSB}}_{n+1}+
\frac{m}{6} \cdot 2 \cdot D^{\text{MSB}}_{n}- \frac{n}{6} \cdot 2 \cdot
D^{\text{MSB}}_{n-1}\right) + \left(-\frac{l}{6} \cdot
D^{\text{LSB}}_{n+1}+ \frac{m}{6} \cdot D^{\text{LSB}}_{n}- \frac{n}{6}
\cdot D^{\text{LSB}}_{n-1}\right) \\
&amp;=  -\frac{l}{6}(2 \cdot D^{\text{MSB}}_{n+1}+D^{\text{LSB}}_{n+1})+
\frac{m}{6}(2\cdot D^{\text{MSB}}_{n}+D^{\text{LSB}}_{n})
-\frac{n}{6}(2\cdot D^{\text{MSB}}_{n-1}+D^{\text{LSB}}_{n-1})
\end{align}\]</span></p>
<p>After scaling, we obtain <span class="math display">\[
V_{\text{rx}}  = -l\cdot(2 \cdot
D^{\text{MSB}}_{n+1}+D^{\text{LSB}}_{n+1})+ m\cdot(2\cdot
D^{\text{MSB}}_{n}+D^{\text{LSB}}_{n}) - n \cdot(2\cdot
D^{\text{MSB}}_{n-1}+D^{\text{LSB}}_{n-1})
\]</span> Where <span class="math inline">\(C_{-1} = l\)</span>, <span
class="math inline">\(C_0 = m\)</span> and <span
class="math inline">\(C_{1}=n\)</span>, which is same with that of
NRZ.</p>
<h1 id="general-tx-serializer">General TX Serializer</h1>
<h2 id="mux-timing">mux timing</h2>
<p><img src="/2022/07/20/tx-pam4/mux2-1.drawio.svg"
alt="mux2-1.drawio" /></p>
<h2 id="divider-latch-timing">divider latch timing</h2>
<p><img src="/2022/07/20/tx-pam4/div2-latch.drawio.svg"
alt="div2-latch.drawio" /></p>
<h2 id="two-latches">Two latches</h2>
<p><img src="/2022/07/20/tx-pam4/two-latch.drawio.svg"
alt="two-latch.drawio" /></p>
<h1 id="dac-based-ffe-in-pam4-transmitter">DAC-based FFE in PAM4
Transmitter</h1>
<p><img src="/2022/07/20/tx-pam4/image-20220721220225623.png"
alt="image-20220721220225623" /></p>
<p>One classic TX implementation contain:</p>
<ul>
<li>a DAC: <strong>56GS/s</strong> <strong>8b</strong></li>
<li>a DSP: <strong>8-tap FIR</strong></li>
</ul>
<blockquote>
<p>C. Menolfi et al., "A 112Gb/S 2.6pJ/b 8-Tap FFE PAM-4 SST TX in 14nm
CMOS," 2018 IEEE International Solid - State Circuits Conference -
(ISSCC), 2018, pp. 104-106, doi: 10.1109/ISSCC.2018.8310205.</p>
</blockquote>
<p><img src="/2022/07/20/tx-pam4/image-20220721234522043.png"
alt="image-20220721234522043" /></p>
<h2 id="pi-coil"><span class="math inline">\(\pi\)</span>-coil</h2>
<p><img src="/2022/07/20/tx-pam4/image-20220720232837839.png"
alt="image-20220720232837839" /></p>
<blockquote>
<p>J. Kim et al., "A 112Gb/s PAM-4 transmitter with 3-Tap FFE in 10nm
CMOS," 2018 IEEE International Solid - State Circuits Conference -
(ISSCC), 2018, pp. 102-104, doi: 10.1109/ISSCC.2018.8310204.</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>C. Menolfi et al., "A 112Gb/S 2.6pJ/b 8-Tap FFE PAM-4 SST TX in 14nm
CMOS," 2018 IEEE International Solid - State Circuits Conference -
(ISSCC), 2018, pp. 104-106, doi: 10.1109/ISSCC.2018.8310205.</p>
<p>E. Chong et al., "A 112Gb/s PAM-4, 168Gb/s PAM-8 7bit DAC-Based
Transmitter in 7nm FinFET," ESSCIRC 2021 - IEEE 47th European Solid
State Circuits Conference (ESSCIRC), 2021, pp. 523-526, doi:
10.1109/ESSCIRC53450.2021.9567801.</p>
<p>B. Razavi, "Design Techniques for High-Speed Wireline Transmitters,"
in IEEE Open Journal of the Solid-State Circuits Society, vol. 1, pp.
53-66, 2021, doi: 10.1109/OJSSCS.2021.3112398.</p>
<p>Wang, Z., Choi, M., Lee, K., Park, K., Liu, Z., Biswas, A., Han, J.,
Du, S., &amp; Alon, E. (2022). An Output Bandwidth Optimized 200-Gb/s
PAM-4 100-Gb/s NRZ Transmitter With 5-Tap FFE in 28-nm CMOS. IEEE
Journal of Solid-State Circuits, 57(1), 21-31.
https://doi.org/10.1109/JSSC.2021.3109562</p>
<p>J. Kim et al., "A 112Gb/s PAM-4 transmitter with 3-Tap FFE in 10nm
CMOS," 2018 IEEE International Solid - State Circuits Conference -
(ISSCC), 2018, pp. 102-104, doi: 10.1109/ISSCC.2018.8310204.</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Debug topology and Check config usage in UVM</title>
    <url>/2022/02/21/uvm-debug-topology-config-usage/</url>
    <content><![CDATA[<h4 id="topology-of-the-test">Topology of the test</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> test_base::start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">	uvm_root::get()<span class="variable">.print_topology</span>(); <span class="comment">// defaults to table printer</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>The default printer policy is
<strong>uvm_default_table_printer</strong></p>
<p>There are three default printer policies that the uvm_pkg
provides:</p>
<blockquote>
<p>uvm_default_table_printer uvm_default_tree_printer
uvm_default_line_printer</p>
</blockquote>
<h4 id="check-all-configuration-settings">Check all configuration
settings</h4>
<p>Check all configuration settings in a components configuration table
to determine if the setting has been used, overridden or not used. When
<em>recurse</em> is 1 (default), configuration for this and all child
components are recursively checked. This function is automatically
called in the check phase, but can be manually called at any time.</p>
<p>To get all configuration information prior to the run phase, do
something like this in your top object:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">	check_config_usage();</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h4 id="uvm-phase">UVM phase</h4>
<p><img
src="/2022/02/21/uvm-debug-topology-config-usage/image-20220221230440017.png"
alt="image-20220221230440017" /></p>
<ul>
<li><strong>Functions</strong> are executed bottom-up (Except for
<strong>build and final phases</strong> , which are executed
top-down)</li>
<li><strong>Tasks</strong> are forked into concurrent executing
threads</li>
</ul>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>UVM project topology</title>
    <url>/2022/03/21/uvm-proj-topo/</url>
    <content><![CDATA[<p>Most user-defined UVM classes are placed in <em>separate
files</em></p>
<p>Classes can only be compiled from a <em>module</em> or <em>package
scope</em></p>
<p>Recommendation:</p>
<ul>
<li>Include related class files into a package</li>
<li>Import the package into modules where required</li>
</ul>
<p>The UVM library is supplied in the package <code>uvm_pkg</code></p>
<ul>
<li>Import package to access library</li>
<li>The macro file <code>uvm_macros.svh</code> must be included
separately</li>
</ul>
<p>yapp_packet.sv</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> yapp_packet <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span> : yapp_packet   </span><br></pre></td></tr></table></figure>
<p>yapp_pkg.sv</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  yapp_pkg;</span><br><span class="line">	<span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line">	<span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">`<span class="keyword">include</span> &quot;yapp_packet.sv&quot;</span></span><br><span class="line"><span class="keyword">endpackage</span> : yapp_pkg</span><br></pre></td></tr></table></figure>
<p>run.f for <code>xrun</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 64 bit option <span class="keyword">for</span> AWS labs</span><br><span class="line">-64</span><br><span class="line"></span><br><span class="line"> -uvmhome CDNS-1.2</span><br><span class="line"></span><br><span class="line">// include directories</span><br><span class="line">-incdir ../sv</span><br><span class="line"></span><br><span class="line">// compile files</span><br><span class="line">../sv/yapp_pkg.sv</span><br><span class="line">./top.sv</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>UVM Register Abstraction Layer (RAL) - source code reading</title>
    <url>/2022/03/13/uvm-ral-src-reading/</url>
    <content><![CDATA[<h2 id="field-access-policies">Field Access Policies</h2>
<p><img
src="/2022/03/13/uvm-ral-src-reading/image-20220526092125583.png"
alt="image-20220526092125583" /></p>
<p>whether a register field can be read or written depends on both the
field's configured access policy and the register's rights in the map
being used to access the field</p>
<p><a
href="http://www.verilab.com/files/litterick_register_final.pdf">http://www.verilab.com/files/litterick_register_final.pdf</a></p>
<p><a
href="https://www.verilab.com/files/litterick_register_slides_sm.pdf">https://www.verilab.com/files/litterick_register_slides_sm.pdf</a></p>
<h2 id="uvm_regwrite">uvm_reg::write</h2>
<ul>
<li><p>If a back-door access path is used, the effect of writing the
register through a physical access is mimicked. For example,
<strong>read-only</strong> bits in the registers will
<strong>not</strong> be written.</p></li>
<li><p>The <strong>mirrored value</strong> will be updated using the
<code>uvm_reg::predict()</code> method.</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> write(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                          <span class="keyword">input</span>  uvm_reg_data_t    value,</span><br><span class="line">                          <span class="keyword">input</span>  uvm_path_e        path = UVM_DEFAULT_PATH,</span><br><span class="line">                          <span class="keyword">input</span>  uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                          <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                          <span class="keyword">input</span>  <span class="keyword">int</span>               prior = -<span class="number">1</span>,</span><br><span class="line">                          <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                          <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                          <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> do_write(uvm_reg_item rw);</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> uvm_reg::write(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                    <span class="keyword">input</span>  uvm_reg_data_t    value,</span><br><span class="line">                    <span class="keyword">input</span>  uvm_path_e        path = UVM_DEFAULT_PATH,</span><br><span class="line">                    <span class="keyword">input</span>  uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                    <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                    <span class="keyword">input</span>  <span class="keyword">int</span>               prior = -<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                    <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// create an abstract transaction for this operation</span></span><br><span class="line">   uvm_reg_item rw;</span><br><span class="line"></span><br><span class="line">   XatomicX(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   set(value);</span><br><span class="line"></span><br><span class="line">   rw = uvm_reg_item::type_id::create(<span class="string">&quot;write_item&quot;</span>,,get_full_name());</span><br><span class="line">   rw<span class="variable">.element</span>      = <span class="keyword">this</span>;</span><br><span class="line">   rw<span class="variable">.element_kind</span> = UVM_REG;</span><br><span class="line">   rw<span class="variable">.kind</span>         = UVM_WRITE;</span><br><span class="line">   rw<span class="variable">.value</span>[<span class="number">0</span>]     = value;</span><br><span class="line">   rw<span class="variable">.path</span>         = path;</span><br><span class="line">   rw<span class="variable">.map</span>          = map;</span><br><span class="line">   rw<span class="variable">.parent</span>       = parent;</span><br><span class="line">   rw<span class="variable">.prior</span>        = prior;</span><br><span class="line">   rw<span class="variable">.extension</span>    = extension;</span><br><span class="line">   rw<span class="variable">.fname</span>        = fname;</span><br><span class="line">   rw<span class="variable">.lineno</span>       = lineno;</span><br><span class="line"></span><br><span class="line">   do_write(rw);</span><br><span class="line"></span><br><span class="line">   status = rw<span class="variable">.status</span>;</span><br><span class="line"></span><br><span class="line">   XatomicX(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<h2 id="uvm_regread">uvm_reg::read</h2>
<ul>
<li><p>If a back-door access path is used, the effect of reading the
register through a physical access is mimicked. For example,
<strong>clear-on-read</strong> bits in the registers will be set to
<strong>zero</strong>.</p></li>
<li><p>The <strong>mirrored value</strong> will be updated using the
<code>uvm_reg::predict()</code> method.</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> read(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                         <span class="keyword">output</span> uvm_reg_data_t    value,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_path_e        path = UVM_DEFAULT_PATH,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">int</span>               prior = -<span class="number">1</span>,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> do_read(uvm_reg_item rw);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/13/uvm-ral-src-reading/uvmreg_read.drawio.svg"
alt="uvmreg_read.drawio" /></p>
<blockquote>
<p><strong>readback value can be different from m_mirrored , m_desired
or value</strong></p>
</blockquote>
<h2 id="uvm_regpoke">uvm_reg::poke</h2>
<ul>
<li><p>Deposit the value in the DUT register corresponding to this
abstraction class instance, <strong>as-is</strong>, using a back-door
access.</p></li>
<li><p>Uses the HDL path for the design abstraction specified by
<strong>kind</strong>.</p></li>
<li><p>The <strong>mirrored value</strong> will be updated using the
<code>uvm_reg::predict()</code> method.</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> poke(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_reg_data_t    value,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">string</span>            kind = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="uvm_regpeek">uvm_reg::peek</h2>
<ul>
<li>Sample the value in the DUT register corresponding to this
abstraction class instance using a <strong>back-door</strong> access.
The register value is sampled, not modified.</li>
<li>Uses the HDL path for the design abstraction specified by
<code>kind</code>.</li>
<li>The <strong>mirrored value</strong> will be updated using the
<code>uvm_reg::predict()</code> method.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> peek(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                         <span class="keyword">output</span> uvm_reg_data_t    value,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">string</span>            kind = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="uvm_regmirror">uvm_reg::mirror</h2>
<ul>
<li><p>Read the register and optionally compared the <strong>readback
value</strong> with the <strong>current mirrored value</strong> if
<code>check</code> is <code>UVM_CHECK</code>.</p></li>
<li><p>The <strong>mirrored value</strong> will be updated using the
<code>uvm_reg::predict()</code> method based on the <strong>readback
value</strong>.</p></li>
<li><p>The mirroring can be performed using the physical interfaces
(frontdoor) or <code>uvm_reg::peek()</code> (backdoor).</p></li>
<li><p>If the register contains <strong>write-only</strong> fields,
their content is mirrored and optionally checked only if a
<code>UVM_BACKDOOR</code> access path is used to read the
register.</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> mirror(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                           <span class="keyword">input</span> uvm_check_e        check  = UVM_NO_CHECK,</span><br><span class="line">                           <span class="keyword">input</span> uvm_path_e         path = UVM_DEFAULT_PATH,</span><br><span class="line">                           <span class="keyword">input</span> uvm_reg_map        map = <span class="literal">null</span>,</span><br><span class="line">                           <span class="keyword">input</span> uvm_sequence_base  parent = <span class="literal">null</span>,</span><br><span class="line">                           <span class="keyword">input</span> <span class="keyword">int</span>                prior = -<span class="number">1</span>,</span><br><span class="line">                           <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                           <span class="keyword">input</span> <span class="keyword">string</span>             fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="keyword">input</span> <span class="keyword">int</span>                lineno = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="uvm_regupdate">uvm_reg::update</h2>
<ul>
<li>Write this register if the DUT register is out-of-date with the
desired/mirrored value in the abstraction class, as determined by the
<code>uvm_reg::needs_update()</code> method.</li>
<li>The update can be performed using the using the physical interfaces
(frontdoor) or <code>uvm_reg::poke()</code> (backdoor) access.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> update(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                           <span class="keyword">input</span>  uvm_path_e        path = UVM_DEFAULT_PATH,</span><br><span class="line">                           <span class="keyword">input</span>  uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                           <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                           <span class="keyword">input</span>  <span class="keyword">int</span>               prior = -<span class="number">1</span>,</span><br><span class="line">                           <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                           <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> uvm_reg::needs_update();</span><br><span class="line">    needs_update = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (m_fields[i]) <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">if</span> (m_fields[i]<span class="variable">.needs_update</span>()) <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span>: needs_update</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> uvm_reg::update(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                     <span class="keyword">input</span>  uvm_path_e        path = UVM_DEFAULT_PATH,</span><br><span class="line">                     <span class="keyword">input</span>  uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                     <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                     <span class="keyword">input</span>  <span class="keyword">int</span>               prior = -<span class="number">1</span>,</span><br><span class="line">                     <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                     <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line">   uvm_reg_data_t upd;</span><br><span class="line"></span><br><span class="line">   status = UVM_IS_OK;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!needs_update()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Concatenate the write-to-update values from each field</span></span><br><span class="line">   <span class="comment">// Fields are stored in LSB or MSB order</span></span><br><span class="line">   upd = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">foreach</span> (m_fields[i])</span><br><span class="line">      upd |= m_fields[i]<span class="variable">.XupdateX</span>() &lt;&lt; m_fields[i]<span class="variable">.get_lsb_pos</span>();</span><br><span class="line"></span><br><span class="line">   write(status, upd, path, map, parent, prior, extension, fname, lineno);</span><br><span class="line"><span class="keyword">endtask</span>: update</span><br></pre></td></tr></table></figure>
<h2 id="uvm_regpredict">uvm_reg::predict</h2>
<ul>
<li>Update the <strong>mirrored and desired value</strong> for this
register.</li>
<li>Predict the mirror (and desired) value of the fields in the register
based on the specified observed <code>value</code> on a specified
address <code>map</code>, or based on a calculated value.</li>
<li>See <code>uvm_reg_field::predict()</code> for more details.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">bit</span> predict (uvm_reg_data_t    value,</span><br><span class="line">                                     uvm_reg_byte_en_t be = -<span class="number">1</span>,</span><br><span class="line">                                     uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                                     uvm_path_e        path = UVM_FRONTDOOR,</span><br><span class="line">                                     uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                                     <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                     <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> do_predict</span><br><span class="line">                             (uvm_reg_item      rw,</span><br><span class="line">                              uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                              uvm_reg_byte_en_t be = -<span class="number">1</span>);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="uvm_regdo_predict">uvm_reg::do_predict</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg::do_predict(uvm_reg_item      rw,</span><br><span class="line">                                  uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                                  uvm_reg_byte_en_t be = -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   uvm_reg_data_t reg_value = rw<span class="variable">.value</span>[<span class="number">0</span>];</span><br><span class="line">   m_fname = rw<span class="variable">.fname</span>;</span><br><span class="line">   m_lineno = rw<span class="variable">.lineno</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rw<span class="variable">.status</span> ==UVM_IS_OK )</span><br><span class="line">   rw<span class="variable">.status</span> = UVM_IS_OK;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (m_is_busy &amp;&amp; kind == UVM_PREDICT_DIRECT) <span class="keyword">begin</span></span><br><span class="line">      `uvm_warning(<span class="string">&quot;RegModel&quot;</span>, &#123;<span class="string">&quot;Trying to predict value of register &#x27;&quot;</span>,</span><br><span class="line">                  get_full_name(),<span class="string">&quot;&#x27; while it is being accessed&quot;</span>&#125;)</span><br><span class="line">      rw<span class="variable">.status</span> = UVM_NOT_OK;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">foreach</span> (m_fields[i]) <span class="keyword">begin</span></span><br><span class="line">      rw<span class="variable">.value</span>[<span class="number">0</span>] = (reg_value &gt;&gt; m_fields[i]<span class="variable">.get_lsb_pos</span>()) &amp;</span><br><span class="line">                                 ((<span class="number">1</span> &lt;&lt; m_fields[i]<span class="variable">.get_n_bits</span>())-<span class="number">1</span>);</span><br><span class="line">      m_fields[i]<span class="variable">.do_predict</span>(rw, kind, be&gt;&gt;(m_fields[i]<span class="variable">.get_lsb_pos</span>()/<span class="number">8</span>));</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   rw<span class="variable">.value</span>[<span class="number">0</span>] = reg_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: do_predict</span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_fielddo_predict">uvm_reg_field::do_predict</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_field::do_predict(uvm_reg_item      rw,</span><br><span class="line">                                        uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                                        uvm_reg_byte_en_t be = -<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">   uvm_reg_data_t field_val = rw<span class="variable">.value</span>[<span class="number">0</span>] &amp; ((<span class="number">1</span> &lt;&lt; m_size)-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (rw<span class="variable">.status</span> != UVM_NOT_OK)</span><br><span class="line">     rw<span class="variable">.status</span> = UVM_IS_OK;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Assume that the entire field is enabled</span></span><br><span class="line">   <span class="keyword">if</span> (!be[<span class="number">0</span>])</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   m_fname = rw<span class="variable">.fname</span>;</span><br><span class="line">   m_lineno = rw<span class="variable">.lineno</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> (kind)</span><br><span class="line"></span><br><span class="line">     UVM_PREDICT_WRITE:</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         uvm_reg_field_cb_iter cbs = <span class="keyword">new</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (rw<span class="variable">.path</span> == UVM_FRONTDOOR || rw<span class="variable">.path</span> == UVM_PREDICT)</span><br><span class="line">            field_val = XpredictX(m_mirrored, field_val, rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">         m_written = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (uvm_reg_cbs cb = cbs<span class="variable">.first</span>(); cb != <span class="literal">null</span>; cb = cbs<span class="variable">.next</span>())</span><br><span class="line">            cb<span class="variable">.post_predict</span>(<span class="keyword">this</span>, m_mirrored, field_val, </span><br><span class="line">                            UVM_PREDICT_WRITE, rw<span class="variable">.path</span>, rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">         field_val &amp;= (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">     UVM_PREDICT_READ:</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         uvm_reg_field_cb_iter cbs = <span class="keyword">new</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (rw<span class="variable">.path</span> == UVM_FRONTDOOR || rw<span class="variable">.path</span> == UVM_PREDICT) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> acc = get_access(rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="string">&quot;RC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;WRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;WSRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;W1SRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;W0SRC&quot;</span>)</span><br><span class="line">              field_val = <span class="number">0</span>;  <span class="comment">// (clear)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (acc == <span class="string">&quot;RS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WCRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;W1CRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;W0CRS&quot;</span>)</span><br><span class="line">              field_val = (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>; <span class="comment">// all 1&#x27;s (set)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (acc == <span class="string">&quot;WO&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WOC&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WOS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WO1&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;NOACCESS&quot;</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (uvm_reg_cbs cb = cbs<span class="variable">.first</span>(); cb != <span class="literal">null</span>; cb = cbs<span class="variable">.next</span>())</span><br><span class="line">            cb<span class="variable">.post_predict</span>(<span class="keyword">this</span>, m_mirrored, field_val,</span><br><span class="line">                            UVM_PREDICT_READ, rw<span class="variable">.path</span>, rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">         field_val &amp;= (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">     UVM_PREDICT_DIRECT:</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">if</span> (m_parent<span class="variable">.is_busy</span>()) <span class="keyword">begin</span></span><br><span class="line">           `uvm_warning(<span class="string">&quot;RegModel&quot;</span>, &#123;<span class="string">&quot;Trying to predict value of field &#x27;&quot;</span>,</span><br><span class="line">              get_name(),<span class="string">&quot;&#x27; while register &#x27;&quot;</span>,m_parent<span class="variable">.get_full_name</span>(),</span><br><span class="line">              <span class="string">&quot;&#x27; is being accessed&quot;</span>&#125;)</span><br><span class="line">           rw<span class="variable">.status</span> = UVM_NOT_OK;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// update the mirror with predicted value</span></span><br><span class="line">   m_mirrored = field_val;</span><br><span class="line">   m_desired  = field_val;</span><br><span class="line">   <span class="keyword">this</span><span class="variable">.value</span> = field_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: do_predict</span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_fieldxpredictx">uvm_reg_field::XpredictX</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> uvm_reg_data_t uvm_reg_field::XpredictX (uvm_reg_data_t cur_val,</span><br><span class="line">                                                  uvm_reg_data_t wr_val,</span><br><span class="line">                                                  uvm_reg_map    map);</span><br><span class="line">   uvm_reg_data_t mask = (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> (get_access(map))</span><br><span class="line">     <span class="string">&quot;RO&quot;</span>:    <span class="keyword">return</span> cur_val;</span><br><span class="line">     <span class="string">&quot;RW&quot;</span>:    <span class="keyword">return</span> wr_val;</span><br><span class="line">     <span class="string">&quot;RC&quot;</span>:    <span class="keyword">return</span> cur_val;</span><br><span class="line">     <span class="string">&quot;RS&quot;</span>:    <span class="keyword">return</span> cur_val;</span><br><span class="line">     <span class="string">&quot;WC&quot;</span>:    <span class="keyword">return</span> &#x27;<span class="number">0</span>;</span><br><span class="line">     <span class="string">&quot;WS&quot;</span>:    <span class="keyword">return</span> mask;</span><br><span class="line">     <span class="string">&quot;WRC&quot;</span>:   <span class="keyword">return</span> wr_val;</span><br><span class="line">     <span class="string">&quot;WRS&quot;</span>:   <span class="keyword">return</span> wr_val;</span><br><span class="line">     <span class="string">&quot;WSRC&quot;</span>:  <span class="keyword">return</span> mask;</span><br><span class="line">     <span class="string">&quot;WCRS&quot;</span>:  <span class="keyword">return</span> &#x27;<span class="number">0</span>;</span><br><span class="line">     <span class="string">&quot;W1C&quot;</span>:   <span class="keyword">return</span> cur_val &amp; (~wr_val);</span><br><span class="line">     <span class="string">&quot;W1S&quot;</span>:   <span class="keyword">return</span> cur_val | wr_val;</span><br><span class="line">     <span class="string">&quot;W1T&quot;</span>:   <span class="keyword">return</span> cur_val ^ wr_val;</span><br><span class="line">     <span class="string">&quot;W0C&quot;</span>:   <span class="keyword">return</span> cur_val &amp; wr_val;</span><br><span class="line">     <span class="string">&quot;W0S&quot;</span>:   <span class="keyword">return</span> cur_val | (~wr_val &amp; mask);</span><br><span class="line">     <span class="string">&quot;W0T&quot;</span>:   <span class="keyword">return</span> cur_val ^ (~wr_val &amp; mask);</span><br><span class="line">     <span class="string">&quot;W1SRC&quot;</span>: <span class="keyword">return</span> cur_val | wr_val;</span><br><span class="line">     <span class="string">&quot;W1CRS&quot;</span>: <span class="keyword">return</span> cur_val &amp; (~wr_val);</span><br><span class="line">     <span class="string">&quot;W0SRC&quot;</span>: <span class="keyword">return</span> cur_val | (~wr_val &amp; mask);</span><br><span class="line">     <span class="string">&quot;W0CRS&quot;</span>: <span class="keyword">return</span> cur_val &amp; wr_val;</span><br><span class="line">     <span class="string">&quot;WO&quot;</span>:    <span class="keyword">return</span> wr_val;</span><br><span class="line">     <span class="string">&quot;WOC&quot;</span>:   <span class="keyword">return</span> &#x27;<span class="number">0</span>;</span><br><span class="line">     <span class="string">&quot;WOS&quot;</span>:   <span class="keyword">return</span> mask;</span><br><span class="line">     <span class="string">&quot;W1&quot;</span>:    <span class="keyword">return</span> (m_written) ? cur_val : wr_val;</span><br><span class="line">     <span class="string">&quot;WO1&quot;</span>:   <span class="keyword">return</span> (m_written) ? cur_val : wr_val;</span><br><span class="line">     <span class="string">&quot;NOACCESS&quot;</span>: <span class="keyword">return</span> cur_val;</span><br><span class="line">     <span class="keyword">default</span>: <span class="keyword">return</span> wr_val;</span><br><span class="line">   <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">   `uvm_fatal(<span class="string">&quot;RegModel&quot;</span>, <span class="string">&quot;uvm_reg_field::XpredictX(): Internal error&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endfunction</span>: XpredictX</span><br></pre></td></tr></table></figure>
<h2 id="uvm_regreset-uvm_reg_fieldreset">uvm_reg::reset ,
uvm_reg_field::reset</h2>
<p>Resetting a register model sets the mirror to the reset value
specified in the model</p>
<h3 id="uvm_regreset">uvm_reg::reset</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg::reset(<span class="keyword">string</span> kind = <span class="string">&quot;HARD&quot;</span>);</span><br><span class="line">   <span class="keyword">foreach</span> (m_fields[i])</span><br><span class="line">      m_fields[i]<span class="variable">.reset</span>(kind);</span><br><span class="line">   <span class="comment">// Put back a key in the semaphore if it is checked out</span></span><br><span class="line">   <span class="comment">// in case a thread was killed during an operation</span></span><br><span class="line">   <span class="keyword">void</span>&#x27;(m_atomic<span class="variable">.try_get</span>(<span class="number">1</span>));</span><br><span class="line">   m_atomic<span class="variable">.put</span>(<span class="number">1</span>);</span><br><span class="line">   m_process = <span class="literal">null</span>;</span><br><span class="line">   Xset_busyX(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">endfunction</span>: reset</span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_fieldreset">uvm_reg_field::reset</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_field::reset(<span class="keyword">string</span> kind = <span class="string">&quot;HARD&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!m_reset<span class="variable">.exists</span>(kind))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   m_mirrored = m_reset[kind];</span><br><span class="line">   m_desired  = m_mirrored;</span><br><span class="line">   value      = m_mirrored;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (kind == <span class="string">&quot;HARD&quot;</span>)</span><br><span class="line">      m_written  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: reset</span><br></pre></td></tr></table></figure>
<h2 id="uvm_reg_fieldrandomize">uvm_reg_field::randomize</h2>
<h3 id="uvm_reg_fieldpre_randomize">uvm_reg_field::pre_randomize()</h3>
<p>Update the only publicly known property <code>value</code> with the
<strong>current desired</strong> value so it can be used as a state
variable should the <code>rand_mode</code> of the field be turned
off.</p>
<blockquote>
<p><code>value</code> is <code>m_desired</code> if
<code>rand_mode</code> is off.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_field::pre_randomize();</span><br><span class="line">   value = m_desired;</span><br><span class="line"><span class="keyword">endfunction</span>: pre_randomize</span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_fieldpost_randomize">uvm_reg_field::post_randomize</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_field::post_randomize();</span><br><span class="line">   m_desired = value;</span><br><span class="line"><span class="keyword">endfunction</span>: post_randomize</span><br></pre></td></tr></table></figure>
<h2 id="misc">misc</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">bit</span> <span class="keyword">unsigned</span> [`UVM_REG_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]  uvm_reg_data_t ;</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum: uvm_predict_e</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// How the mirror is to be updated</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UVM_PREDICT_DIRECT  - Predicted value is as-is</span></span><br><span class="line"><span class="comment">// UVM_PREDICT_READ    - Predict based on the specified value having been read</span></span><br><span class="line"><span class="comment">// UVM_PREDICT_WRITE   - Predict based on the specified value having been written</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">      UVM_PREDICT_DIRECT,</span><br><span class="line">      UVM_PREDICT_READ,</span><br><span class="line">      UVM_PREDICT_WRITE</span><br><span class="line">   &#125; uvm_predict_e;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>UVM Register Abstraction Layer (RAL) - overview</title>
    <url>/2022/03/12/uvm-ral/</url>
    <content><![CDATA[<p>Within an UVM testbench a register model is used</p>
<ul>
<li><p>either as a means of looking up a mirror of the current DUT
hardware state</p></li>
<li><p>or as means of accessing the hardware via the front or back
door</p>
<p>and updating the register model database.</p></li>
</ul>
<p><img src="/2022/03/12/uvm-ral/image-20220312125516500.png"
alt="image-20220312125516500" /></p>
<h4 id="register-frontdoor-write">Register Frontdoor Write</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.write</span>(status, value, [UVM_FRONTDOOR], <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>Sequence sets <code>uvm_reg</code> with value</li>
<li><code>uvm_reg</code> content is translated into bus transaction</li>
<li>Driver gets bus transaction and writes DUT register</li>
<li><strong>Mirror</strong> can be updated either implicitly or
explicitly (predictor)</li>
</ul>
<h4 id="register-backdoor-write">Register Backdoor Write</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.write</span>(status, value, UVM_BACKDOOR, <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p><code>uvm_reg</code> uses DPI/XMR to set DUT register with value</p>
<ul>
<li>Physical interface is bypassed</li>
<li>Register behavior is mimicked</li>
</ul>
<h4 id="register-backdoor-poke">Register Backdoor Poke</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.poke</span>(status, value, <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p><code>uvm_reg</code> used DPI/XMR to set DUT register with
<strong>value as is</strong></p>
<ul>
<li>Physical interface is bypassed</li>
<li>Register behavior is <strong>NOT</strong> mimicked</li>
</ul>
<hr />
<h4 id="register-frontdoor-read">Register Frontdoor Read</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.read</span>(status, value, [UVM_FRONTDOOR], <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>Sequence executes <code>uvm_reg</code> READ</li>
<li><code>uvm_reg</code> is translated into bus transaction</li>
<li>Driver gets bus transaction and read DUT register</li>
<li>Read value is translated into <code>uvm_reg</code> data and returned
to sequence</li>
<li>Mirror updates</li>
</ul>
<h4 id="register-backdoor-read">Register Backdoor Read</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.read</span>(status, value, UVM_BACKDOOR, <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p><code>uvm_reg</code> used DPI/XMR to get DUT register value</p>
<ul>
<li>Physical interface is bypassed</li>
<li>Register behavior is <strong>mimicked</strong> (acc)</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EXECUTE READ...</span></span><br><span class="line"><span class="keyword">case</span> (rw<span class="variable">.path</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...VIA USER BACKDOOR</span></span><br><span class="line">   UVM_BACKDOOR: <span class="keyword">begin</span> </span><br><span class="line">      uvm_reg_backdoor bkdr = get_backdoor();</span><br><span class="line"></span><br><span class="line">      uvm_reg_map map = uvm_reg_map::backdoor();</span><br><span class="line">      <span class="keyword">if</span> (map<span class="variable">.get_check_on_read</span>()) exp = get();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (bkdr != <span class="literal">null</span>)</span><br><span class="line">        bkdr<span class="variable">.read</span>(rw);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        backdoor_read(rw);</span><br><span class="line"></span><br><span class="line">      value = rw<span class="variable">.value</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Need to clear RC fields, set RS fields and mask WO fields</span></span><br><span class="line">      <span class="keyword">if</span> (rw<span class="variable">.status</span> != UVM_NOT_OK) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">         uvm_reg_data_t wo_mask;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">foreach</span> (m_fields[i]) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">string</span> acc = m_fields[i]<span class="variable">.get_access</span>(uvm_reg_map::backdoor());</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="string">&quot;RC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;WRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;WSRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;W1SRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;W0SRC&quot;</span>) <span class="keyword">begin</span></span><br><span class="line">               value &amp;= ~(((<span class="number">1</span>&lt;&lt;m_fields[i]<span class="variable">.get_n_bits</span>())-<span class="number">1</span>)</span><br><span class="line">                                       &lt;&lt; m_fields[i]<span class="variable">.get_lsb_pos</span>());</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (acc == <span class="string">&quot;RS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WCRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;W1CRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;W0CRS&quot;</span>) <span class="keyword">begin</span></span><br><span class="line">               value |= (((<span class="number">1</span>&lt;&lt;m_fields[i]<span class="variable">.get_n_bits</span>())-<span class="number">1</span>)</span><br><span class="line">                                       &lt;&lt; m_fields[i]<span class="variable">.get_lsb_pos</span>());</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (acc == <span class="string">&quot;WO&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WOC&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WOS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WO1&quot;</span>) <span class="keyword">begin</span></span><br><span class="line">               wo_mask |= ((<span class="number">1</span>&lt;&lt;m_fields[i]<span class="variable">.get_n_bits</span>())-<span class="number">1</span>)</span><br><span class="line">                                       &lt;&lt; m_fields[i]<span class="variable">.get_lsb_pos</span>();</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (value != rw<span class="variable">.value</span>[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">           uvm_reg_data_t saved;</span><br><span class="line">           saved = rw<span class="variable">.value</span>[<span class="number">0</span>];</span><br><span class="line">           rw<span class="variable">.value</span>[<span class="number">0</span>] = value;</span><br><span class="line">           <span class="keyword">if</span> (bkdr != <span class="literal">null</span>)</span><br><span class="line">              bkdr<span class="variable">.write</span>(rw);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">              backdoor_write(rw);</span><br><span class="line">           rw<span class="variable">.value</span>[<span class="number">0</span>] = saved;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">         rw<span class="variable">.value</span>[<span class="number">0</span>] &amp;= ~wo_mask;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (map<span class="variable">.get_check_on_read</span>() &amp;&amp;</span><br><span class="line">            rw<span class="variable">.status</span> != UVM_NOT_OK) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">void</span>&#x27;(do_check(exp, rw<span class="variable">.value</span>[<span class="number">0</span>], map));</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line">         do_predict(rw, UVM_PREDICT_READ);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="register-backdoor-peek">Register Backdoor Peek</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.peek</span>(status, value, <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p><code>uvm_reg</code> uses DPI/XMR to get DUT register <strong>value
as is</strong></p>
<ul>
<li>Physical interface is bypassed</li>
<li>Register behavior is <strong>NOT</strong> mimicked</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> uvm_reg::peek(<span class="keyword">output</span> uvm_status_e      status,</span><br><span class="line">                   <span class="keyword">output</span> uvm_reg_data_t    value,</span><br><span class="line">                   <span class="keyword">input</span>  <span class="keyword">string</span>            kind = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   <span class="keyword">input</span>  uvm_sequence_base parent = <span class="literal">null</span>,</span><br><span class="line">                   <span class="keyword">input</span>  uvm_object        extension = <span class="literal">null</span>,</span><br><span class="line">                   <span class="keyword">input</span>  <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   <span class="keyword">input</span>  <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   uvm_reg_backdoor bkdr = get_backdoor();</span><br><span class="line">   uvm_reg_item rw;</span><br><span class="line"></span><br><span class="line">   m_fname = fname;</span><br><span class="line">   m_lineno = lineno;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// create an abstract transaction for this operation</span></span><br><span class="line">   rw = uvm_reg_item::type_id::create(<span class="string">&quot;mem_peek_item&quot;</span>,,get_full_name());</span><br><span class="line">   rw<span class="variable">.element</span>      = <span class="keyword">this</span>;</span><br><span class="line">   rw<span class="variable">.path</span>         = UVM_BACKDOOR;</span><br><span class="line">   rw<span class="variable">.element_kind</span> = UVM_REG;</span><br><span class="line">   rw<span class="variable">.kind</span>         = UVM_READ;</span><br><span class="line">   rw<span class="variable">.bd_kind</span>      = kind;</span><br><span class="line">   rw<span class="variable">.parent</span>       = parent;</span><br><span class="line">   rw<span class="variable">.extension</span>    = extension;</span><br><span class="line">   rw<span class="variable">.fname</span>        = fname;</span><br><span class="line">   rw<span class="variable">.lineno</span>       = lineno;</span><br><span class="line"></span><br><span class="line">   do_predict(rw, UVM_PREDICT_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endtask</span>: peek </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="methods-to-handle-property-of-uvm_reg-or-uvm_reg_block">Methods
to handle property of uvm_reg or uvm_reg_block</h4>
<h5 id="mirror">mirror</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.mirror</span>(status, [check], [path], <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">model<span class="variable">.r0</span><span class="variable">.mirro</span>(status, [check], [path], <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p>Update <strong>mirrored</strong> and <strong>desired</strong>
properties with DUT content</p>
<h5 id="set">set</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.set</span>(value);</span><br></pre></td></tr></table></figure>
<p>Set value in <strong>desired</strong> properties</p>
<h5 id="randomize">randomize</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.randomize</span>();</span><br><span class="line">model<span class="variable">.r0</span><span class="variable">.randomize</span>();</span><br></pre></td></tr></table></figure>
<p>Populate <strong>desired</strong> property with random value</p>
<h5 id="get">get</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">value = model<span class="variable">.r0</span><span class="variable">.get</span>();</span><br></pre></td></tr></table></figure>
<p>Get value from <strong>desired</strong> property</p>
<h5 id="update">update</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.update</span>(status, [path], <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">model<span class="variable">.r0</span><span class="variable">.update</span>(status, [path], <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p>Update <strong>DUT</strong> and <strong>mirrored</strong> property
with <strong>desired</strong> property if <strong>mirrored</strong>
property is different from <strong>desired</strong></p>
<h5 id="predict">predict</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">model<span class="variable">.r0</span><span class="variable">.predict</span>(value);</span><br></pre></td></tr></table></figure>
<p>Set the value of <strong>mirrored</strong> property</p>
<h5 id="get_mirrored_value">get_mirrored_value</h5>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">value = model<span class="variable">.r0</span><span class="variable">.get_mirrored_value</span>();</span><br></pre></td></tr></table></figure>
<p>Get value from <strong>mirrored</strong> property</p>
<h4 id="backdoor-access">Backdoor Access</h4>
<ul>
<li>Two ways to generate the backdoor access:
<ul>
<li>Via SystemVerilog Cross Module Reference (XMR)</li>
<li>Via SystemVerilog DPI call</li>
</ul></li>
<li>Both allow register model to be part of SystemVerilog package</li>
<li>XMR implementation is faster
<ul>
<li>Requires user to compile one additional file and at compile-time
provide top level path to DUT</li>
<li><strong>VCS only</strong></li>
</ul></li>
<li>DPI implementation is slower
<ul>
<li>No additional file is needed and top level path can be provided at
run-time</li>
<li>Portable to other simulators</li>
</ul></li>
</ul>
<h4 id="uvm-register-classes-uvm_reg_bus_op-uvm_reg_item">UVM Register
Classes: uvm_reg_bus_op &amp; uvm_reg_item</h4>
<p>The generic register item is implemented as a struct in order to
minimise the amount of memory resource it uses. The struct is defined as
type <code>uvm_reg_bus_op</code> and this contains 6 fields:</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 26%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Type</th>
<th>Comment/Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>addr</td>
<td>uvm_reg_addr_t</td>
<td>Address field, defaults to 64 bits</td>
</tr>
<tr class="even">
<td>data</td>
<td>uvm_reg_data_t</td>
<td>Read or write data, defaults to 64 bits</td>
</tr>
<tr class="odd">
<td>kind</td>
<td>uvm_access_e</td>
<td>UVM_READ or UVM_WRITE</td>
</tr>
<tr class="even">
<td>n_bits</td>
<td>unsigned int</td>
<td>Number of bits being transferred</td>
</tr>
<tr class="odd">
<td>byte_en</td>
<td>uvm_reg_byte_en_t</td>
<td>Byte enable</td>
</tr>
<tr class="even">
<td>status</td>
<td>uvm_status_e</td>
<td>UVM_IS_OK, UVM_IS_X, UVM_NOT_OK</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  uvm_access_e kind;	<span class="comment">// Kind of access: READ or WRITE.</span></span><br><span class="line">  uvm_reg_addr_t addr;	<span class="comment">// The bus address.</span></span><br><span class="line">  uvm_reg_data_t data;	<span class="comment">// The data to write.</span></span><br><span class="line">  <span class="comment">// The number of bits of &lt;uvm_reg_item::value&gt; being transferred by this transaction.</span></span><br><span class="line">  <span class="keyword">int</span> n_bits;	</span><br><span class="line">  uvm_reg_byte_en_t byte_en;	<span class="comment">// Enables for the byte lanes on the bus.</span></span><br><span class="line">  uvm_status_e status;	<span class="comment">// The result of the transaction: UVM_IS_OK, UVM_HAS_X, UVM_NOT_OK.</span></span><br><span class="line">&#125; uvm_reg_bus_op;</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> uvm_reg_item <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    <span class="keyword">rand</span> uvm_access_e kind;</span><br><span class="line">    <span class="keyword">rand</span> uvm_reg_data_t value[];</span><br><span class="line">    <span class="keyword">rand</span> uvm_reg_addr_t offset;</span><br><span class="line">    uvm_status_e status;</span><br><span class="line">    uvm_reg_map map;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h4 id="registers">Registers</h4>
<p>The register class contains a <code>build</code> method which is used
to <strong>create</strong> and <strong>configure the
fields</strong>.</p>
<blockquote>
<p>this <code>build</code> method is not called by the UVM
<code>build_phase</code>, since the register is an
<code>uvm_object</code> rather than an <code>uvm_component</code></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// uvm_reg constructor prototype:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">string</span> name=<span class="string">&quot;&quot;</span>,      <span class="comment">// Register name</span></span><br><span class="line">              <span class="keyword">int</span> <span class="keyword">unsigned</span> n_bits, <span class="comment">// Register width in bits</span></span><br><span class="line">              <span class="keyword">int</span> has_coverage);   <span class="comment">// Coverage model supported by the register</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function: new</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;ctrl_reg&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, <span class="number">32</span>, build_coverage(UVM_CVR_FIELD_VALS));</span><br><span class="line">    add_coverage(build_coverage(UVM_CVR_FIELD_VALS));</span><br><span class="line">    <span class="keyword">if</span>(has_coverage(UVM_CVR_FIELD_VALS))</span><br><span class="line">        cg_vals = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function: sample_values</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> sample_values();</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.sample_values</span>();</span><br><span class="line">    <span class="keyword">if</span> (get_coverage(UVM_CVR_FIELD_VALS))</span><br><span class="line">        cg_vals<span class="variable">.sample</span>();</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function: build</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build();</span><br><span class="line">    ass = uvm_reg_field::type_id::create(<span class="string">&quot;ass&quot;</span>);</span><br><span class="line">    ie = uvm_reg_field::type_id::create(<span class="string">&quot;ie&quot;</span>);</span><br><span class="line">    lsb = uvm_reg_field::type_id::create(<span class="string">&quot;lsb&quot;</span>);</span><br><span class="line">    tx_neg = uvm_reg_field::type_id::create(<span class="string">&quot;tx_neg&quot;</span>);</span><br><span class="line">    rx_neg = uvm_reg_field::type_id::create(<span class="string">&quot;rx_neg&quot;</span>);</span><br><span class="line">    go_bsy = uvm_reg_field::type_id::create(<span class="string">&quot;go_bsy&quot;</span>);</span><br><span class="line">    reserved2 = uvm_reg_field::type_id::create(<span class="string">&quot;reserved2&quot;</span>);</span><br><span class="line">    char_len = uvm_reg_field::type_id::create(<span class="string">&quot;char_len&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ass<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ie<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    lsb<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    tx_neg<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rx_neg<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    go_bsy<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    reserved2<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    char_len<span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">7&#x27;b0000000</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>As shown above, Register width is <strong>32</strong> same with the
bus width, <strong>lower 14 bit</strong> is configured.</p>
</blockquote>
<p><strong>RTL</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> SPI_CTRL_BIT_NB         14</span></span><br><span class="line"><span class="keyword">reg</span> [`SPI_CTRL_BIT_NB-<span class="number">1</span>:<span class="number">0</span>] ctrl;	<span class="comment">// Control and status register</span></span><br></pre></td></tr></table></figure>
<h4 id="register-maps">Register Maps</h4>
<p>Two purpose of the register map</p>
<ul>
<li>provide information on the offset of the registers, memories and/or
register blocks</li>
<li>identify bus agent based sequences to be executed ???</li>
</ul>
<blockquote>
<p>There can be several register maps within a block, each one can
specify a different <strong>address map</strong> and a different
<strong>target bus agent</strong></p>
<p>register map has to be created which the <strong>register
block</strong> using the <code>create_map</code> method</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Prototype for the create_map method</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">function</span> uvm_reg_map create_map(<span class="keyword">string</span> name,               <span class="comment">// Name of the map handle</span></span><br><span class="line">                                uvm_reg_addr_t base_addr,  <span class="comment">// The maps base address</span></span><br><span class="line">                                <span class="keyword">int</span> <span class="keyword">unsigned</span> n_bytes,      <span class="comment">// Map access width in bytes</span></span><br><span class="line">                                uvm_endianness_e endian,   <span class="comment">// The endianess of the map</span></span><br><span class="line">                                <span class="keyword">bit</span> byte_addressing=<span class="number">1</span>);    <span class="comment">// Whether byte_addressing is supported</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AHB_map = create_map(<span class="string">&quot;AHB_map&quot;</span>, <span class="number">&#x27;h0</span>, <span class="number">4</span>, UVM_LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>The <strong>n_bytes</strong> parameter is the word size (bus
width) of the bus to which the map is associated. If a register's width
exceeds the bus width, more than one bus access is needed to read and
write that register over that bus.</p></li>
<li><p>he <em>byte_addressing</em> argument affects how the address is
incremented in these consecutive accesses. For example, if
<em>n_bytes</em>=4 and <em>byte_addressing</em>=0, then an access to a
register that is 64-bits wide and at offset 0 will result in two bus
accesses at addresses 0 and 1. With <em>byte_addressing</em>=1, that
same access will result in two bus accesses at addresses 0 and 4.</p>
<p><strong>The default for <em>byte_addressing is</em>
1</strong></p></li>
<li><p>The <strong>first map</strong> to be created within a register
block is assigned to the <strong>default_map</strong> member of the
register block</p></li>
</ul>
</blockquote>
<p><img src="/2022/03/12/uvm-ral/byte_addressing.drawio.svg"
alt="byte_addressing.drawio" /></p>
<h4 id="register-adapter">Register Adapter</h4>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>uvm_reg_adapter</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Methods</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td>reg2bus</td>
<td>Overload to convert generic register access items to target bus
agent sequence items</td>
</tr>
<tr class="odd">
<td>bus2reg</td>
<td>Overload to convert target bus sequence items to register model
items</td>
</tr>
<tr class="even">
<td><strong>Properties (Of type bit)</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="odd">
<td>supports_byte_enable</td>
<td>Set to 1 if the target bus and the target bus agent supports byte
enables, else set to 0</td>
</tr>
<tr class="even">
<td>provides_responses</td>
<td>Set to 1 if the target agent driver sends separate response
sequence_items that require response handling</td>
</tr>
</tbody>
</table>
<blockquote>
<p>The <strong>provides_responses</strong> bit should be set if the
agent driver returns a separate response item (i.e.
<code>put(response)</code>, or <code>item_done(response)</code>) from
its request item</p>
</blockquote>
<h4 id="prediction">Prediction</h4>
<p>the update, or prediction, of the register model content can occur
using one of three models</p>
<h5 id="auto-prediction">Auto Prediction</h5>
<p>This mode of operation is the simplest to implement, but suffers from
the drawback that it can only keep the register model up to date with
<strong>the transfers that it initiates</strong>. If any other sequences
directly access the target sequencer to update register content, or if
there are register accesses from other DUT interfaces, then the register
model will not be updated.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_map::set_auto_predict(<span class="keyword">bit</span> on=<span class="number">1</span>); m_auto_predict = on; <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Gets the auto-predict mode setting for this map.</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span>  uvm_reg_map::get_auto_predict(); <span class="keyword">return</span> m_auto_predict; <span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>// Function: set_auto_predict</p>
<p>//</p>
<p>// Sets the auto-predict mode for his map.</p>
<p>//</p>
<p>// When <sub>on</sub> is <sub>TRUE</sub>,</p>
<p>// the register model will automatically update its
<strong>mirror</strong> (what it thinks should be in the DUT)</p>
<p>immediately after any bus read or write operation via this map.
<strong>Before</strong> a <code>uvm_reg::write</code></p>
<p>// or <code>uvm_reg::read</code> operation returns, the register's
<code>uvm_reg::predict</code> method is called to update</p>
<p>the <strong>mirrored</strong> value in the register.</p>
<p>//</p>
<p>// When <sub>on</sub> is <sub>FALSE</sub>, bus reads and writes via
this map do not</p>
<p>// automatically update the mirror. For real-time updates to the
mirror</p>
<p>// in this mode, you connect a <code>uvm_reg_predictor</code>
instance to the bus</p>
<p>// monitor. The predictor takes observed bus transactions from
the</p>
<p>// bus monitor, looks up the associated <code>uvm_reg</code> register
given</p>
<p>// the address, then calls that register's
<code>uvm_reg::predict</code> method.</p>
<p>// While more complex, this mode will capture all register
read/write</p>
<p>// activity, including that not directly descendant from calls to</p>
<p>// <code>uvm_reg::write</code> and <code>uvm_reg::read</code>.</p>
<p>//</p>
<p>// <strong>By default, auto-prediction is turned off</strong>.</p>
<p>//</p>
</blockquote>
<p><img
src="https://s3.amazonaws.com/cookbook.verification.academy/images/Reg_auto_predict.gif"
alt="Reg auto predict.gif" /></p>
<blockquote>
<p>The register model content is updated based on the register accesses
it initiates</p>
</blockquote>
<h5 id="explicit-prediction-recommended-approach">Explicit Prediction
(Recommended Approach)</h5>
<p>Explicit prediction is the <strong>default mode</strong> of
prediction</p>
<p><img
src="https://s3.amazonaws.com/cookbook.verification.academy/images/Reg_explicit_prediction.gif"
alt="Reg explicit prediction.gif" /></p>
<p>The register model content is updated via the <strong>predictor
component</strong> based on all observed bus transactions, ensuring that
register accesses made without the register model are mirrored
correctly. The predictor looks up the accessed register by address then
calls its <code>predict()</code> method</p>
<h6 id="uvm_regpredict-uvm_regdo_predict">uvm_reg::predict &amp;
uvm_reg::do_predict</h6>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// predict</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> uvm_reg::predict (uvm_reg_data_t    value,</span><br><span class="line">                               uvm_reg_byte_en_t be = -<span class="number">1</span>,</span><br><span class="line">                               uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                               uvm_path_e        path = UVM_FRONTDOOR,</span><br><span class="line">                               uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                               <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                               <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line">  uvm_reg_item rw = <span class="keyword">new</span>; </span><br><span class="line">  rw<span class="variable">.value</span>[<span class="number">0</span>] = value;</span><br><span class="line">  rw<span class="variable">.path</span> = path;</span><br><span class="line">  rw<span class="variable">.map</span> = map; </span><br><span class="line">  rw<span class="variable">.fname</span> = fname;</span><br><span class="line">  rw<span class="variable">.lineno</span> = lineno;</span><br><span class="line">  do_predict(rw, kind, be); </span><br><span class="line">  predict = (rw<span class="variable">.status</span> == UVM_NOT_OK) ? <span class="number">0</span> : <span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span>: predict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do_predict</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg::do_predict(uvm_reg_item      rw,  </span><br><span class="line">                                  uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                                  uvm_reg_byte_en_t be = -<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">   uvm_reg_data_t reg_value = rw<span class="variable">.value</span>[<span class="number">0</span>];</span><br><span class="line">   m_fname = rw<span class="variable">.fname</span>;</span><br><span class="line">   m_lineno = rw<span class="variable">.lineno</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (rw<span class="variable">.status</span> ==UVM_IS_OK )</span><br><span class="line">   rw<span class="variable">.status</span> = UVM_IS_OK;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (m_is_busy &amp;&amp; kind == UVM_PREDICT_DIRECT) <span class="keyword">begin</span></span><br><span class="line">      `uvm_warning(<span class="string">&quot;RegModel&quot;</span>, &#123;<span class="string">&quot;Trying to predict value of register &#x27;&quot;</span>,</span><br><span class="line">                  get_full_name(),<span class="string">&quot;&#x27; while it is being accessed&quot;</span>&#125;)</span><br><span class="line">      rw<span class="variable">.status</span> = UVM_NOT_OK;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">end</span>  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">foreach</span> (m_fields[i]) <span class="keyword">begin</span></span><br><span class="line">      rw<span class="variable">.value</span>[<span class="number">0</span>] = (reg_value &gt;&gt; m_fields[i]<span class="variable">.get_lsb_pos</span>()) &amp;</span><br><span class="line">                                 ((<span class="number">1</span> &lt;&lt; m_fields[i]<span class="variable">.get_n_bits</span>())-<span class="number">1</span>);</span><br><span class="line">      m_fields[i]<span class="variable">.do_predict</span>(rw, kind, be&gt;&gt;(m_fields[i]<span class="variable">.get_lsb_pos</span>()/<span class="number">8</span>));</span><br><span class="line">   <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line">   rw<span class="variable">.value</span>[<span class="number">0</span>] = reg_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: do_predict</span><br></pre></td></tr></table></figure>
<h6
id="uvm_reg_fieldpredict-uvm_reg_fielddo_predict">uvm_reg_field::predict
&amp; uvm_reg_field::do_predict</h6>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// predict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> uvm_reg_field::predict (uvm_reg_data_t    value,</span><br><span class="line">                                     uvm_reg_byte_en_t be = -<span class="number">1</span>,</span><br><span class="line">                                     uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                                     uvm_path_e        path = UVM_FRONTDOOR,</span><br><span class="line">                                     uvm_reg_map       map = <span class="literal">null</span>,</span><br><span class="line">                                     <span class="keyword">string</span>            fname = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                     <span class="keyword">int</span>               lineno = <span class="number">0</span>);</span><br><span class="line">  uvm_reg_item rw = <span class="keyword">new</span>;</span><br><span class="line">  rw<span class="variable">.value</span>[<span class="number">0</span>] = value;</span><br><span class="line">  rw<span class="variable">.path</span> = path;</span><br><span class="line">  rw<span class="variable">.map</span> = map;</span><br><span class="line">  rw<span class="variable">.fname</span> = fname;</span><br><span class="line">  rw<span class="variable">.lineno</span> = lineno;</span><br><span class="line">  do_predict(rw, kind, be);</span><br><span class="line">  predict = (rw<span class="variable">.status</span> == UVM_NOT_OK) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endfunction</span>: predict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do_predict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_field::do_predict(uvm_reg_item      rw,</span><br><span class="line">                                        uvm_predict_e     kind = UVM_PREDICT_DIRECT,</span><br><span class="line">                                        uvm_reg_byte_en_t be = -<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">   uvm_reg_data_t field_val = rw<span class="variable">.value</span>[<span class="number">0</span>] &amp; ((<span class="number">1</span> &lt;&lt; m_size)-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (rw<span class="variable">.status</span> != UVM_NOT_OK)</span><br><span class="line">     rw<span class="variable">.status</span> = UVM_IS_OK;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Assume that the entire field is enabled</span></span><br><span class="line">   <span class="keyword">if</span> (!be[<span class="number">0</span>])</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   m_fname = rw<span class="variable">.fname</span>;</span><br><span class="line">   m_lineno = rw<span class="variable">.lineno</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> (kind)</span><br><span class="line"></span><br><span class="line">     UVM_PREDICT_WRITE:</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         uvm_reg_field_cb_iter cbs = <span class="keyword">new</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (rw<span class="variable">.path</span> == UVM_FRONTDOOR || rw<span class="variable">.path</span> == UVM_PREDICT)</span><br><span class="line">            field_val = XpredictX(m_mirrored, field_val, rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">         m_written = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (uvm_reg_cbs cb = cbs<span class="variable">.first</span>(); cb != <span class="literal">null</span>; cb = cbs<span class="variable">.next</span>())</span><br><span class="line">            cb<span class="variable">.post_predict</span>(<span class="keyword">this</span>, m_mirrored, field_val, </span><br><span class="line">                            UVM_PREDICT_WRITE, rw<span class="variable">.path</span>, rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">         field_val &amp;= (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">     UVM_PREDICT_READ:</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         uvm_reg_field_cb_iter cbs = <span class="keyword">new</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (rw<span class="variable">.path</span> == UVM_FRONTDOOR || rw<span class="variable">.path</span> == UVM_PREDICT) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> acc = get_access(rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="string">&quot;RC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;WRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;WSRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;W1SRC&quot;</span> ||</span><br><span class="line">                acc == <span class="string">&quot;W0SRC&quot;</span>)</span><br><span class="line">              field_val = <span class="number">0</span>;  <span class="comment">// (clear)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (acc == <span class="string">&quot;RS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WCRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;W1CRS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;W0CRS&quot;</span>)</span><br><span class="line">              field_val = (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>; <span class="comment">// all 1&#x27;s (set)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (acc == <span class="string">&quot;WO&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WOC&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WOS&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;WO1&quot;</span> ||</span><br><span class="line">                     acc == <span class="string">&quot;NOACCESS&quot;</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (uvm_reg_cbs cb = cbs<span class="variable">.first</span>(); cb != <span class="literal">null</span>; cb = cbs<span class="variable">.next</span>())</span><br><span class="line">            cb<span class="variable">.post_predict</span>(<span class="keyword">this</span>, m_mirrored, field_val,</span><br><span class="line">                            UVM_PREDICT_READ, rw<span class="variable">.path</span>, rw<span class="variable">.map</span>);</span><br><span class="line"></span><br><span class="line">         field_val &amp;= (<span class="number">&#x27;b1</span> &lt;&lt; m_size)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">     UVM_PREDICT_DIRECT:</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">if</span> (m_parent<span class="variable">.is_busy</span>()) <span class="keyword">begin</span></span><br><span class="line">           `uvm_warning(<span class="string">&quot;RegModel&quot;</span>, &#123;<span class="string">&quot;Trying to predict value of field &#x27;&quot;</span>,</span><br><span class="line">              get_name(),<span class="string">&quot;&#x27; while register &#x27;&quot;</span>,m_parent<span class="variable">.get_full_name</span>(),</span><br><span class="line">              <span class="string">&quot;&#x27; is being accessed&quot;</span>&#125;)</span><br><span class="line">           rw<span class="variable">.status</span> = UVM_NOT_OK;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// update the mirror with predicted value</span></span><br><span class="line">   m_mirrored = field_val;</span><br><span class="line">   m_desired  = field_val;</span><br><span class="line">   <span class="keyword">this</span><span class="variable">.value</span> = field_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: do_predict</span><br></pre></td></tr></table></figure>
<h6 id="uvm_access_e">uvm_access_e</h6>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum: uvm_access_e</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Type of operation begin performed</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UVM_READ     - Read operation</span></span><br><span class="line"><span class="comment">// UVM_WRITE    - Write operation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">      UVM_READ,</span><br><span class="line">      UVM_WRITE,</span><br><span class="line">      UVM_BURST_READ,</span><br><span class="line">      UVM_BURST_WRITE</span><br><span class="line">   &#125; uvm_access_e;</span><br></pre></td></tr></table></figure>
<h6 id="uvm_predict_e">uvm_predict_e</h6>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum: uvm_predict_e</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// How the mirror is to be updated</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UVM_PREDICT_DIRECT  - Predicted value is as-is</span></span><br><span class="line"><span class="comment">// UVM_PREDICT_READ    - Predict based on the specified value having been read</span></span><br><span class="line"><span class="comment">// UVM_PREDICT_WRITE   - Predict based on the specified value having been written</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">      UVM_PREDICT_DIRECT,</span><br><span class="line">      UVM_PREDICT_READ,</span><br><span class="line">      UVM_PREDICT_WRITE</span><br><span class="line">   &#125; uvm_predict_e;</span><br></pre></td></tr></table></figure>
<h6 id="uvm_path_e">uvm_path_e</h6>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum: uvm_path_e</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Path used for register operation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UVM_FRONTDOOR    - Use the front door</span></span><br><span class="line"><span class="comment">// UVM_BACKDOOR     - Use the back door</span></span><br><span class="line"><span class="comment">// UVM_PREDICT      - Operation derived from observations by a bus monitor via</span></span><br><span class="line"><span class="comment">//                    the &lt;uvm_reg_predictor&gt; class.</span></span><br><span class="line"><span class="comment">// UVM_DEFAULT_PATH - Operation specified by the context</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">      UVM_FRONTDOOR,</span><br><span class="line">      UVM_BACKDOOR,</span><br><span class="line">      UVM_PREDICT,</span><br><span class="line">      UVM_DEFAULT_PATH</span><br><span class="line">   &#125; uvm_path_e;</span><br></pre></td></tr></table></figure>
<h5 id="passive-prediction">Passive Prediction</h5>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>UVM REG RALF &amp; IP-XACT</title>
    <url>/2022/03/14/uvm-reg-ralf/</url>
    <content><![CDATA[<h2 id="uvm_reg_field">uvm_reg_field</h2>
<p>There are no properties for <strong>unused</strong> or
<strong>reserved</strong> fields, and unlike register arrays</p>
<h3 id="ralf">ralf</h3>
<ul>
<li>bytes: the register size, default is <em>N*8 &gt; all
field</em></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">register CTRL &#123;</span><br><span class="line">   left_to_right;</span><br><span class="line">   field unused &#123;bits 6;&#125;</span><br><span class="line">    field HC1R &#123;</span><br><span class="line">    bits 1; access rw  ;</span><br><span class="line">    coverpoint &#123; bins x = &#123;0,1&#125;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    field HC1E &#123;bits 1 ; access rw &#125;</span><br><span class="line">    field unused &#123;bits 2; &#125;</span><br><span class="line">    field HC0R &#123;bits 1; access rw &#125;</span><br><span class="line">    field HCOE &#123;bits 1 ; access rw &#125;</span><br><span class="line">    field unused &#123;bits 2; &#125;</span><br><span class="line">    field BL &#123;bits 1; access rw &#125;</span><br><span class="line">    field CSL &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field VSL &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field HSL &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field PC &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field CD &#123;bits 2 ; access rw&#125;</span><br><span class="line">    field VBL &#123;bits 2 ; access rw&#125;</span><br><span class="line">    field CBSWE &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field VBSWE &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field CBSIE &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field VBSIE &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field HIE  &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field VIE  &#123;bits 1 ; access rw&#125;</span><br><span class="line">    field VEN  &#123;bits 1 ; access rw&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="generated-sv">generated sv</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build();</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HC1R</span> = uvm_reg_field::type_id::create(<span class="string">&quot;HC1R&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HC1R</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HC1E</span> = uvm_reg_field::type_id::create(<span class="string">&quot;HC1E&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HC1E</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HC0R</span> = uvm_reg_field::type_id::create(<span class="string">&quot;HC0R&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HC0R</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HCOE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;HCOE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HCOE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.BL</span> = uvm_reg_field::type_id::create(<span class="string">&quot;BL&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.BL</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CSL</span> = uvm_reg_field::type_id::create(<span class="string">&quot;CSL&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CSL</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VSL</span> = uvm_reg_field::type_id::create(<span class="string">&quot;VSL&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VSL</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HSL</span> = uvm_reg_field::type_id::create(<span class="string">&quot;HSL&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HSL</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.PC</span> = uvm_reg_field::type_id::create(<span class="string">&quot;PC&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.PC</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CD</span> = uvm_reg_field::type_id::create(<span class="string">&quot;CD&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CD</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">2&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VBL</span> = uvm_reg_field::type_id::create(<span class="string">&quot;VBL&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VBL</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">2&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CBSWE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;CBSWE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CBSWE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VBSWE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;VBSWE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VBSWE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CBSIE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;CBSIE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.CBSIE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VBSIE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;VBSIE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VBSIE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HIE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;HIE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.HIE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VIE</span> = uvm_reg_field::type_id::create(<span class="string">&quot;VIE&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VIE</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VEN</span> = uvm_reg_field::type_id::create(<span class="string">&quot;VEN&quot;</span>,,get_full_name());</span><br><span class="line">     <span class="keyword">this</span><span class="variable">.VEN</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>, <span class="number">1&#x27;h0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build </span><br></pre></td></tr></table></figure>
<h2 id="uvm_reg_block">uvm_reg_block</h2>
<h3 id="ralf-1">ralf</h3>
<ul>
<li>bytes : bus width</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">block vga_lcd  &#123;</span><br><span class="line">    bytes 4;</span><br><span class="line">    endian little;</span><br><span class="line">    </span><br><span class="line">    register STAT (`RAL_HDL_PATH.wbs.stat[31:0]) @0004;</span><br><span class="line">    register HTIM (`RAL_HDL_PATH.htim[31:0]) @0008;</span><br><span class="line">    register CTRL (`RAL_HDL_PATH.wbs.ctrl[31:0]) @00010;</span><br><span class="line">    register VTIM (`RAL_HDL_PATH.vtim[31:0]) @0012;</span><br><span class="line">    register C1CR (`RAL_HDL_PATH.c1cr[31:0]) @0016;</span><br><span class="line">    memory CLUT1  @&#x27;h0C00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="generated-sv-1">generated sv</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span> = create_map(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">4</span>, UVM_LITTLE_ENDIAN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span><span class="variable">.STAT</span> = ral_reg_STAT::type_id::create(<span class="string">&quot;STAT&quot;</span>,,get_full_name());</span><br><span class="line"><span class="keyword">this</span><span class="variable">.STAT</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.STAT</span><span class="variable">.build</span>();</span><br><span class="line"><span class="keyword">this</span><span class="variable">.STAT</span><span class="variable">.add_hdl_path</span>(&#x27;&#123; &#x27;&#123;<span class="string">&quot;wbs.stat[31:0]&quot;</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span><span class="variable">.add_reg</span>(<span class="keyword">this</span><span class="variable">.STAT</span>, `UVM_REG_ADDR_WIDTH&#x27;h4, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span><span class="variable">.HTIM</span> = ral_reg_HTIM::type_id::create(<span class="string">&quot;HTIM&quot;</span>,,get_full_name()); </span><br><span class="line"><span class="keyword">this</span><span class="variable">.HTIM</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.HTIM</span><span class="variable">.build</span>();</span><br><span class="line"><span class="keyword">this</span><span class="variable">.HTIM</span><span class="variable">.add_hdl_path</span>(&#x27;&#123;&#x27;&#123;<span class="string">&quot;htim[31:0]&quot;</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125; &#125;); </span><br><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span><span class="variable">.add_reg</span>(<span class="keyword">this</span><span class="variable">.HTIM</span>, `UVM_REG_ADDR_WIDTH&#x27;h8, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span><span class="variable">.CTRL</span> = ral_reg_CTRL::type_id::create(<span class="string">&quot;CTRL&quot;</span>,,get_full_name());</span><br><span class="line"><span class="keyword">this</span><span class="variable">.CTRL</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>); </span><br><span class="line"><span class="keyword">this</span><span class="variable">.CTRL</span><span class="variable">.build</span>(); </span><br><span class="line"><span class="keyword">this</span><span class="variable">.CTRL</span><span class="variable">.add_hdl_path</span>(&#x27;&#123;&#x27;&#123;<span class="string">&quot;wbs.ctrl[31:0]&quot;</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span><span class="variable">.add_reg</span>(<span class="keyword">this</span><span class="variable">.CTRL</span>, `UVM_REG_ADDR_WIDTH&#x27;hA, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span><span class="variable">.VTIM</span> = ral_reg_VTIM::type_id::create(<span class="string">&quot;VTIM&quot;</span>,,get_full_name()); </span><br><span class="line"><span class="keyword">this</span><span class="variable">.VTIM</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.VTIM</span><span class="variable">.build</span>();</span><br><span class="line"><span class="keyword">this</span><span class="variable">.VTIM</span><span class="variable">.add_hdl_path</span>(&#x27;&#123; &#x27;&#123;<span class="string">&quot;vtim[31:0]&quot;</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125; &#125;); </span><br><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span><span class="variable">.add_reg</span>(<span class="keyword">this</span><span class="variable">.VTIM</span>, `UVM_REG_ADDR_WIDTH&#x27;hC, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span><span class="variable">.C1CR</span> = ral_reg_C1CR::type_id::create(<span class="string">&quot;C1CR&quot;</span>,,get_full_name());</span><br><span class="line"><span class="keyword">this</span><span class="variable">.C1CR</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.C1CR</span><span class="variable">.build</span>();</span><br><span class="line"><span class="keyword">this</span><span class="variable">.C1CR</span><span class="variable">.add_hdl_path</span>(&#x27;&#123; &#x27;&#123;<span class="string">&quot;c1cr[31:0]&quot;</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span><span class="variable">.add_reg</span>(<span class="keyword">this</span><span class="variable">.C1CR</span>, `UVM_REG_ADDR_WIDTH&#x27;h10, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span><span class="variable">.CLUT1</span> = ral_mem_CLUT1::type_id::create(<span class="string">&quot;CLUT1&quot;</span>,,get_full_name());</span><br><span class="line"><span class="keyword">this</span><span class="variable">.CLUT1</span><span class="variable">.configure</span>(<span class="keyword">this</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.CLUT1</span><span class="variable">.build</span>();</span><br><span class="line"><span class="keyword">this</span><span class="variable">.default_map</span><span class="variable">.add_mem</span>(<span class="keyword">this</span><span class="variable">.CLUT1</span>, `UVM_REG_ADDR_WIDTH&#x27;hC00, <span class="string">&quot;RW&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ral_reg_CTRL <span class="keyword">extends</span> uvm_reg;</span><br><span class="line"><span class="keyword">class</span> ral_reg_STAT <span class="keyword">extends</span> uvm_reg;</span><br><span class="line"><span class="keyword">class</span> ral_reg_HTIM <span class="keyword">extends</span> uvm_reg;</span><br><span class="line"><span class="keyword">class</span> ral_reg_VTIM <span class="keyword">extends</span> uvm_reg;</span><br><span class="line"><span class="keyword">class</span> ral_reg_C1CR <span class="keyword">extends</span> uvm_reg;</span><br><span class="line"><span class="keyword">class</span> ral_mem_CLUT1 <span class="keyword">extends</span> uvm_mem;</span><br><span class="line"><span class="keyword">class</span> ral_block_vga_lcd <span class="keyword">extends</span> uvm_reg_block;</span><br></pre></td></tr></table></figure>
<h2 id="ralgen-command">ralgen command</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ralgen -uvm -t dut_regmodel0 vga_lcd_env.ralf</span><br></pre></td></tr></table></figure>
<h2 id="byte-or-halfword-access">BYTE or HALFWORD access</h2>
<p>User is verifying 32 bit registers and the design also allows the
BYTE (8 bits) and HALFWORD (16 bits) accesses.</p>
<blockquote>
<p>this is achieved by setting the <strong>bit_addressing=0</strong>
field in the <strong>uvm_reg_block::create_map</strong> function.</p>
<p>Using <code>create_map</code> in <code>uvm_reg_block</code>, you can
change the type of addressing scheme you want to use; namely BYTE or
HALFWORD.</p>
</blockquote>
<p><strong>create_map</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> uvm_reg_map create_map( <span class="keyword">string</span> name,</span><br><span class="line">                                       uvm_reg_addr_t base_addr,</span><br><span class="line">                                       <span class="keyword">int</span> <span class="keyword">unsigned</span> n_bytes,</span><br><span class="line">                                       uvm_endianness_e endian,</span><br><span class="line">                                       <span class="keyword">bit</span> byte_addressing)</span><br></pre></td></tr></table></figure>
<p>Creates an address map with the specified name, then configures it
with the following properties:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>base_addr</td>
<td>It is the base address for the map. All registers, memories, and
sub-blocks within the map will be at offsets to this address.</td>
</tr>
<tr class="even">
<td>n_bytes</td>
<td>It is the byte-width of the bus on which this map is used</td>
</tr>
<tr class="odd">
<td>endian</td>
<td>It is the endian format. See uvm_endianness_e for possible
values.</td>
</tr>
<tr class="even">
<td>byte_addressing</td>
<td>It specifies whether consecutive addresses referred are <strong>1
byte apart (TRUE)</strong> or <strong>n_bytes apart (FALSE)</strong>.
Default is TRUE.</td>
</tr>
</tbody>
</table>
<ul>
<li>For HALFWORD addressing, you should call create_map the following
way:</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">default_map = create_map(get_name(), <span class="number">0</span>, <span class="number">2</span>, UVM_LITTLE_ENDIAN, <span class="number">0</span>); <span class="comment">// 32 bit registers offset are 0x00, 0x02, 0x04</span></span><br></pre></td></tr></table></figure>
<ul>
<li>For WORD addressing</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">default_map = create_map(get_name(), <span class="number">0</span>, <span class="number">4</span>, UVM_LITTLE_ENDIAN, <span class="number">0</span>); <span class="comment">// 32 bit registers offset are 0x00, 0x01, 0x02</span></span><br></pre></td></tr></table></figure>
<ul>
<li>For BYTE addressing (default) :</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">default_map = create_map(get_name(), <span class="number">0</span>, <span class="number">4</span>, UVM_LITTLE_ENDIAN, <span class="number">1</span>); <span class="comment">// 32 bit registers offset are 0x00, 0x04, 0x08</span></span><br></pre></td></tr></table></figure>
<ul>
<li>BYTE width and byte addressing</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">default_map = create_map(get_name(), <span class="number">0</span>, <span class="number">1</span>, UVM_LITTLE_ENDIAN, <span class="number">1</span>); <span class="comment">// 32 bit registers offset are 0x00, 0x04, 0x08 </span></span><br></pre></td></tr></table></figure>
<h2 id="uvm_reg_blockcreate_map">uvm_reg_block::create_map</h2>
<p>Create an address map in this block</p>
<blockquote>
<p>n_bytes - the byte-width of the bus on which this map is used</p>
<p>byte_addressing - specifies whether consecutive addresses refer are 1
byte apart (TRUE) or <code>n_bytes</code> apart (FALSE). Default is
TRUE.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> uvm_reg_map uvm_reg_block::create_map(<span class="keyword">string</span> name,</span><br><span class="line">                                               uvm_reg_addr_t base_addr,</span><br><span class="line">                                               <span class="keyword">int</span> <span class="keyword">unsigned</span> n_bytes,</span><br><span class="line">                                               uvm_endianness_e endian,</span><br><span class="line">                                               <span class="keyword">bit</span> byte_addressing=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   uvm_reg_map  map; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span><span class="variable">.locked</span>) <span class="keyword">begin</span></span><br><span class="line">      `uvm_error(<span class="string">&quot;RegModel&quot;</span>, <span class="string">&quot;Cannot add map to locked model&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line">   map = uvm_reg_map::type_id::create(name,,<span class="keyword">this</span><span class="variable">.get_full_name</span>());</span><br><span class="line">   map<span class="variable">.configure</span>(<span class="keyword">this</span>,base_addr,n_bytes,endian,byte_addressing);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span><span class="variable">.maps</span>[map] = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">if</span> (maps<span class="variable">.num</span>() == <span class="number">1</span>)</span><br><span class="line">     default_map = map; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> map; </span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h2 id="uvm_reg_mapadd_reg">uvm_reg_map::add_reg</h2>
<p>The register is located at the specified address <em>offset</em> from
this maps configured base address.</p>
<p>The number of consecutive physical addresses occupied by the register
depends on the width of the register and the number of bytes in the
physical interface corresponding to this address map.</p>
<p>If <em>unmapped</em> is TRUE, the register does not occupy any
physical addresses and the base address is ignored. Unmapped registers
require a user-defined <em>frontdoor</em> to be specified.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> uvm_reg_map::add_reg(uvm_reg rg,  </span><br><span class="line">                                   uvm_reg_addr_t offset,</span><br><span class="line">                                   <span class="keyword">string</span> rights = <span class="string">&quot;RW&quot;</span>,</span><br><span class="line">                                   <span class="keyword">bit</span> unmapped=<span class="number">0</span>,</span><br><span class="line">                                   uvm_reg_frontdoor frontdoor=<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (m_regs_info<span class="variable">.exists</span>(rg)) <span class="keyword">begin</span></span><br><span class="line">      `uvm_error(<span class="string">&quot;RegModel&quot;</span>, &#123;<span class="string">&quot;Register &#x27;&quot;</span>,rg<span class="variable">.get_name</span>(),</span><br><span class="line">                 <span class="string">&quot;&#x27; has already been added to map &#x27;&quot;</span>,get_name(),<span class="string">&quot;&#x27;&quot;</span>&#125;)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (rg<span class="variable">.get_parent</span>() != get_parent()) <span class="keyword">begin</span></span><br><span class="line">      `uvm_error(<span class="string">&quot;RegModel&quot;</span>,</span><br><span class="line">         &#123;<span class="string">&quot;Register &#x27;&quot;</span>,rg<span class="variable">.get_full_name</span>(),<span class="string">&quot;&#x27; may not be added to address map &#x27;&quot;</span>,</span><br><span class="line">          get_full_name(),<span class="string">&quot;&#x27; : they are not in the same block&quot;</span>&#125;)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">end</span>  </span><br><span class="line">   </span><br><span class="line">   rg<span class="variable">.add_map</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">   uvm_reg_map_info info = <span class="keyword">new</span>; </span><br><span class="line">   info<span class="variable">.offset</span>   = offset;</span><br><span class="line">   info<span class="variable">.rights</span>   = rights;</span><br><span class="line">   info<span class="variable">.unmapped</span> = unmapped;</span><br><span class="line">   info<span class="variable">.frontdoor</span> = frontdoor;</span><br><span class="line">   m_regs_info[rg] = info;</span><br><span class="line">   <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h2 id="register-defines">Register Defines</h2>
<h3 id="uvm_reg_addr_width">`UVM_REG_ADDR_WIDTH</h3>
<p>Maximum address width in bits</p>
<blockquote>
<p>Default value is 64. Used to define the <uvm_reg_addr_t> type.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> UVM_REG_ADDR_WIDTH</span></span><br><span class="line"> <span class="meta">`<span class="keyword">define</span> UVM_REG_ADDR_WIDTH 64</span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="uvm_reg_data_width">`UVM_REG_DATA_WIDTH</h3>
<p>Maximum data width in bits</p>
<blockquote>
<p>Default value is 64. Used to define the <uvm_reg_data_t> type.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> UVM_REG_DATA_WIDTH</span></span><br><span class="line"> <span class="meta">`<span class="keyword">define</span> UVM_REG_DATA_WIDTH 64</span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="generic-ralf-features-and-ip-xact-mapping">Generic RALF Features
and IP-XACT Mapping</h2>
<h3 id="field">field</h3>
<p><img src="/2022/03/14/uvm-reg-ralf/image-20220314212141988.png"
alt="image-20220314212141988" /></p>
<h3 id="register">register</h3>
<h4 id="addressoffset">addressOffset</h4>
<p>a register has an <code>addressOffset</code> that describes the
location of the register expressed in <code>addressUnitBits</code> as
offset to the starting address of the containing
<code>addressBlock</code> or the containing
<code>registerFile</code></p>
<h4 id="addressunitbits">addressUnitBits</h4>
<p>The <code>addressUnitBits</code> element describes the number of bits
of an address increment between two <strong>consecutive addressable
units</strong> in the <code>addressSpace</code>. If
<code>addressUnitBits</code> is not described, then its value
<strong>defaults to 8</strong>, indicating a
<strong>byte-addressable</strong> <code>addressSpace</code></p>
<p><img src="/2022/03/14/uvm-reg-ralf/image-20220314212217722.png"
alt="image-20220314212217722" /></p>
<h3 id="block">block</h3>
<p><img src="/2022/03/14/uvm-reg-ralf/image-20220314212251012.png"
alt="image-20220314212251012" /></p>
<h3 id="memory">memory</h3>
<p><img src="/2022/03/14/uvm-reg-ralf/image-20220314212427347.png"
alt="image-20220314212427347" /></p>
<h2 id="reference">Reference</h2>
<p>UVM Register Abstraction Layer Generator User Guide, S-2021.09-SP1,
December 2021</p>
<p><a
href="https://www.accellera.org/images/downloads/standards/ip-xact/IP-XACT_User_Guide_2018-02-16.pdf">User
guide for the IEEE 1685 Standard for IP-XACT</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>Process Variation</title>
    <url>/2022/03/02/variation/</url>
    <content><![CDATA[<h4 id="process-corners">Process Corners</h4>
<p><img src="/2022/03/02/variation/image-20220302000743092.png"
alt="image-20220302000743092" /></p>
<h4 id="globallocal-variation">Global/Local Variation</h4>
<p><img src="/2022/03/02/variation/image-20220302000808679.png"
alt="image-20220302000808679" /></p>
<h4 id="timing-and-rc-modeling-with-process-corners">Timing and RC
Modeling with Process Corners</h4>
<p><img src="/2022/03/02/variation/image-20220302000916728.png"
alt="image-20220302000916728" /></p>
<h4 id="global-and-local-variation-by-gaussian">Global and Local
variation by Gaussian</h4>
<p><img src="/2022/03/02/variation/image-20230111003336823.png"
alt="image-20230111003336823" /></p>
<blockquote>
<p>Local Monte-Carlo (<strong>SSG, FFG with Local Gaussian</strong>) as
Signoff golden</p>
</blockquote>
<p><img src="/2022/03/02/variation/image-20231215234014594.png"
alt="image-20231215234014594" /></p>
<h4 id="process-corner-model-limitations">Process Corner Model
Limitations</h4>
<p><img src="/2022/03/02/variation/image-20220323232119661.png"
alt="image-20220323232119661" /></p>
<p><img src="/2022/03/02/variation/image-20230111003705417.png"
alt="image-20230111003705417" /></p>
<p>Variation section</p>
<ul>
<li>Total corner (TT/SS/FF/SF/FS)
<ul>
<li>E.g. TTMacro_MOS_MOS_MOSCAP</li>
</ul></li>
<li>Global Corner (TTG/SSG/FFG/SFG/FSG) + Local MC
<ul>
<li>E.g. TTGlobalCorner_LocalMC_MOS_MOSCAP</li>
</ul></li>
<li>Local MC
<ul>
<li>E.g. LocalMCOnly_MOS_MOSCAP</li>
</ul></li>
<li>Global MC + Local MC (Total MC)
<ul>
<li>GlobalMC_LocalMC_MOS_MOSCAP</li>
</ul></li>
</ul>
<p><img src="/2022/03/02/variation/image-20230308003005235.png"
alt="image-20230308003005235" /></p>
<p><img src="/2022/03/02/variation/image-20230111010426775.png"
alt="image-20230111010426775" /></p>
<p><img
src="/2022/03/02/variation/Screen-Shot-2014-09-11-at-8.47.06-AM.png"
alt="img" /></p>
<p><img src="/2022/03/02/variation/image-20230111011757049.png"
alt="image-20230111011757049" /></p>
<blockquote>
<p><strong>SSGNP, FFGNP</strong>:</p>
<p>When N/P global correlation is weak (R^2=0.15), the corner of N/PMOS
balance circuit (e.g. inverter) can be tightened (<strong>3sigma -&gt;
2.5sgma</strong>) due to the <strong>cancellation</strong> between NMOS
and PMOS</p>
<p>SSGNP, FFGNP usually used in Digital STA</p>
</blockquote>
<blockquote>
<ul>
<li><strong>Global variation</strong> validation with <strong>global
corner</strong>
<ul>
<li><strong>3-sigma of global MC</strong> simulation is aligned with
<strong>global corner</strong></li>
</ul></li>
<li><strong>Total variation</strong> validation with <strong>total
corner</strong>
<ul>
<li><strong>3-sigma of global MC + local MC (total)</strong> simulation
is aligned with <strong>total corner</strong></li>
</ul></li>
</ul>
</blockquote>
<h4 id="global-corner">Global Corner</h4>
<blockquote>
<p><a
href="https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/20466/monte-carlo-simulation-global-local-vs-local-and-process-vs-mismatch/1365101#1365101">https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/20466/monte-carlo-simulation-global-local-vs-local-and-process-vs-mismatch/1365101#1365101</a></p>
<p>The <strong>"total corner"</strong> is representative of the maximum
device parameter variation including local device variation effects.
However, it is not a statistical corner.</p>
<p>The <strong>"global" corner</strong> is defined as the
<strong>"total" corner minus the impact of "local
variation"</strong></p>
<p>Hence, if you were to examine simulation results for a parameter
using a "total" and "global" corner, you would find the range of
variation will be less with the "global" corner than with the "total"
corner.</p>
<p>The "global" corner is provided for use in <strong>statistical
simulations</strong>. Hence, when performing a Monte-Carlo simulation,
the "global" corner is selected - NOT the "total" corner.</p>
</blockquote>
<p><img src="/2022/03/02/variation/image-20230511234313012.png"
alt="image-20230511234313012" /></p>
<p><span class="math display">\[
\Delta V_{T,\sigma_{total}} = \sqrt{\Delta^2 _{T,
\sigma_{global}}+\Delta^2 _{T, \sigma_{local}}}
\]</span></p>
<h4 id="reference">reference</h4>
<p>Eric J.-W. Fang, T5: Fundamentals of Process Monitors for
Signoff-Oriented Circuit Design, 2022 IEEE International Solid-State
Circuits Conference</p>
<p>Alvin Loke, Device and Physical Design Considerations for Circuits in
FinFET Technology, ISSCC 2020 Short Course</p>
<p>簡報 Cln16ffcll Sr V1d0 2p1 Usage Guide URL: <a
href="https://usermanual.wiki/Document/cln16ffcllsrv1d02p1usageguide.1649731847/view">https://usermanual.wiki/Document/cln16ffcllsrv1d02p1usageguide.1649731847/view</a></p>
<p>Radojcic, Riko, Dan Perry and Mark Nakamoto. “Design for
manufacturability for fabless manufactuers.” <em>IEEE Solid-State
Circuits Magazine</em> 1 (2009): n. pag.</p>
<p>How To Reduce Implementation Headaches In FinFET Processes URL: <a
href="https://semiengineering.com/how-to-reduce-implementation-headaches-in-finfet-processes/">https://semiengineering.com/how-to-reduce-implementation-headaches-in-finfet-processes/</a></p>
<p>陌上风骑驴看IC, STA | SSGNP, FFGNP. <a
href="https://mp.weixin.qq.com/s/eJ8fYRJBR1E9XbfH95OUOg">https://mp.weixin.qq.com/s/eJ8fYRJBR1E9XbfH95OUOg</a></p>
<p>陌上风骑驴看IC, STA | ssg 跟ss corner 的区别——谬误更正版 <a
href="https://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247486225&amp;idx=1&amp;sn=e9c68f6108ae6c9958d47ca0b29373ca&amp;chksm=fad262cfcda5ebd949cc91353c7cbfaf4ba61179306f7d8e98461a4f4ca9d8a9baef5e9f2cc1&amp;scene=178&amp;cur_album_id=1326356275000705025#rd">https://mp.weixin.qq.com/s?__biz=MzUzODczODg2NQ==&amp;mid=2247486225&amp;idx=1&amp;sn=e9c68f6108ae6c9958d47ca0b29373ca&amp;chksm=fad262cfcda5ebd949cc91353c7cbfaf4ba61179306f7d8e98461a4f4ca9d8a9baef5e9f2cc1&amp;scene=178&amp;cur_album_id=1326356275000705025#rd</a></p>
<p>The Evolution, Pitfalls, and Cargo Cult Engineering of Advanced
Digital Timing Sign-off <a
href="https://www.tauworkshop.com/2021/speaker_slides/christian_l.pdf">https://www.tauworkshop.com/2021/speaker_slides/christian_l.pdf</a></p>
<p>Don O'Riordan Cadence Design Systems. Recommended Spectre Monte Carlo
modeling methodology [<a
href="https://designers-guide.org/modeling/montecarlo.pdf">https://designers-guide.org/modeling/montecarlo.pdf</a>]</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>VCS &amp; Verdi</title>
    <url>/2022/02/08/vcs-verdi/</url>
    <content><![CDATA[<h2 id="vcs-with-customized-uvm-version">VCS with customized UVM
version</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uvm 1.1 customized</span></span><br><span class="line">$ <span class="built_in">export</span> VCS_UVM_HOME=<span class="string">&quot;path/to/uvm-1.1d/src&quot;</span></span><br><span class="line">$ vcs -full64 -debug_access+all -kdb -sverilog -ntb_opts uvm -timescale=1ns/1ps -f filelist.f</span><br><span class="line">$ ./simv -gui=verdi</span><br></pre></td></tr></table></figure>
<h2 id="vcs-with-release-uvm">VCS with release UVM</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vcs -full64 -debug_access+all -kdb -sverilog -ntb_opts uvm-1.2</span><br></pre></td></tr></table></figure>
<h2 id="vcs-compile-time-options">VCS compile-time options</h2>
<p><strong>-kdb</strong>: Enables generating Verdi KDB database</p>
<p><strong>-lca</strong>: Enables Limited Customer Availability feature,
which is not fully test</p>
<p><strong>+vpi</strong>: Enables the use of VPI PLI access
routines.</p>
<p>​ <em>Verilog PLI (Programming Language Interface) is a mechanism to
invoke C or C++ functions from Verilog code.</em></p>
<p><strong>-P &lt;pli.tab&gt;</strong>: Specifies a PLI table file</p>
<p>​ <code>$&#123;VERDI_HOME&#125;/share/PLI/VCS/LINUX64/novas.tb</code></p>
<p><img src="/2022/02/08/vcs-verdi/image-20220603221739973.png"
alt="image-20220603221739973" /></p>
<p><strong>+define+<macro_name>=<value></strong>: Define a text macro,
Test for this definition in your Verilog source code using the
`<code>ifdef</code> compiler directive</p>
<p><code>+define+SIMULATION</code> when compiling</p>
<p>`<code>ifdef SIMULATOIN</code> in code</p>
<p><strong>-debug_access</strong>: Enables dumping to FSDB/VPD, and
limited read/callback capability. Use <code>-debug_access+classs</code>
for testbench debug, and <code>debug_access+all</code> for all debug
capabilities. Refer the VCS user guide for more granular options for
debug control under the switch <code>debug_access</code> and refer to
<code>debug_region</code> for region control</p>
<p><strong>-y <directory_pathname></strong>: Specifies a Verilog library
directory to search for module definitons</p>
<p><strong>-v &lt;filename&gt;</strong>: Specifies a Verilog library
file to search for module definitons</p>
<p><strong>+nospecify</strong>: Suppresses module path delays and time
checks in specify blocks</p>
<p><strong>-l &lt;filename&gt;</strong>: (lower case L) Specifies a log
file where VCS records compilation message and runtime messages if you
include the -R, -RI, or -RIG option</p>
<p><strong>+vcs+fsdbon</strong>: A <strong>compile-time</strong>
substitute for <code>$fsdbDumpvars</code> system task. The
<em>+vcs+fsdbon</em> switch enables dumping for the <strong>entire
design</strong>. If you do not add a corresponding
<em>-debug_access*</em> switch, then <em>-debug_access</em> is
automatically added. Note that you must also set
<strong>VERDI_HOME</strong>.</p>
<blockquote>
<p>$ ./simv</p>
<p>FSDB Dumper for VCS, Release Verdi_S-2021.09-SP2-2, Linux
x86_64/64bit, 05/22/2022 (C) 1996 - 2022 by Synopsys, Inc. *Verdi* :
Create FSDB file 'novas.fsdb' *Verdi* : Begin traversing the scopes,
layer (0). *Verdi* : End of traversing.</p>
</blockquote>
<p><strong>+vcs+vcdpluson</strong>: A <strong>compile-time</strong>
substitute for <code>$vcdpluson</code> system task. The
<em>+vcs+vcdpluson</em> switch enables dumping for the <strong>entire
design</strong>. If you do not add a corresponding
<em>-debug_access*</em> switch, then <em>-debug_access</em> is
automatically added</p>
<blockquote>
<p>$ ./simv</p>
<p>VCD+ Writer S-2021.09-SP2-2_Full64 Copyright (c) 1991-2021 by
Synopsys Inc.</p>
</blockquote>
<p><strong>+incdir+&lt;directory&gt;</strong>: Specifies the directories
that contain the files you specified with the `<code>include</code>
compiler directive. You can specify more than on directory, separating
each path name with the <code>+</code> character.</p>
<h3 id="compile-time-use-model">Compile time Use Model</h3>
<p>Just add the <code>-kdb</code> option to VCS executables when running
simulation</p>
<ul>
<li><p>Three steps flow:</p>
<ul>
<li><p><code>vlogan/vhdlan/syscan -kdb</code></p>
<p>Compile design and generate un-resolved KDB to
<em>./work</em></p></li>
<li><p><code>vcs -kdb -debug_access+all &lt;other option&gt;</code></p>
<p>Generate elaborated KDB to <em>./sim.dadir</em></p></li>
</ul></li>
<li><p>Two steps flow:</p>
<ul>
<li><p><code>vcs -kdb -debug_access+all &lt;other option&gt;</code></p>
<p>Compile design and generate elaborated KDB to
<em>./simv.dadir</em></p></li>
</ul></li>
</ul>
<h2 id="common-simv-option">Common <code>simv</code> Option</h2>
<p><code>-gv &lt;gen=value&gt;</code>: override runtime VHDL generics
*</p>
<p><code>-ucli</code>: stop at Tcl prompt upon start-up</p>
<p><code>-i &lt;run.tcl&gt;</code>: execute specified Tcl script upon
start-up</p>
<p><code>-l &lt;logfile&gt;</code>: create runtime logfile</p>
<p><code>-gui</code>: create runtime logfile</p>
<p><code>-xlrm</code>: allow relaxed/non-LRM compliant code</p>
<p><code>-cm &lt;options&gt;</code>: enable coverate options</p>
<h2 id="verdi-binkey">verdi binkey</h2>
<p><code>SHIFT+A</code>: <em>Find Signal/Find Instance/Find
Instport</em></p>
<p><code>SHIFT+S</code>: <em>Find Scope</em></p>
<h3 id="module-traverse">module traverse</h3>
<p><img src="/2022/02/08/vcs-verdi/image-20220527165858163.png"
alt="image-20220527165858163" /></p>
<blockquote>
<p><em>Show Calling</em></p>
<p><em>Show Definition</em></p>
<p>Double-Click <strong>instance name</strong> is same with click
<em>Show Definition</em></p>
<p>Double-Click <strong>module name</strong> is same with click <em>Show
Calling</em></p>
</blockquote>
<h3 id="signal-traverse">signal traverse</h3>
<p><img src="/2022/02/08/vcs-verdi/image-20220527201122708.png"
alt="image-20220527201122708" /></p>
<blockquote>
<p><em>Driver</em></p>
<p><em>Load</em></p>
<p>Double-Click <strong>signal name</strong> is same with click
<em>Driver</em></p>
</blockquote>
<h2 id="verdi-options">Verdi options</h2>
<p><code>-ssf fastFile(s)|dumpFile(s)|fastFile list(s)</code>: Load FSDB
(*.fsdb), virtual FSDB (*.vf) , gzipped FSDB (*.fsdb.gz), bzip2 FSDB
(*.fsdb.bz2), waveform dump (*.vcd, *.vcd.gz) files, or FSDB file list
(*.flst)</p>
<p><code>-simBin &lt;simv_executable&gt;</code>: Specify the path of the
simulation binary file.</p>
<p><img src="/2022/02/08/vcs-verdi/image-20220604220225513.png"
alt="image-20220604220225513" /></p>
<p><code>-dbdir</code>: Specify the daidir (simv.daidir ) directory to
load</p>
<blockquote>
<p>In the VCS two-step flow, the VCS generated KDB (kdb.elab++) is saved
under the simv.daidir/ directory (like
<code>simv.daidir</code>/kdb.elab++).</p>
</blockquote>
<p><code>-f file_name / -file file_name</code>: Load an ASCII file
containing design source files and additional simulator options</p>
<h2 id="import-design-from-ufe">Import Design from UFE</h2>
<blockquote>
<p><strong>Knowledge Database (KDB)</strong>: As it compiles the design,
the Verdi platform uses its internal synthesis technology to recognize
and extract specific structural, logical, and functional information
about the design and stores the resulting detailed design information in
the KDB</p>
</blockquote>
<p>The Unified Compiler Flow (UFE) uses VCS with the <code>-kdb</code>
option and the generated <code>simv.daidar</code> includes the
<strong>KDB</strong> information</p>
<ol type="1">
<li><p><code>verdi -dbdir simv.daidir</code></p>
<p>Use the new -dbdir option to specify the simv.daidir
directory</p></li>
<li><p><code>verdi -simBin simv</code></p>
<p>Load <code>simv.daidir</code> from <em>the <strong>same
directory</strong> as <code>simv</code></em> and invoke Verdi if
<code>simv.daidir</code> is available</p></li>
<li><p><code>verdi -ssf novas.fsdb</code></p>
<p>Load KDB automatically from FSDB,</p></li>
</ol>
<blockquote>
<p>For 2 and 3, use the <code>-dbdir</code> option to load
<em>simv.dadir</em> if you have move it to somewhere else</p>
</blockquote>
<h2 id="reference-design-and-fsdb-on-the-command-line">Reference Design
and FSDB on the Command Line</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verdi -f &lt;source_file_name&gt; -ssf &lt;fsdb_file_name&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Where, source_file_name is the source file name and fsdb_file_name is
the name of the FSDB file</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>Verdi使用总结 URL: <a
href="https://www.wenhui.space/docs/07-ic-verify/tools/verdi_userguide/">https://www.wenhui.space/docs/07-ic-verify/tools/verdi_userguide/</a></p>
<p><a
href="https://www.youtube.com/watch?v=cFHKjDzoPyY&amp;ab_channel=Synopsys">Using
Verdi for Design Understanding - Driver/Load Tracing in Verdi |
Synopsys</a></p>
<p><a
href="https://www.youtube.com/watch?v=yjs7R5UWOEw&amp;ab_channel=Synopsys">Using
Verdi for Design Understanding - Connectivity Tracing and FSM Extraction
in Verdi | Synopsys</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>variables with statistical distribution</title>
    <url>/2023/10/05/varstat/</url>
    <content><![CDATA[<p><code>Specifying Parameter Distributions Using Statistics Blocks</code></p>
<ul>
<li><code>process</code>: generate random number once per MC run</li>
<li><code>mismatch</code> : generate a random number per instance</li>
</ul>
<p><img src="/2023/10/05/varstat/image-20231005190644654.png"
alt="image-20231005190644654" /></p>
<p><img src="/2023/10/05/varstat/image-20231005190712057.png"
alt="image-20231005190712057" /></p>
<p><img src="/2023/10/05/varstat/image-20231005190724560.png"
alt="image-20231005190724560" /></p>
<h2 id="reference">reference</h2>
<p>Article (20498356) Title: How to vary design variables with
statistical distribution to be used with Monte Carlo analysis URL: <a
href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009ErHHEA0">https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1O3w000009ErHHEA0</a></p>
<p>Spectre Circuit Simulator Reference</p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
  </entry>
  <entry>
    <title>verilog constant part-select and indexed part-select</title>
    <url>/2022/02/11/verilog-constant-part-select-and-variable-part-select/</url>
    <content><![CDATA[<p>A range of contiguous bits can be selected and is known as
<strong>part-select</strong>. There are two types of part-selects, one
with a <strong>constant part-select</strong> and another with an
<strong>indexed part-select</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line">addr [<span class="number">23</span>:<span class="number">16</span>] = <span class="number">8&#x27;h23</span>; <span class="comment">//bits 23 to 16 will be replaced by the new value &#x27;h23 -&gt; constant part-select</span></span><br></pre></td></tr></table></figure>
<p>Having a variable part-select allows it to be used effectively in
loops to select parts of the vector. Although the starting bit can be
<strong>varied</strong>, the width has to be
<strong>constant</strong>.</p>
<blockquote>
<p><strong>[&lt;start_bit +: <width>] // part-select increments from
start-bit</strong></p>
<p><strong>[&lt;start_bit -: <width>] // part-select decrements from
start-bit</strong></p>
</blockquote>
<p><strong>Example</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>: <span class="number">0</span>] a_vect;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">0</span> :<span class="number">31</span>] b_vect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">63</span>: <span class="number">0</span>] dword;</span><br><span class="line"><span class="keyword">integer</span> sel;</span><br><span class="line"></span><br><span class="line">a_vect[ <span class="number">0</span> +: <span class="number">8</span>] <span class="comment">// == a_vect[ 7 : 0]</span></span><br><span class="line">a_vect[<span class="number">15</span> -: <span class="number">8</span>] <span class="comment">// == a_vect[15 : 8]</span></span><br><span class="line">b_vect[ <span class="number">0</span> +: <span class="number">8</span>] <span class="comment">// == b_vect[0 : 7]</span></span><br><span class="line">b_vect[<span class="number">15</span> -: <span class="number">8</span>] <span class="comment">// == b_vect[8 :15]</span></span><br><span class="line"></span><br><span class="line">dword[<span class="number">8</span>*sel +: <span class="number">8</span>] <span class="comment">// variable part-select with fixed width</span></span><br></pre></td></tr></table></figure>
<p><strong>ref</strong></p>
<p><a
href="https://www.chipverify.com/verilog/verilog-scalar-vector#:~:text=Part%2Dselects,with%20an%20indexed%20part%2Dselect.&amp;text=Having%20a%20variable%20part%2Dselect,select%20parts%20of%20the%20vector.">Verilog
scalar and vector</a></p>
<p><a
href="https://electronics.stackexchange.com/questions/74277/what-is-the-operator-called-in-verilog">What
is the "+:" operator called in Verilog?</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>verilog readmemb and readmemh</title>
    <url>/2022/02/12/verilog-readmemb/</url>
    <content><![CDATA[<p><strong><code>$readmemh("hex_memory_file.mem", memory_array, [start_address], [end_address])</code></strong>
<strong><code>$readmemb("bin_memory_file.mem", memory_array, [start_address], [end_address])</code></strong></p>
<p>The system task has no versions to accept octal data or decimal
data.</p>
<ul>
<li>The 1st argument is the data file name.</li>
<li>The 2nd argument is the array to receive the data.</li>
<li>The 3rd argument is an optional start address, and if you provide
it, you can also provide</li>
<li>The 4th argument optional end address.</li>
</ul>
<p>Note, the 3rd and 4th argument address is for array not data
file.</p>
<p>If the memory addresses are not specified anywhere, then the system
tasks load file data sequentially from the lowest address toward the
highest address.</p>
<blockquote>
<p>The standard before 2005 specify that the system tasks load file data
sequentially from the left memory address bound to the right memory
address bound.</p>
</blockquote>
<p><strong>readtest.v</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> readfile;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] array4 [<span class="number">0</span>:<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] array7 [<span class="number">6</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] array12 [<span class="number">11</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">integer</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="built_in">$readmemb</span>(<span class="string">&quot;data.txt&quot;</span>, array4);</span><br><span class="line">		<span class="built_in">$readmemb</span>(<span class="string">&quot;data.txt&quot;</span>, array7, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="built_in">$readmemb</span>(<span class="string">&quot;data.txt&quot;</span>, array12);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i = i+<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">$display</span>(<span class="string">&quot;array4[%0d] = %b&quot;</span>, i, array4[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i = i+<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">$display</span>(<span class="string">&quot;array7[%0d] = %b&quot;</span>, i, array7[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i = i+<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">$display</span>(<span class="string">&quot;array12[%0d] = %b&quot;</span>, i, array12[i]);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>data.txt</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 </span><br><span class="line">00000001</span><br><span class="line">00000010</span><br><span class="line">00000011</span><br><span class="line">00000100</span><br><span class="line">00000101</span><br><span class="line">00000110</span><br><span class="line">00001000</span><br></pre></td></tr></table></figure>
<p><strong>result</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array4[0] = 00000000</span><br><span class="line">array4[1] = 00000001</span><br><span class="line">array4[2] = 00000010</span><br><span class="line">array4[3] = 00000011</span><br><span class="line">=========================</span><br><span class="line">array7[0] = xxxxxxxx</span><br><span class="line">array7[1] = xxxxxxxx</span><br><span class="line">array7[2] = 00000000</span><br><span class="line">array7[3] = 00000001</span><br><span class="line">array7[4] = 00000010</span><br><span class="line">array7[5] = 00000011</span><br><span class="line">array7[6] = xxxxxxxx</span><br><span class="line">=========================</span><br><span class="line">array12[0] = 00000000</span><br><span class="line">array12[1] = 00000001</span><br><span class="line">array12[2] = 00000010</span><br><span class="line">array12[3] = 00000011</span><br><span class="line">array12[4] = 00000100</span><br><span class="line">array12[5] = 00000101</span><br><span class="line">array12[6] = 00000110</span><br><span class="line">array12[7] = 00001000</span><br><span class="line">array12[8] = xxxxxxxx</span><br><span class="line">array12[9] = xxxxxxxx</span><br><span class="line">array12[10] = xxxxxxxx</span><br><span class="line">array12[11] = xxxxxxxx</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>ref</strong></p>
<p><a
href="https://projectf.io/posts/initialize-memory-in-verilog/">Initialize
Memory in Verilog</a></p>
]]></content>
      <categories>
        <category>digital</category>
      </categories>
  </entry>
  <entry>
    <title>compile vim from source with GUI support</title>
    <url>/2022/02/02/vim-compile/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gtk3 in Rocky Linux 8.5</span></span><br><span class="line">./configure --with-features=huge --enable-gui=gtk3 --enable-python3interp --prefix=/usr</span><br><span class="line">make -j`<span class="built_in">nproc</span>`</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="binkey">binkey</h2>
<p>Inserting a new line below: <code>o</code></p>
<p>above: <code>O</code></p>
<p>To insert before the cursor: <code>i</code></p>
<p>After: <code>a</code></p>
<p>Before the line (home): <code>I</code></p>
<p>Append at the end of line: <code>A</code></p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Custom Bindkey of Cadence Virtuoso</title>
    <url>/2022/04/13/virtuoso-bindkey/</url>
    <content><![CDATA[<h2 id="schbindkeys.il">schBindKeys.il</h2>
<blockquote>
<p>schematic</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias bk hiSetBindKey</span><br><span class="line">when ( isCallable(&#x27;schGetEnv&#x27;)</span><br><span class="line">bk(&quot;Schematics&quot; &quot;Ctrl&lt;Key&gt;x&quot; &quot;schHiCreateInst(\&quot;basic\&quot; \&quot;nonConn\&quot; \&quot;symbol\&quot;)&quot;)</span><br><span class="line">bk(&quot;Schematics&quot; &quot;Ctrl&lt;Key&gt;v&quot; &quot;schHiCreateInst(\&quot;analogLib\&quot; \&quot;vdc\&quot; \&quot;symbol\&quot;)&quot;)</span><br><span class="line">bk(&quot;Schematics&quot; &quot;Ctrl&lt;Key&gt;g&quot; &quot;schHiCreateInst(\&quot;analogLib\&quot; \&quot;gnd\&quot; \&quot;symbol\&quot;)&quot;)</span><br><span class="line">bk(&quot;Schematics&quot; &quot;Shift&lt;Key&gt;9&quot; &quot;geDeleteNetProbe()&quot;)</span><br><span class="line">bk(&quot;Schematics&quot; &quot;&lt;Key&gt;0&quot; &quot;geDeleteAllProbe(getCurrentWindow()t)&quot;)</span><br><span class="line">)</span><br><span class="line">unalias bk</span><br></pre></td></tr></table></figure>
<h2 id="lebindkeys.il">leBindKeys.il</h2>
<blockquote>
<p>layout</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias bk hiSetBindKey</span><br><span class="line">when ( isCallable(&#x27;leGetEnv)</span><br><span class="line">    bk(&quot;Layout&quot; &quot;&lt;Key&gt;1&quot; &quot;leSetEntryLayer(\&quot;M0PO\&quot;) leSetAllLayerVisible(nil) leSetEntryLayer(\&quot;M0OD\&quot;) leSetEntryLayer(\&quot;VIA0\&quot;) leSetEntryLayer(list(\&quot;M1\&quot; \&quot;pin\&quot;)) leSetEntryLayer(\&quot;M1\&quot;) hiRedraw()&quot; )</span><br><span class="line">    ; M1-VIA1-M2</span><br><span class="line">    bk(&quot;Layout&quot; &quot;&lt;Key&gt;2&quot; &quot;leSetEntryLayer(\&quot;M1\&quot;) leSetAllLayerVisible(nil) leSetEntryLayer(\&quot;VIA1\&quot;) leSetEntryLayer(list(\&quot;M2\&quot; \&quot;pin\&quot;)) leSetEntryLayer(\&quot;M2\&quot;) hiRedraw()&quot; )</span><br><span class="line">    ; M2-VIA2-M3</span><br><span class="line">    bk(&quot;Layout&quot; &quot;&lt;Key&gt;3&quot; &quot;leSetEntryLayer(\&quot;M2\&quot;) leSetAllLayerVisible(nil) leSetEntryLayer(\&quot;VIA2\&quot;) leSetEntryLayer(list(\&quot;M3\&quot; \&quot;pin\&quot;)) leSetEntryLayer(\&quot;M3\&quot;) hiRedraw()&quot; )</span><br><span class="line">    ; M3-VIA3-M4</span><br><span class="line">    bk(&quot;Layout&quot; &quot;&lt;Key&gt;4&quot; &quot;leSetEntryLayer(\&quot;M3\&quot;) leSetAllLayerVisible(nil) leSetEntryLayer(\&quot;VIA3\&quot;) leSetEntryLayer(list(\&quot;M4\&quot; \&quot;pin\&quot;)) leSetEntryLayer(\&quot;M4\&quot;) hiRedraw()&quot; )</span><br><span class="line">    ; M4-VIA4-M5</span><br><span class="line">	; select M4 layer, turn off other layer visibilty, select VIA4 M5_pin M5 and turn on them</span><br><span class="line">    bk(&quot;Layout&quot; &quot;&lt;Key&gt;5&quot; &quot;leSetEntryLayer(\&quot;M4\&quot;) leSetAllLayerVisible(nil) leSetEntryLayer(\&quot;VIA4\&quot;) leSetEntryLayer(list(\&quot;M5\&quot; \&quot;pin\&quot;)) leSetEntryLayer(\&quot;M5\&quot;) hiRedraw()&quot; )</span><br><span class="line">    ; all visiable</span><br><span class="line">    bk(&quot;Layout&quot; &quot;&lt;Key&gt;0&quot; &quot;leSetAllLayerVisible(t) hiRedraw()&quot; )</span><br><span class="line">)</span><br><span class="line">unalias bk</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>virtuoso &quot;dlopen failed to open &#39;libdl.so&#39;&quot;</title>
    <url>/2022/09/24/virtuoso-dlopen-libdl/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install glibc-devel  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Last metadata expiration check: 0:01:02 ago on Sat 24 Sep 2022 12:13:54 AM CST.                                                         </span><br><span class="line">Dependencies resolved.</span><br><span class="line">=========================================================================================================================================</span><br><span class="line"> Package                            Architecture              Version                                    Repository                 Size</span><br><span class="line">=========================================================================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> glibc-devel                        x86_64                    2.28-189.5.el8_6                           baseos                     78 k</span><br><span class="line">Installing dependencies:</span><br><span class="line"> glibc-headers                      x86_64                    2.28-189.5.el8_6                           baseos                    482 k</span><br><span class="line"> kernel-headers                     x86_64                    4.18.0-372.26.1.el8_6                      baseos                    9.4 M</span><br><span class="line"> libxcrypt-devel                    x86_64                    4.1.1-6.el8                                baseos                     24 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">=========================================================================================================================================</span><br><span class="line">Install  4 Packages</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>Voltage-Mode Driver Equalization</title>
    <url>/2022/07/09/vm-drv-eq/</url>
    <content><![CDATA[<h2 id="sst-driver">SST Driver</h2>
<h3 id="sharing-termination-in-sst-transmitter">sharing termination in
SST transmitter</h3>
<p><img src="/2022/07/09/vm-drv-eq/tx_leg.drawio.svg"
alt="tx_leg.drawio" /></p>
<p>Sharing termination keep a constant current through leg, which
improve TX speed in this way. On the other hand, the sharing termination
facilitate drain/source sharing technique in layout.</p>
<h3 id="pull-up-and-pull-down-resistor">pull-up and pull-down
resistor</h3>
<p><img src="/2022/07/09/vm-drv-eq/sst-evolution.png"
alt="sst-evolution" /></p>
<p><strong>Original stacked structure</strong></p>
<p>Pro's:</p>
<p>​ smaller static current when both pull up and pull down path is
on</p>
<p>Con's:</p>
<p>​ slowly switching due to parasitic capacitance behind pull-up and
pull-down resistor</p>
<p><strong>with single shared linearization resistor</strong></p>
<p>Pro's:</p>
<p>​ The parasitic capacitance behind the resistor still exists but is
now always driven high or low actively</p>
<p>Con's:</p>
<p>​ more static current</p>
<h2 id="vm-driver-equalization---differential-ended-termination">VM
Driver Equalization - differential ended termination</h2>
<p><span class="math display">\[
V_o = D_{n+1}C_{-1}+D_nC_0+D_{n-1}C_{+1}
\]</span></p>
<p>where <span class="math inline">\(D_n \in \{-1, 1\}\)</span></p>
<p><img src="/2022/07/09/vm-drv-eq/vdrv.drawio.svg" alt="vdrv.drawio" />
<span class="math display">\[
V_{\text{rx}} = V_{\text{dd}} \frac{(R_2-R_1)R_T}{R_1R_T+R_2R_T+R_1R_2}
\]</span> With <span class="math inline">\(R_u=(L+M+N)R_T\)</span></p>
<p>Normalize above equation, obtain <span class="math display">\[
V_{\text{rx,norm}} = \frac{(R_2-R_1)R_T}{R_1R_T+R_2R_T+R_1R_2}
\]</span></p>
<table>
<thead>
<tr class="header">
<th></th>
<th><span class="math inline">\(D_{n-1}\)</span></th>
<th><span class="math inline">\(D_{n}\)</span></th>
<th><span class="math inline">\(D_{n+1}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(C_{-1}\)</span></td>
<td>1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr class="even">
<td><span class="math inline">\(C_0\)</span></td>
<td>-1</td>
<td>1</td>
<td>-1</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(C_{+1}\)</span></td>
<td>-1</td>
<td>-1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Where precursor <span class="math inline">\(R_L = L\times
R_T\)</span>, main cursor <span class="math inline">\(R_M = M\times
R_T\)</span> and post cursor <span class="math inline">\(R_N = N\times
R_T\)</span></p>
<p><img src="/2022/07/09/vm-drv-eq/image-20220709151054840.png"
alt="image-20220709151054840" /></p>
<h3 id="equation-1">Equation-1</h3>
<blockquote>
<p><span class="math inline">\(D_{n-1}D_nD_{n+1}=1,-1,-1\)</span></p>
</blockquote>
<p><img src="/2022/07/09/vm-drv-eq/pre.drawio.svg"
alt="pre.drawio" /></p>
<p><span class="math display">\[\begin{align}
R_1 &amp;= R_N \\
&amp;= \frac{R_u}{N} \\
R_2 &amp;= R_L\parallel R_M \\
&amp;= \frac{R_u}{L+M}
\end{align}\]</span></p>
<p>We obtain <span class="math display">\[
V_{L}= \frac{1}{2}\cdot\frac{N-(L+M)}{L+M+N}
\]</span></p>
<h3 id="equation-2">Equation-2</h3>
<blockquote>
<p><span class="math inline">\(D_{n-1}D_nD_{n+1}=-1,1,-1\)</span></p>
</blockquote>
<p><img src="/2022/07/09/vm-drv-eq/main.drawio.svg"
alt="main.drawio" /></p>
<p>with <span class="math inline">\(R_1=R_T\)</span> and <span
class="math inline">\(R_2=+\infty\)</span>, we obtain <span
class="math display">\[
V_M = \frac{1}{2}
\]</span></p>
<h3 id="equation-3">Equation-3</h3>
<blockquote>
<p><span class="math inline">\(D_{n-1}D_nD_{n+1}=-1,-1,1\)</span></p>
</blockquote>
<p><span class="math display">\[\begin{align}
R_1 &amp;= R_L \\
&amp;= \frac{R_u}{L} \\
R_2 &amp;= R_N\parallel R_M \\
&amp;= \frac{R_u}{N+M}
\end{align}\]</span></p>
<p>We obtain <span class="math display">\[
V_N = \frac{1}{2}\cdot\frac{L-(N+M)}{L+M+N}
\]</span></p>
<h3 id="obtain-fir-coefficients">Obtain FIR coefficients</h3>
<p>We define <span class="math display">\[\begin{align}
l &amp;= \frac{L}{L+M+N} \\
m &amp;= \frac{M}{L+M+N} \\
n &amp;= \frac{N}{L+M+N}
\end{align}\]</span></p>
<p>where <span class="math inline">\(l+m+n=1\)</span></p>
<p>Due to Eq1 ~ Eq3 <span class="math display">\[
\left\{ \begin{array}{cl}
C_{-1}-C_0-C_1 &amp; = \frac{1}{2}(n-l-m) \\
-C_{-1}+C_0-C_1 &amp; = \frac{1}{2} \\
-C_{-1}-C_0+C_1 &amp; = \frac{1}{2}(l-n-m)
\end{array} \right.
\]</span> After scaling, we get <span class="math display">\[
\left\{ \begin{array}{cl}
C_{-1}-C_0-C_1 &amp; = -l-m+n \\
-C_{-1}+C_0-C_1 &amp; = l+m+n \\
-C_{-1}-C_0+C_1 &amp; = l-m-n
\end{array} \right.
\]</span> Then, <strong>the relationship between FIR coefficients and
legs is clear</strong>, i.e. <span class="math display">\[\begin{align}
C_{-1} &amp;= -\frac{L}{L+M+N} \\
C_{0} &amp;= \frac{M}{L+M+N} \\
C_{1} &amp;= -\frac{N}{L+M+N}
\end{align}\]</span></p>
<p>For example, <span class="math inline">\(C_{-1}=-0.1\)</span>, <span
class="math inline">\(C_0=0.7\)</span> and <span
class="math inline">\(C_1=-0.2\)</span> <span class="math display">\[
H(z) = -0.1+0.7z^{-1}-0.2z^{-2}
\]</span> <img src="/2022/07/09/vm-drv-eq/image-20220709185832444.png"
alt="image-20220709185832444" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">w = [<span class="number">-0.1</span>, <span class="number">0.7</span>, <span class="number">-0.2</span>];</span><br><span class="line">Fs = <span class="number">32e9</span>;</span><br><span class="line">[mag, w] = freqz(w, <span class="number">1</span>, [], Fs);</span><br><span class="line"><span class="built_in">plot</span>(w/<span class="number">1e9</span>, <span class="built_in">abs</span>(mag));</span><br><span class="line">xlabel(<span class="string">&#x27;Freq(GHz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<h2 id="vm-driver-equalization---single-ended-termination">VM Driver
Equalization - single ended termination</h2>
<h3 id="equation-1-1">Equation-1</h3>
<p><img src="/2022/07/09/vm-drv-eq/pre_se.drawio.svg"
alt="pre_se.drawio" /></p>
<p><span class="math display">\[\begin{align}
V_{\text{rxp}} &amp;= \frac{1}{2} \cdot \frac{N}{L+M+N} \\
V_{\text{rxm}} &amp;= \frac{1}{2} \cdot \frac{L+M}{L+M+N}
\end{align}\]</span> So <span class="math display">\[
V_{L}= \frac{1}{2}\cdot\frac{N-(L+M)}{L+M+N}
\]</span> which is same with differential ended termination</p>
<h3 id="equation-2-1">Equation-2</h3>
<p><img src="/2022/07/09/vm-drv-eq/main_se.drawio.svg"
alt="main_se.drawio" /></p>
<p><span class="math display">\[\begin{align}
V_{\text{rxp}} &amp;= \frac{1}{2} \\
V_{\text{rxm}} &amp;= 0
\end{align}\]</span> So <span class="math display">\[
V_{M}= \frac{1}{2}
\]</span> which is same with differential ended termination</p>
<h3 id="equation-3-1">Equation-3</h3>
<p><span class="math display">\[
V_{N}= \frac{1}{2}\cdot\frac{L-(N+M)}{L+M+N}
\]</span></p>
<h3 id="obtain-fir-coefficients-1">Obtain FIR coefficients</h3>
<p>Same with differential ended termination driver.</p>
<h2 id="basic-feed-forward-equalization-theory">Basic Feed Forward
Equalization Theory</h2>
<p><img src="/2022/07/09/vm-drv-eq/image-20220709111229772.png"
alt="image-20220709111229772" /></p>
<p><img src="/2022/07/09/vm-drv-eq/image-20220709112543338.png"
alt="image-20220709112543338" /></p>
<p><img src="/2022/07/09/vm-drv-eq/image-20220709125046329.png"
alt="image-20220709125046329" /></p>
<blockquote>
<p>Pre-cursor FFE can compensate phase distortion through the
channel</p>
</blockquote>
<p><img src="/2022/07/09/vm-drv-eq/image-20220709130050057.png"
alt="image-20220709130050057" /></p>
<blockquote>
<p>Single-ended termination</p>
<p>Differential termination</p>
</blockquote>
<h2 id="reference">reference</h2>
<p>J. F. Bulzacchelli et al., "A 28-Gb/s 4-Tap FFE/15-Tap DFE Serial
Link Transceiver in 32-nm SOI CMOS Technology," in IEEE Journal of
Solid-State Circuits, vol. 47, no. 12, pp. 3232-3248, Dec. 2012, doi:
10.1109/JSSC.2012.2216414.</p>
<p>Jhwan Kim, CICC 2022, ES4-4: Transmitter Design for High-speed Serial
Data Communications</p>
]]></content>
      <categories>
        <category>analog</category>
      </categories>
  </entry>
  <entry>
    <title>Build VMware host modules</title>
    <url>/2024/01/30/vmware-module/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:mkubecek/vmware-host-modules.git</span><br><span class="line">cd vmware-host-modules/</span><br><span class="line">git checkout origin/workstation-17.0.2</span><br><span class="line">make -j`nproc`</span><br><span class="line">sudo make install</span><br><span class="line">sudo modprobe -v vmmon</span><br><span class="line">sudo modprobe -v vmnet</span><br><span class="line">sudo vmware-networks --start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
  </entry>
  <entry>
    <title>Design Variable in analogLib-vpwlf</title>
    <url>/2022/05/14/vpwlf-designvar/</url>
    <content><![CDATA[<p><code>PWL File as Design Var?</code> parameter in <em>vpwlf</em> cell
is convenient for sweep simulation or corner simulation, wherein there
are multiple pwl files .</p>
<p><img src="/2022/05/14/vpwlf-designvar/image-20220514121048124.png"
alt="image-20220514121048124" /></p>
<p>The file path should be surrounded with
<strong>double-quotes</strong> to be protected from evaluation.</p>
<p><img src="/2022/05/14/vpwlf-designvar/image-20220514121150988.png"
alt="image-20220514121150988" /></p>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>virtuoso</tag>
      </tags>
  </entry>
  <entry>
    <title>The z-Transform and Its Application</title>
    <url>/2022/03/22/z-Transform/</url>
    <content><![CDATA[<h2 id="fir-equalization">FIR Equalization</h2>
<h3 id="frequency-response">Frequency Response</h3>
<p><img src="/2022/03/22/z-Transform/image-20220322093428287.png"
alt="image-20220322093428287" /> <span class="math display">\[
z = e^{j\omega T_s}
\]</span></p>
<h3 id="unit-impulse">Unit impulse</h3>
<p>filter coefficients are <strong>[-0.131, 0.595, -0.274]</strong> and
sampling period is <strong>100ps</strong></p>
<p><img src="/2022/03/22/z-Transform/image-20220428125454912.png"
alt="image-20220428125454912" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Frequency response</span></span><br><span class="line">w = [<span class="number">-0.131</span>, <span class="number">0.595</span>, <span class="number">-0.274</span>];</span><br><span class="line">Ts = <span class="number">100e-12</span>;</span><br><span class="line">[mag, w] = freqz(w, <span class="number">1</span>, [], <span class="number">1</span>/Ts);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(w/<span class="number">1e9</span>, <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(mag)));</span><br><span class="line">xlabel(<span class="string">&#x27;Freq(GHz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;dB&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&#x27;frequency response&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% unit impulse response from transfer function</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">z = tf(<span class="string">&#x27;z&#x27;</span>, Ts);</span><br><span class="line">h = <span class="number">-0.131</span> + <span class="number">0.595</span>*z^(<span class="number">-1</span>) <span class="number">-0.274</span>*z^(<span class="number">-2</span>);</span><br><span class="line">[y, t] = impulse(h);</span><br><span class="line">stem(t*<span class="number">1e10</span>, y*Ts);  <span class="comment">% !!! y*Ts is essential</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;unit impulse response&quot;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(\times 100ps)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;mag&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>impulse</code>:</p>
<p>For discrete-time systems, the impulse response is the response to a
unit area pulse of length <code>Ts</code> and height <code>1/Ts</code>,
where <code>Ts</code> is the sample time of the system. (This pulse
approaches <span class="math inline">\(\delta(t)\)</span> as
<code>Ts</code> approaches zero.)</p>
<p>Scale output:</p>
<p>Multiply <code>impulse</code> output with sample period
<code>Ts</code> in order to correct <code>1/Ts</code> height of
<code>impulse</code> function.</p>
</blockquote>
<h3 id="psd-transformation">PSD transformation</h3>
<p>If we have power spectrum or power spectrum density of <strong>both
edge's absolute jitter</strong> (<span
class="math inline">\(x(n)\)</span>) , <span
class="math inline">\(P_{\text{xx}}\)</span></p>
<p>Then <strong>1UI</strong> jitter is <span
class="math inline">\(x_{\text{1UI}}(n)=x(n)-x(n-1)\)</span>, and
<strong>Period</strong> jitter is <span
class="math inline">\(x_{\text{Period}}(n)=x(n)-x(n-2)\)</span>, which
can be modeled as FIR filter, <span class="math inline">\(H(\omega) =
1-z^{-k}\)</span>, i.e. <span class="math inline">\(k=1\)</span> for
<strong>1UI</strong> jitter and <span class="math inline">\(k=2\)</span>
<strong>Period</strong> jitter <span
class="math display">\[\begin{align}
P_{\text{xx}}&#39;(\omega) &amp;= P_{\text{xx}}(\omega) \cdot \left|
1-z^{-k}  \right|^2 \\
&amp;= P_{\text{xx}}(\omega) \cdot \left| 1-(e^{j\omega
T_s})^{-k}  \right|^2 \\
&amp;= P_{\text{xx}}(\omega) \cdot \left| 1-e^{-j\omega T_s
k}  \right|^2
\end{align}\]</span></p>
<p><img src="/2022/03/22/z-Transform/image-20220519172239916.png"
alt="image-20220519172239916" /></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">xf_fs = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.5</span>;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">H_1UI = <span class="number">1</span> - <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*xf_fs);</span><br><span class="line">HH_1UI = <span class="built_in">abs</span>(H_1UI).^<span class="number">2</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(xf_fs, HH_1UI);</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Freq&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;|H|^2&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Weight for 1UI jitter&#x27;</span>);</span><br><span class="line"></span><br><span class="line">k = <span class="number">2</span>;</span><br><span class="line">H_period = <span class="number">1</span> - <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*xf_fs);</span><br><span class="line">HH_period = <span class="built_in">abs</span>(H_period).^<span class="number">2</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(xf_fs, HH_period);</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Freq&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;|H|^2&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Weight for Period jitter&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/z-Transform/image-20220709104127384.png"
alt="image-20220709104127384" /> <span class="math display">\[
x(t-\Delta T)\overset{FT}{\longrightarrow} X(s)e^{-\Delta T \cdot s}
\]</span></p>
<h2 id="reference">reference</h2>
<p><a
href="https://people.engr.tamu.edu/spalermo/ecen689/lecture7_ee720_eq_intro_txeq.pdf">Sam
Palermo, ECEN720, Lecture 7: Equalization Introduction &amp; TX FIR
Eq</a></p>
<p><a
href="https://people.engr.tamu.edu/spalermo/ecen689/ECEN720_lab5_2021.pdf">Sam
Palermo, ECEN720, Lab5 –Equalization Circuits</a></p>
<p>B. Razavi, "The z-Transform for Analog Designers [The Analog Mind],"
IEEE Solid-State Circuits Magazine, Volume. 12, Issue. 3, pp. 8-14,
Summer 2020.</p>
<p>Jhwan Kim, CICC 2022, ES4-4: Transmitter Design for High-speed Serial
Data Communications</p>
<p>Mathuranathan. Digital filter design – Introduction <a
href="https://www.gaussianwaves.com/2020/02/introduction-to-digital-filter-design/">https://www.gaussianwaves.com/2020/02/introduction-to-digital-filter-design/</a></p>
]]></content>
      <categories>
        <category>dsp</category>
      </categories>
  </entry>
</search>
